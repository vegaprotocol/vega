// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/protos/data-node/api/v2"
	"code.vegaprotocol.io/vega/protos/vega"
	"code.vegaprotocol.io/vega/protos/vega/data/v1"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

type DataSourceKind interface {
	IsDataSourceKind()
}

// Union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind
type Event interface {
	IsEvent()
}

type ExternalDataSourceKind interface {
	IsExternalDataSourceKind()
}

type GameEntity interface {
	IsGameEntity()
}

type GovernanceTransferKind interface {
	IsGovernanceTransferKind()
}

type InternalDataSourceKind interface {
	IsInternalDataSourceKind()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProductConfiguration interface {
	IsProductConfiguration()
}

type ProductData interface {
	IsProductData()
}

type ProposalChange interface {
	IsProposalChange()
}

type ProposalNode interface {
	IsProposalNode()
}

type RiskModel interface {
	IsRiskModel()
}

type SignerKind interface {
	IsSignerKind()
}

type StopOrderTrigger interface {
	IsStopOrderTrigger()
}

type TransferKind interface {
	IsTransferKind()
}

type TriggerKind interface {
	IsTriggerKind()
}

// One of the possible asset sources for update assets proposals
type UpdateAssetSource interface {
	IsUpdateAssetSource()
}

type UpdateMarketRiskParameters interface {
	IsUpdateMarketRiskParameters()
}

type UpdateProductConfiguration interface {
	IsUpdateProductConfiguration()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// Margins for a hypothetical position not related to any existing party
type AbstractMarginLevels struct {
	// Market in which the margin is required for this party
	Market *vega.Market `json:"market"`
	// Asset for the current margins
	Asset *vega.Asset `json:"asset"`
	// Minimal margin for the position to be maintained in the network (unsigned integer)
	MaintenanceLevel string `json:"maintenanceLevel"`
	// If the margin is between maintenance and search, the network will initiate a collateral search, expressed as unsigned integer
	SearchLevel string `json:"searchLevel"`
	// This is the minimum margin required for a party to place a new order on the network, expressed as unsigned integer
	InitialLevel string `json:"initialLevel"`
	// When in isolated margin, the required order margin level, otherwise, 0
	OrderMarginLevel string `json:"orderMarginLevel"`
	// If the margin of the party is greater than this level, then collateral will be released from the margin account into
	// the general account of the party for the given asset.
	CollateralReleaseLevel string `json:"collateralReleaseLevel"`
	// Margin mode of the party, cross margin or isolated margin
	MarginMode vega.MarginMode `json:"marginMode"`
	// Margin factor, only relevant for isolated margin mode, else 0
	MarginFactor string `json:"marginFactor"`
}

// An auction duration is used to configure 3 auction periods:
// 1. `duration > 0`, `volume == 0`:
// The auction will last for at least N seconds.
// 2. `duration == 0`, `volume > 0`:
// The auction will end once the given volume will match at uncrossing.
// 3. `duration > 0`, `volume > 0`:
// The auction will take at least N seconds, but can end sooner if the market can trade a certain volume.
type AuctionDuration struct {
	// Duration of the auction in seconds
	DurationSecs int `json:"durationSecs"`
	// Target uncrossing trading volume
	Volume int `json:"volume"`
}

type BatchProposal struct {
	// Proposal ID that is provided by Vega once proposal reaches the network
	ID *string `json:"id,omitempty"`
	// A UUID reference to aid tracking proposals on Vega
	Reference string `json:"reference"`
	// Party that prepared the proposal
	Party *vega.Party `json:"party"`
	// State of the proposal
	State vega.Proposal_State `json:"state"`
	// RFC3339Nano time and date when the proposal reached the network
	Datetime int64 `json:"datetime"`
	// Terms of all the proposals in the batch
	BatchTerms *vega.BatchProposalTerms `json:"batchTerms,omitempty"`
	// Rationale behind the proposal
	Rationale *vega.ProposalRationale `json:"rationale"`
	// Votes cast for this proposal
	Votes *ProposalVotes `json:"votes"`
	// Reason the proposal was rejected
	RejectionReason *vega.ProposalError `json:"rejectionReason,omitempty"`
	// Details of the rejection reason
	ErrorDetails *string `json:"errorDetails,omitempty"`
	// Required majority for this proposal to succeed
	RequiredMajority string `json:"requiredMajority"`
	// Required participation for this proposal to succeed
	RequiredParticipation string `json:"requiredParticipation"`
	// Equity-like share required for a market amendment proposal to be enacted, represented as a fraction that can be converted to a percentage. If not met, the proposal will not be enacted
	RequiredLpMajority *string `json:"requiredLpMajority,omitempty"`
	// The market share of LPs' equity-like share that must take part in a market amendment vote for the proposal to pass. This means the votes of LPs that have submitted more liquidity to that market, or have been LPs from the start carry more weight. If it requires 50% of a market's equity-like share for a majority, and the full batch of proposals receives all YES votes but only LPs with 49% of the equity-like share voted, the proposal will not pass
	RequiredLpParticipation *string `json:"requiredLpParticipation,omitempty"`
	// Proposals that are part of the batch
	SubProposals []*vega.Proposal `json:"subProposals,omitempty"`
}

func (BatchProposal) IsProposalNode() {}

// A Vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

type BusEvent struct {
	// The ID for this event
	ID string `json:"id"`
	// The block hash
	Block string `json:"block"`
	// The type of event
	Type BusEventType `json:"type"`
	// The payload - the wrapped event
	Event Event `json:"event"`
}

// Condition describes the condition that must be validated by the data source engine
type Condition struct {
	// The type of comparison to make on the value.
	Operator v1.Condition_Operator `json:"operator"`
	// The value to compare against.
	Value *string `json:"value,omitempty"`
}

// A mode where Vega tries to execute orders as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// A data source contains the data sent by a data source
type Data struct {
	// signers is the list of public keys/ETH addresses that signed the data
	Signers []*Signer `json:"signers,omitempty"`
	// properties contains all the properties sent by a data source
	Data     []*v1.Property `json:"data,omitempty"`
	MetaData []*v1.Property `json:"metaData,omitempty"`
	// List of all the data specs that matched this source data.
	// When the array is empty, it means no data spec matched this source data.
	MatchedSpecIds []string `json:"matchedSpecIds,omitempty"`
	// RFC3339Nano formatted date and time for when the data was broadcast to the markets
	// with a matching data spec.
	// It has no value when the source data does not match any data spec.
	BroadcastAt int64 `json:"broadcastAt"`
}

// An data source specification describes the data source data that a product (or a risk model)
// wants to get from the oracle engine.
type DataSourceSpec struct {
	// ID is a hash generated from the DataSourceSpec data.
	ID string `json:"id"`
	// RFC3339Nano creation date time
	CreatedAt int64 `json:"createdAt"`
	// RFC3339Nano last updated timestamp
	UpdatedAt *int64                     `json:"updatedAt,omitempty"`
	Data      *vega.DataSourceDefinition `json:"data"`
	// Status describes the status of the data source spec
	Status DataSourceSpecStatus `json:"status"`
}

type DiscountFactors struct {
	// The proportion of the referee's taker infrastructure fees to be discounted
	InfrastructureFactor string `json:"infrastructureFactor"`
	// The proportion of the referee's taker maker fees to be discounted
	MakerFactor string `json:"makerFactor"`
	// The proportion of the referee's taker liquidity fees to be discounted
	LiquidityFactor string `json:"liquidityFactor"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the ERC20 contract
	ContractAddress string `json:"contractAddress"`
	// The lifetime limits deposit per address
	// Note: this is a temporary measure that can be changed by governance
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
	// There is no limit on the size of a withdrawal
	// Note: this is a temporary measure that can be changed by governance
	WithdrawThreshold string `json:"withdrawThreshold"`
	// The chain ID the asset originates from.
	ChainID string `json:"chainId"`
}

func (Erc20) IsAssetSource() {}

type ERC20MultiSigSignerAddedBundleEdge struct {
	Node   *v2.ERC20MultiSigSignerAddedBundle `json:"node"`
	Cursor string                             `json:"cursor"`
}

// Response for the signature bundle to add a particular validator to the signer list of the multisig contract
type ERC20MultiSigSignerAddedConnection struct {
	Edges    []*ERC20MultiSigSignerAddedBundleEdge `json:"edges,omitempty"`
	PageInfo *v2.PageInfo                          `json:"pageInfo,omitempty"`
}

type ERC20MultiSigSignerRemovedBundleEdge struct {
	Node   *v2.ERC20MultiSigSignerRemovedBundle `json:"node"`
	Cursor string                               `json:"cursor"`
}

// Response for the signature bundle to remove a particular validator from the signer list of the multisig contract
type ERC20MultiSigSignerRemovedConnection struct {
	// The list of signer bundles for that validator
	Edges []*ERC20MultiSigSignerRemovedBundleEdge `json:"edges,omitempty"`
	// The pagination information
	PageInfo *v2.PageInfo `json:"pageInfo,omitempty"`
}

// Response for the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge
type ERC20SetAssetLimitsBundle struct {
	// The address of the asset on ethereum
	AssetSource string `json:"assetSource"`
	// The ID of the vega asset
	VegaAssetID string `json:"vegaAssetId"`
	// The nonce, which is actually the internal reference for the proposal
	Nonce string `json:"nonce"`
	// The lifetime limit deposit for this asset
	LifetimeLimit string `json:"lifetimeLimit"`
	// The threshold withdraw for this asset
	Threshold string `json:"threshold"`
	// The signatures bundle as hex encoded data, forward by 0x
	// e.g: 0x + sig1 + sig2 + ... + sixN
	Signatures string `json:"signatures"`
}

type ETHAddress struct {
	Address *string `json:"address,omitempty"`
}

func (ETHAddress) IsSignerKind() {}

// Summary of a node's rewards for a given epoch
type EpochParticipation struct {
	Epoch *vega.Epoch `json:"epoch,omitempty"`
	// RFC3339 timestamp
	Offline *int64 `json:"offline,omitempty"`
	// RFC3339 timestamp
	Online *int64 `json:"online,omitempty"`
	// Total amount rewarded for participation in the given epoch
	TotalRewards *float64 `json:"totalRewards,omitempty"`
}

// Response for the signature bundle to allowlist an ERC20 token in the collateral bridge
type Erc20ListAssetBundle struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The ID of the vega asset
	VegaAssetID string `json:"vegaAssetId"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset on the bridged EVM chain
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawn
	Amount string `json:"amount"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
	// The target address that will receive the funds
	TargetAddress string `json:"targetAddress"`
	// RFC3339Nano timestamp at which the withdrawal was created
	Creation string `json:"creation"`
	// The chain ID of the bridged EVM chain
	SourceChainID string `json:"sourceChainId"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// EthCallTrigger is the type of trigger used to make calls to Ethereum network.
type EthCallTrigger struct {
	Trigger TriggerKind `json:"trigger"`
}

// Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
// one-off or repeating.
type EthTimeTrigger struct {
	// Trigger when the Ethereum time is greater or equal to this time, in Unix seconds.
	Initial *int64 `json:"initial,omitempty"`
	// Repeat the call every n seconds after the initial call. If no time for
	// initial call was specified, begin repeating immediately.
	Every *int `json:"every,omitempty"`
	// If repeating, stop once Ethereum time is greater than this time, in Unix
	// seconds. If not set, then repeat indefinitely.
	Until *int64 `json:"until,omitempty"`
}

func (EthTimeTrigger) IsTriggerKind() {}

// An Ethereum data source
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

type ExternalData struct {
	Data *Data `json:"data"`
}

// externalDataSourceSpec is the type that wraps the DataSourceSpec type in order to be further used/extended
// by the OracleSpec
type ExternalDataSourceSpec struct {
	Spec *DataSourceSpec `json:"spec"`
}

// An estimate of the fee to be paid for the order
type FeeEstimate struct {
	// The estimated fees if the order was to trade
	Fees *TradeFee `json:"fees"`
	// The total estimated amount of fees if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
}

// Filter describes the conditions under which oracle data is considered of
// interest or not.
type Filter struct {
	// key is the data source data property key targeted by the filter.
	Key *PropertyKey `json:"key"`
	// The conditions that should be matched by the data to be
	// considered of interest.
	Conditions []*Condition `json:"conditions,omitempty"`
}

type GamePartyScoreFilter struct {
	// Zero or more game IDs to filter by
	GameIds []string `json:"gameIds,omitempty"`
	// Zero or more team IDs to filter by
	TeamIds []string `json:"teamIds,omitempty"`
	// Zero or more party IDs to filter by
	PartyIds []string `json:"partyIds,omitempty"`
	// Optional 'from epoch' ID for scores epoch interval
	EpochFrom *int `json:"epochFrom,omitempty"`
	// Optional 'to epoch' ID for scores epoch interval
	EpochTo *int `json:"epochTo,omitempty"`
}

type GameTeamScoreFilter struct {
	// Zero or more game IDs to filter by
	GameIds []string `json:"gameIds,omitempty"`
	// Zero or more team IDs to filter by
	TeamIds []string `json:"teamIds,omitempty"`
	// Optional 'from epoch' ID for scores epoch interval
	EpochFrom *int `json:"epochFrom,omitempty"`
	// Optional 'to epoch' ID for scores epoch interval
	EpochTo *int `json:"epochTo,omitempty"`
}

// Individual party participating in a game and their metrics
type IndividualGameEntity struct {
	// Party ID of the participant
	Individual string `json:"individual"`
	// The rank of the individual within the game. If the individual is in a team, then the rank of the individual in the team
	Rank int `json:"rank"`
	// The volume traded by the individual
	Volume string `json:"volume"`
	// The reward metric applied to the game
	RewardMetric vega.DispatchMetric `json:"rewardMetric"`
	// The rewards earned by the individual during the epoch
	RewardEarned string `json:"rewardEarned"`
	// Total rewards earned by the individual during the game
	TotalRewardsEarned string `json:"totalRewardsEarned"`
	// The rewards earned by the individual during the epoch in quantum value
	RewardEarnedQuantum string `json:"rewardEarnedQuantum"`
	// Total rewards earned by the individual during the game in quantum value
	TotalRewardsEarnedQuantum string `json:"totalRewardsEarnedQuantum"`
}

func (IndividualGameEntity) IsGameEntity() {}

// Configuration of a market liquidity monitoring parameters
type LiquidityMonitoringParameters struct {
	// Specifies parameters related to target stake calculation
	TargetStakeParameters *TargetStakeParameters `json:"targetStakeParameters"`
}

// The equity-like share of liquidity fee for each liquidity provider
type LiquidityProviderFeeShare struct {
	// The liquidity provider party ID
	Party *vega.Party `json:"party"`
	// The share owned by this liquidity provider
	EquityLikeShare string `json:"equityLikeShare"`
	// The average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
	// The average liquidity score
	AverageScore string `json:"averageScore"`
	// The virtual stake for this liquidity provider
	VirtualStake string `json:"virtualStake"`
}

// The SLA statistics for each liquidity provider
type LiquidityProviderSLA struct {
	// The liquidity provider party ID
	Party *vega.Party `json:"party"`
	// Indicates how often LP meets the commitment during the current epoch.
	CurrentEpochFractionOfTimeOnBook string `json:"currentEpochFractionOfTimeOnBook"`
	// Indicates how often LP met the commitment in the previous epoch.
	LastEpochFractionOfTimeOnBook string `json:"lastEpochFractionOfTimeOnBook"`
	// Indicates the fee penalty amount applied in the previous epoch.
	LastEpochFeePenalty string `json:"lastEpochFeePenalty"`
	// Indicates the bond penalty amount applied in the previous epoch.
	LastEpochBondPenalty string `json:"lastEpochBondPenalty"`
	// Determines how the fee penalties from past epochs affect future fee revenue.
	HysteresisPeriodFeePenalties []string `json:"hysteresisPeriodFeePenalties,omitempty"`
	// Represents the total amount of funds LP must supply. The amount to be supplied is in the market’s settlement currency, spread on both buy and sell sides of the order book within a defined range.
	RequiredLiquidity string `json:"requiredLiquidity"`
	// Notional volume of orders within the range provided on the buy side of the book.
	NotionalVolumeBuys string `json:"notionalVolumeBuys"`
	// Notional volume of orders within the range provided on the sell side of the book.
	NotionalVolumeSells string `json:"notionalVolumeSells"`
}

type LossSocialization struct {
	// The market ID where loss socialization happened
	MarketID string `json:"marketId"`
	// The party that was part of the loss socialization
	PartyID string `json:"partyId"`
	// The amount lost
	Amount string `json:"amount"`
}

// The liquidity commitments for this market
type MarketDataCommitments struct {
	// A set of liquidity sell orders to meet the liquidity provision obligation.
	Sells []*vega.LiquidityOrderReference `json:"sells,omitempty"`
	// A set of liquidity buy orders to meet the liquidity provision obligation.
	Buys []*vega.LiquidityOrderReference `json:"buys,omitempty"`
}

type MarketDepthTrade struct {
	// ID of the trade for the given market (if available)
	ID string `json:"id"`
	// Price of the trade
	Price string `json:"price"`
	// Size of the trade
	Size string `json:"size"`
}

type MarketEvent struct {
	// The market ID
	MarketID string `json:"marketId"`
	// The message - market events are used for logging
	Payload string `json:"payload"`
}

type MarketTick struct {
	// The market ID
	MarketID string `json:"marketId"`
	// The block time
	Time string `json:"time"`
}

// Details on the collection of nodes for particular validator status
type NodeSet struct {
	// Total number of nodes in the node set
	Total int `json:"total"`
	// Number of nodes in the node set that had a performance score of 0 at the end of the last epoch
	Inactive int `json:"inactive"`
	// IDs of the nodes that were promoted into this node set at the start of the epoch
	Promoted []string `json:"promoted,omitempty"`
	// IDs of the nodes that were demoted into this node set at the start of the epoch
	Demoted []string `json:"demoted,omitempty"`
	// Total number of nodes allowed in the node set
	Maximum *int `json:"maximum,omitempty"`
}

// Normaliser to convert the data returned from the contract method
// into a standard format.
type Normaliser struct {
	Name       string `json:"name"`
	Expression string `json:"expression"`
}

// The equity-like share of liquidity fee for each liquidity provider
type ObservableLiquidityProviderFeeShare struct {
	// The liquidity provider party ID
	PartyID string `json:"partyId"`
	// The share owned by this liquidity provider (float)
	EquityLikeShare string `json:"equityLikeShare"`
	// The average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
	// The average liquidity score
	AverageScore string `json:"averageScore"`
}

// The SLA statistics for each liquidity provider
type ObservableLiquidityProviderSLA struct {
	// The liquidity provider party ID
	Party string `json:"party"`
	// Indicates how often LP meets the commitment during the current epoch.
	CurrentEpochFractionOfTimeOnBook string `json:"currentEpochFractionOfTimeOnBook"`
	// Indicates how often LP meets the commitment during last epoch.
	LastEpochFractionOfTimeOnBook string `json:"lastEpochFractionOfTimeOnBook"`
	// Indicates the fee penalty amount applied in the previous epoch.
	LastEpochFeePenalty string `json:"lastEpochFeePenalty"`
	// Indicates the bond penalty amount applied in the previous epoch.
	LastEpochBondPenalty string `json:"lastEpochBondPenalty"`
	// Determines how the fee penalties from past epochs affect future fee revenue.
	HysteresisPeriodFeePenalties []string `json:"hysteresisPeriodFeePenalties,omitempty"`
	// Represents the total amount of funds LP must supply. The amount to be supplied is in the market’s settlement currency, spread on both buy and sell sides of the order book within a defined range.
	RequiredLiquidity string `json:"requiredLiquidity"`
	// Notional volume of orders within the range provided on the buy side of the book.
	NotionalVolumeBuys string `json:"notionalVolumeBuys"`
	// Notional volume of orders within the range provided on the sell side of the book.
	NotionalVolumeSells string `json:"notionalVolumeSells"`
}

type OrderByMarketAndPartyIdsFilter struct {
	Order     *v2.OrderFilter `json:"order,omitempty"`
	MarketIds []string        `json:"marketIds,omitempty"`
	PartyIds  []string        `json:"partyIds,omitempty"`
}

type OrderByMarketIdsFilter struct {
	Order     *v2.OrderFilter `json:"order,omitempty"`
	MarketIds []string        `json:"marketIds,omitempty"`
}

type OrderByPartyIdsFilter struct {
	Order    *v2.OrderFilter `json:"order,omitempty"`
	PartyIds []string        `json:"partyIds,omitempty"`
}

// An estimate of the fee to be paid by the order
type OrderEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
	// The margin requirement for this order
	MarginLevels *vega.MarginLevels `json:"marginLevels"`
}

// Response for the estimate of the margin level and, if available, collateral was provided in the request, liquidation price for the specified position
type PositionEstimate struct {
	// Margin level range estimate for the specified position
	Margin *v2.MarginEstimate `json:"margin"`
	// Estimated margin account balance increase
	CollateralIncreaseEstimate *v2.CollateralIncreaseEstimate `json:"collateralIncreaseEstimate"`
	// Liquidation price range estimate for the specified position. Only populated if available collateral was specified in the request
	Liquidation *v2.LiquidationEstimate `json:"liquidation,omitempty"`
}

type PositionResolution struct {
	// The market ID where position resolution happened
	MarketID string `json:"marketId"`
	// Number of distressed parties on market
	Distressed int `json:"distressed"`
	// Number of parties closed out
	Closed int `json:"closed"`
	// The mark price at which parties were distressed/closed out
	MarkPrice string `json:"markPrice"`
}

// Range of valid prices and the associated price monitoring trigger
type PriceMonitoringBounds struct {
	// Minimum price that isn't currently breaching the specified price monitoring trigger
	MinValidPrice string `json:"minValidPrice"`
	// Maximum price that isn't currently breaching the specified price monitoring trigger
	MaxValidPrice string `json:"maxValidPrice"`
	// Price monitoring trigger associated with the bounds
	Trigger *PriceMonitoringTrigger `json:"trigger"`
	// Reference price used to calculate the valid price range
	ReferencePrice string `json:"referencePrice"`
	// Has this bound been triggered yet or is it still active
	Active *bool `json:"active,omitempty"`
}

// PriceMonitoringParameters holds a list of triggers
type PriceMonitoringParameters struct {
	// The list of triggers for this price monitoring
	Triggers []*PriceMonitoringTrigger `json:"triggers,omitempty"`
}

// Configuration of a market price monitoring auctions triggers
type PriceMonitoringSettings struct {
	// Specified a set of PriceMonitoringParameters to be use for price monitoring purposes
	Parameters *PriceMonitoringParameters `json:"parameters,omitempty"`
}

// PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration
type PriceMonitoringTrigger struct {
	// Price monitoring projection horizon τ in seconds (> 0).
	HorizonSecs int `json:"horizonSecs"`
	// Price monitoring probability level p. (>0 and < 1)
	Probability float64 `json:"probability"`
	// Price monitoring auction extension duration in seconds should the price
	// breach its theoretical level over the specified horizon at the specified
	// probability level (> 0)
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

// PropertyKey describes the property key contained in a source data.
type PropertyKey struct {
	// The name of the property.
	Name *string `json:"name,omitempty"`
	// The type of the property.
	Type v1.PropertyKey_Type `json:"type"`
	// An optional decimal place to be applied on the provided value.
	// Valid only for PropertyType of type DECIMAL, INTEGER.
	NumberDecimalPlaces *int `json:"numberDecimalPlaces,omitempty"`
}

type ProposalVote struct {
	// Cast vote
	Vote *vega.Vote `json:"vote"`
	// Proposal ID the vote is cast on
	ProposalID string `json:"proposalId"`
}

// Connection type for retrieving cursor-based paginated proposal vote information
type ProposalVoteConnection struct {
	// The proposal votes in this connection
	Edges []*ProposalVoteEdge `json:"edges,omitempty"`
	// The pagination information
	PageInfo *v2.PageInfo `json:"pageInfo,omitempty"`
}

// Edge type containing the proposal vote and cursor information returned by a ProposalVoteConnection
type ProposalVoteEdge struct {
	// The proposal vote
	Node *ProposalVote `json:"node"`
	// The cursor for this proposal vote
	Cursor *string `json:"cursor,omitempty"`
}

type ProposalVoteSide struct {
	// All votes cast for this side
	Votes []*vega.Vote `json:"votes,omitempty"`
	// Total number of votes cast for this side
	TotalNumber string `json:"totalNumber"`
	// Total weight of governance token from the votes cast for this side
	TotalWeight string `json:"totalWeight"`
	// Total number of governance tokens from the votes cast for this side
	TotalTokens string `json:"totalTokens"`
	// Total equity-like share weight for this side (only for UpdateMarket Proposals)
	TotalEquityLikeShareWeight string `json:"totalEquityLikeShareWeight"`
}

type ProposalVotes struct {
	// Yes votes cast for this proposal
	Yes *ProposalVoteSide `json:"yes"`
	// No votes cast for this proposal
	No *ProposalVoteSide `json:"no"`
}

// Indicator showing whether the data-node is ready for the protocol upgrade to begin.
type ProtocolUpgradeStatus struct {
	Ready bool `json:"ready"`
}

type PubKey struct {
	Key *string `json:"key,omitempty"`
}

func (PubKey) IsSignerKind() {}

// Queries allow a caller to read data and filter data via GraphQL.
type Query struct {
}

type RewardFactors struct {
	// The proportion of the referee's taker infrastructure fees to be rewarded to the referrer
	InfrastructureFactor string `json:"infrastructureFactor"`
	// The proportion of the referee's taker maker fees to be rewarded to the referrer
	MakerFactor string `json:"makerFactor"`
	// The proportion of the referee's taker liquidity fees to be rewarded to the referrer
	LiquidityFactor string `json:"liquidityFactor"`
}

// Connection type for retrieving cursor-based paginated reward summary information
type RewardSummaryConnection struct {
	// List of reward summaries available for the connection
	Edges []*RewardSummaryEdge `json:"edges,omitempty"`
	// Page information for the connection
	PageInfo *v2.PageInfo `json:"pageInfo"`
}

// Edge type containing the reward summary and cursor information returned by a RewardSummaryConnection
type RewardSummaryEdge struct {
	// The reward summary
	Node *vega.RewardSummary `json:"node"`
	// Cursor identifying the reward summary
	Cursor string `json:"cursor"`
}

type SettleDistressed struct {
	// The market in which a position was closed out
	MarketID string `json:"marketId"`
	// The party that was closed out
	PartyID string `json:"partyId"`
	// The margin taken from distressed party
	Margin string `json:"margin"`
	// The price at which the position was closed out
	Price string `json:"price"`
}

type SettlePosition struct {
	// The market in which a position was settled
	MarketID string `json:"marketId"`
	// The party who settled a position
	PartyID string `json:"partyId"`
	// The settle price
	Price string `json:"price"`
	// The trades that were settled to close the overall position
	TradeSettlements []*TradeSettlement `json:"tradeSettlements,omitempty"`
}

// Signer is the authorized signature used for the data.
type Signer struct {
	Signer SignerKind `json:"signer"`
}

// Describes which property of the data source data should be
// used as composite price source.
type SpecBindingForCompositePrice struct {
	PriceSourceProperty string `json:"priceSourceProperty"`
}

// All staking information related to a Party.
// Contains the current recognised balance by the network and
// all the StakeLink/Unlink seen by the network
type StakingSummary struct {
	// The stake currently available for the party
	CurrentStakeAvailable string `json:"currentStakeAvailable"`
	// The list of all stake link/unlink for the party
	Linkings *v2.StakesConnection `json:"linkings"`
}

// Price at which a stop order will trigger
type StopOrderPrice struct {
	Price string `json:"price"`
}

func (StopOrderPrice) IsStopOrderTrigger() {}

// Percentage movement in the price at which a stop order will trigger.
type StopOrderTrailingPercentOffset struct {
	TrailingPercentOffset string `json:"trailingPercentOffset"`
}

func (StopOrderTrailingPercentOffset) IsStopOrderTrigger() {}

// Subscriptions allow a caller to receive new information as it is available from the Vega network.
type Subscription struct {
}

// TargetStakeParameters contains parameters used in target stake calculation
type TargetStakeParameters struct {
	// Specifies length of time window expressed in seconds for target stake calculation
	TimeWindow int `json:"timeWindow"`
	// Specifies scaling factors used in target stake calculation
	ScalingFactor float64 `json:"scalingFactor"`
}

// Team participating in a game and their metrics.
type TeamGameEntity struct {
	// Breakdown of the team members and their contributions to the total team metrics.
	Team *TeamParticipation `json:"team"`
	// Rank of the team within the game.
	Rank int `json:"rank"`
	// Total volume traded by the team
	Volume string `json:"volume"`
	// Reward metric applied to the game.
	RewardMetric vega.DispatchMetric `json:"rewardMetric"`
	// Total rewards earned by the team during the epoch
	RewardEarned string `json:"rewardEarned"`
	// Total rewards earned by the team for the game
	TotalRewardsEarned string `json:"totalRewardsEarned"`
	// Total rewards earned by the team during the epoch in quantum value
	RewardEarnedQuantum string `json:"rewardEarnedQuantum"`
	// Total rewards earned by the team for the game in quantum value
	TotalRewardsEarnedQuantum string `json:"totalRewardsEarnedQuantum"`
}

func (TeamGameEntity) IsGameEntity() {}

// Team participation information, i.e. the team ID and the metrics for each participating team member.
type TeamParticipation struct {
	// Team ID
	TeamID string `json:"teamId"`
	// List of participating team members and their metrics.
	MembersParticipating []*IndividualGameEntity `json:"membersParticipating"`
}

type TimeUpdate struct {
	// RFC3339Nano time of new block time
	Timestamp int64 `json:"timestamp"`
}

func (TimeUpdate) IsEvent() {}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, paid by the aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the validators to maintain the Vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the liquidity providers that committed liquidity to the market
	LiquidityFee string `json:"liquidityFee"`
	// The fee paid into the protocol buy-back account
	BuyBackFee string `json:"buyBackFee"`
	// The fee paid into the network treasury
	TreasuryFee string `json:"treasuryFee"`
	// The fee paid to a high-volume maker as a rebate
	HighVolumeMakerFee string `json:"highVolumeMakerFee"`
	// Referral discount on maker fees for the trade
	MakerFeeReferralDiscount *string `json:"makerFeeReferralDiscount,omitempty"`
	// Volume discount on maker fees for the trade
	MakerFeeVolumeDiscount *string `json:"makerFeeVolumeDiscount,omitempty"`
	// Referral discount on infrastructure fees for the trade
	InfrastructureFeeReferralDiscount *string `json:"infrastructureFeeReferralDiscount,omitempty"`
	// Volume discount on infrastructure fees for the trade
	InfrastructureFeeVolumeDiscount *string `json:"infrastructureFeeVolumeDiscount,omitempty"`
	// Referral discount on liquidity fees for the trade
	LiquidityFeeReferralDiscount *string `json:"liquidityFeeReferralDiscount,omitempty"`
	// Volume discount on liquidity fees for the trade
	LiquidityFeeVolumeDiscount *string `json:"liquidityFeeVolumeDiscount,omitempty"`
}

type TradeSettlement struct {
	// The size of the trade
	Size int `json:"size"`
	// The price of the trade
	Price string `json:"price"`
}

// Filter to apply to the trade connection query
type TradesFilter struct {
	PartyIds  []string `json:"partyIds,omitempty"`
	MarketIds []string `json:"marketIds,omitempty"`
	OrderIds  []string `json:"orderIds,omitempty"`
}

// Filter to apply to the trade subscription request
type TradesSubscriptionFilter struct {
	PartyIds  []string `json:"partyIds,omitempty"`
	MarketIds []string `json:"marketIds,omitempty"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

type TransferBalance struct {
	// Account involved in transfer
	Account *vega.AccountDetails `json:"account"`
	// The new balance of the account
	Balance string `json:"balance"`
}

// A transfer fee record
type TransferFee struct {
	// Transfer ID of the transfer for which the fee was paid
	TransferID string `json:"transferId"`
	// The fee amount
	Amount string `json:"amount"`
	// The epoch when this fee was paid
	Epoch int `json:"epoch"`
}

type TransferResponse struct {
	// The ledger entries and balances resulting from a transfer request
	Transfers []*vega.LedgerEntry `json:"transfers,omitempty"`
	// The balances of accounts involved in the transfer
	Balances []*TransferBalance `json:"balances,omitempty"`
}

type TransferResponses struct {
	// A group of transfer responses - events from core
	Responses []*TransferResponse `json:"responses,omitempty"`
}

// An asset originated from an Ethereum ERC20 Token
type UpdateErc20 struct {
	// The lifetime limits deposit per address
	// Note: this is a temporary measure that can be changed by governance
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
	// There is no limit on the size of a withdrawal
	// Note: this is a temporary measure that can be changed by governance
	WithdrawThreshold string `json:"withdrawThreshold"`
}

func (UpdateErc20) IsUpdateAssetSource() {}

type UpdateInstrumentConfiguration struct {
	Code    string                     `json:"code"`
	Name    string                     `json:"name"`
	Product UpdateProductConfiguration `json:"product"`
}

type UpdateSpotInstrumentConfiguration struct {
	// Instrument code, human-readable shortcode used to describe the instrument.
	Code string `json:"code"`
	// Instrument name
	Name string `json:"name"`
}

type UpdateVolumeRebateProgram struct {
	// The benefit tiers for the program
	BenefitTiers []*VolumeRebateBenefitTier `json:"benefitTiers"`
	// Timestamp as Unix time in nanoseconds, after which program ends.
	EndOfProgramTimestamp int64 `json:"endOfProgramTimestamp"`
	// The window length to consider for the volume discount program
	WindowLength int `json:"windowLength"`
}

func (UpdateVolumeRebateProgram) IsProposalChange() {}

type VolumeRebateBenefitTier struct {
	// The required volume fraction for a party to access this tier
	MinimumPartyMakerVolumeFraction string `json:"minimumPartyMakerVolumeFraction"`
	// The additional rebate factor (in percentage of trade_value_for_fee_purposes a party at this tier will receive when they are the maker side of a trade
	AdditionalMakerRebate string `json:"additionalMakerRebate"`
	// The tier number
	TierNumber *int `json:"tierNumber,omitempty"`
}

// Event types
type BusEventType string

const (
	// Vega Time has changed
	BusEventTypeTimeUpdate BusEventType = "TimeUpdate"
	// Collateral has deposited in to this Vega network via the bridge
	BusEventTypeDeposit BusEventType = "Deposit"
	// Collateral has been withdrawn from this Vega network via the bridge
	BusEventTypeWithdrawal BusEventType = "Withdrawal"
	// The results from processing at transaction
	BusEventTypeTransactionResult BusEventType = "TransactionResult"
)

var AllBusEventType = []BusEventType{
	BusEventTypeTimeUpdate,
	BusEventTypeDeposit,
	BusEventTypeWithdrawal,
	BusEventTypeTransactionResult,
}

func (e BusEventType) IsValid() bool {
	switch e {
	case BusEventTypeTimeUpdate, BusEventTypeDeposit, BusEventTypeWithdrawal, BusEventTypeTransactionResult:
		return true
	}
	return false
}

func (e BusEventType) String() string {
	return string(e)
}

func (e *BusEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusEventType", str)
	}
	return nil
}

func (e BusEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CompositePriceType string

const (
	// Composite price is calculated as a weighted average of the underlying price sources
	CompositePriceTypeCompositePriceTypeWeighted CompositePriceType = "COMPOSITE_PRICE_TYPE_WEIGHTED"
	// Composite price is calculated as a median of the underlying price sources
	CompositePriceTypeCompositePriceTypeMedian CompositePriceType = "COMPOSITE_PRICE_TYPE_MEDIAN"
	// Composite price is set to the last trade (legacy)
	CompositePriceTypeCompositePriceTypeLastTrade CompositePriceType = "COMPOSITE_PRICE_TYPE_LAST_TRADE"
)

var AllCompositePriceType = []CompositePriceType{
	CompositePriceTypeCompositePriceTypeWeighted,
	CompositePriceTypeCompositePriceTypeMedian,
	CompositePriceTypeCompositePriceTypeLastTrade,
}

func (e CompositePriceType) IsValid() bool {
	switch e {
	case CompositePriceTypeCompositePriceTypeWeighted, CompositePriceTypeCompositePriceTypeMedian, CompositePriceTypeCompositePriceTypeLastTrade:
		return true
	}
	return false
}

func (e CompositePriceType) String() string {
	return string(e)
}

func (e *CompositePriceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompositePriceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompositePriceType", str)
	}
	return nil
}

func (e CompositePriceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the status of the data spec
type DataSourceSpecStatus string

const (
	// Describes an active data spec
	DataSourceSpecStatusStatusActive DataSourceSpecStatus = "STATUS_ACTIVE"
	// Describes a data spec that is not listening to data
	// anymore
	DataSourceSpecStatusStatusDeactivated DataSourceSpecStatus = "STATUS_DEACTIVATED"
)

var AllDataSourceSpecStatus = []DataSourceSpecStatus{
	DataSourceSpecStatusStatusActive,
	DataSourceSpecStatusStatusDeactivated,
}

func (e DataSourceSpecStatus) IsValid() bool {
	switch e {
	case DataSourceSpecStatusStatusActive, DataSourceSpecStatusStatusDeactivated:
		return true
	}
	return false
}

func (e DataSourceSpecStatus) String() string {
	return string(e)
}

func (e *DataSourceSpecStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataSourceSpecStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DataSourceSpecStatus", str)
	}
	return nil
}

func (e DataSourceSpecStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GovernanceTransferType string

const (
	// Default value, always invalid
	GovernanceTransferTypeGovernanceTransferTypeUnspecified GovernanceTransferType = "GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED"
	// Transfers the specified amount or does not transfer anything
	GovernanceTransferTypeGovernanceTransferTypeAllOrNothing GovernanceTransferType = "GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING"
	// Transfers the specified amount or the max allowable amount if this is less than the specified amount
	GovernanceTransferTypeGovernanceTransferTypeBestEffort GovernanceTransferType = "GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT"
)

var AllGovernanceTransferType = []GovernanceTransferType{
	GovernanceTransferTypeGovernanceTransferTypeUnspecified,
	GovernanceTransferTypeGovernanceTransferTypeAllOrNothing,
	GovernanceTransferTypeGovernanceTransferTypeBestEffort,
}

func (e GovernanceTransferType) IsValid() bool {
	switch e {
	case GovernanceTransferTypeGovernanceTransferTypeUnspecified, GovernanceTransferTypeGovernanceTransferTypeAllOrNothing, GovernanceTransferTypeGovernanceTransferTypeBestEffort:
		return true
	}
	return false
}

func (e GovernanceTransferType) String() string {
	return string(e)
}

func (e *GovernanceTransferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GovernanceTransferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GovernanceTransferType", str)
	}
	return nil
}

func (e GovernanceTransferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MarketUpdateType string

const (
	// Default value, always invalid
	MarketUpdateTypeMarketStateUpdateTypeUnspecified MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_UNSPECIFIED"
	// Terminate the market
	MarketUpdateTypeMarketStateUpdateTypeTerminate MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_TERMINATE"
	// Suspend the market
	MarketUpdateTypeMarketStateUpdateTypeSuspend MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_SUSPEND"
	// Resume a suspended market
	MarketUpdateTypeMarketStateUpdateTypeResume MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_RESUME"
)

var AllMarketUpdateType = []MarketUpdateType{
	MarketUpdateTypeMarketStateUpdateTypeUnspecified,
	MarketUpdateTypeMarketStateUpdateTypeTerminate,
	MarketUpdateTypeMarketStateUpdateTypeSuspend,
	MarketUpdateTypeMarketStateUpdateTypeResume,
}

func (e MarketUpdateType) IsValid() bool {
	switch e {
	case MarketUpdateTypeMarketStateUpdateTypeUnspecified, MarketUpdateTypeMarketStateUpdateTypeTerminate, MarketUpdateTypeMarketStateUpdateTypeSuspend, MarketUpdateTypeMarketStateUpdateTypeResume:
		return true
	}
	return false
}

func (e MarketUpdateType) String() string {
	return string(e)
}

func (e *MarketUpdateType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketUpdateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketUpdateType", str)
	}
	return nil
}

func (e MarketUpdateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Filter type for specifying the types of transfers to filter for
type TransferDirection string

const (
	TransferDirectionTo       TransferDirection = "To"
	TransferDirectionFrom     TransferDirection = "From"
	TransferDirectionToOrFrom TransferDirection = "ToOrFrom"
)

var AllTransferDirection = []TransferDirection{
	TransferDirectionTo,
	TransferDirectionFrom,
	TransferDirectionToOrFrom,
}

func (e TransferDirection) IsValid() bool {
	switch e {
	case TransferDirectionTo, TransferDirectionFrom, TransferDirectionToOrFrom:
		return true
	}
	return false
}

func (e TransferDirection) String() string {
	return string(e)
}

func (e *TransferDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransferDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransferDirection", str)
	}
	return nil
}

func (e TransferDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
