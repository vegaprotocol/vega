syntax = "proto3";

package vega;
option go_package = "code.vegaprotocol.io/vega/proto";

import "github.com/mwitkow/go-proto-validators/validator.proto";

enum Side { Buy = 0; Sell = 1; }

enum Interval { I1M = 0; I5M = 1; I15M = 2; I1H = 3; I6H = 4; I1D = 5; }

message Amount {
  string value = 1;
}

message Party {
    string id = 1 [(validator.field) = {msg_exists : true}];
    repeated Position positions = 2;
}

message RiskFactor {
  string market = 1;
  double short = 2;
  double long = 3;
}

message RiskResult {
  // timestamp when these risk factors were generated
  int64 updatedTimestamp = 1;
  // risk factors (long and short) for each marginable asset/currency (usually == settlement assets) in the market
  map<string, RiskFactor> riskFactors = 2;
  // time when risk factors are expected to change (or empty if risk factors are continually updated)
  int64 nextUpdateTimestamp = 3;
  // predicted risk factors at next change (what they'd be if the change occurred now)
  map<string, RiskFactor> predictedNextRiskFactors = 4;
}

message Order {
  enum TimeInForce {
    GTC = 0;
    GTT = 1;
    IOC = 2;
    FOK = 3;
  }

  enum Type {
    LIMIT   = 0; // Limit order
    MARKET  = 1; // Market order type
    NETWORK = 2; // order where the initiating party is the network (used for distressed traders)
  }

  enum Status {
    Active = 0;
    Expired = 1;
    Cancelled = 2;
    Stopped = 3;
    Filled = 4;
    Rejected = 5;
  }

  string id = 1;
  string marketID = 2;
  string partyID = 3;
  Side side = 4;
  uint64 price = 5;
  uint64 size = 6;
  uint64 remaining = 7;
  TimeInForce timeInForce  = 8;
  Type type = 9;
  int64 createdAt = 10;
  Status status = 11;
  int64 expiresAt = 12;
  string reference = 13;
  OrderError reason = 14;
}

message OrderCancellationConfirmation {
    Order order = 1;
}

message OrderConfirmation {
    Order order = 1;
    repeated Trade trades = 2;
    repeated Order passiveOrdersAffected = 3;
}

enum OrderError {
  NONE = 0;
  INVALID_MARKET_ID = 1;
  INVALID_ORDER_ID = 2;
  ORDER_OUT_OF_SEQUENCE = 3;
  INVALID_REMAINING_SIZE = 4;
  TIME_FAILURE = 5;
  ORDER_REMOVAL_FAILURE = 6;
  INVALID_EXPIRATION_DATETIME = 7;
  INVALID_ORDER_REFERENCE = 8;
  EDIT_NOT_ALLOWED = 9;
  ORDER_AMEND_FAILURE = 10;
  ORDER_NOT_FOUND = 11;
  INVALID_PARTY_ID = 12;
  MARKET_CLOSED = 13;
  MARGIN_CHECK_FAILED = 14;
  MISSING_GENERAL_ACCOUNT = 15;
  INTERNAL_ERROR = 16;
}

message Trade {
    string id = 1;
    string marketID = 2;
    uint64 price = 3;
    uint64 size = 4;
    string buyer = 5;
    string seller = 6;
    Side aggressor = 7;
    string buyOrder = 8;
    string sellOrder = 9;
    int64 timestamp = 10;
}

message TradeSet {
    repeated Trade trades = 1;
}

message Candle {
    int64 timestamp = 1;
    string datetime = 2;
    uint64 high = 3;
    uint64 low = 4;
    uint64 open = 5;
    uint64 close = 6;
    uint64 volume = 7;
    Interval interval = 8;
}

message PriceLevel {
    uint64 price = 1;
    uint64 numberOfOrders = 2;
    uint64 volume = 3;
    uint64 cumulativeVolume = 4;
}

message MarketDepth {
    string marketID = 1;
    repeated PriceLevel buy = 2;
    repeated PriceLevel sell = 3;
}

message Position {
    string marketID = 1;
    string partyID = 2;
    int64 openVolume = 3;
    int64 realisedPNL  = 4;
    int64 unrealisedPNL = 5;
    uint64 averageEntryPrice = 6;
}

message PositionTrade {
  int64 volume = 1;
  uint64 price = 2;
}

message Statistics {
  uint64 blockHeight = 1;
  uint64 backlogLength = 2;
  uint64 totalPeers = 3;
  string genesisTime = 4;
  string currentTime = 5;
  string vegaTime = 6;
  ChainStatus status = 7;
  uint64 txPerBlock = 8;
  uint64 averageTxBytes = 9;
  uint64 averageOrdersPerBlock = 10;
  uint64 tradesPerSecond = 11;
  uint64 ordersPerSecond = 12;
  uint64 totalMarkets = 13;
  uint64 totalParties = 14;
  repeated string parties = 15;
  uint64 totalAmendOrder = 16;
  uint64 totalCancelOrder = 17;
  uint64 totalCreateOrder = 18;
  uint64 totalOrders = 19;
  uint64 totalTrades = 20;
  int32 orderSubscriptions = 21;
  int32 tradeSubscriptions = 22;
  int32 candleSubscriptions = 23;
  int32 marketDepthSubscriptions = 24;
  int32 positionsSubscriptions = 25;
  int32 accountSubscriptions = 26;
  int32 marketDataSubscriptions = 27;
  string appVersionHash = 28;
  string appVersion = 29;
  string chainVersion = 30;
  uint64 blockDuration = 31; // nanoseconds
  string uptime = 32;
}

enum ChainStatus {
    DISCONNECTED = 0;
    REPLAYING = 1;
    CONNECTED = 2;
}

message PendingOrder {
  string reference = 1;
  uint64 price = 2;
  Order.TimeInForce TimeInForce = 3;
  Side side = 4;
  string marketID = 5;
  uint64 size = 6;
  string partyID = 7;
  Order.Status status = 8;
  string id = 9;
  Order.Type type = 10;
}

message NotifyTraderAccount {
  string traderID = 1;
  uint64 amount = 2;
}

message Withdraw {
  string partyID = 1;
  uint64 amount = 2;
  string asset = 3;
}

message OrderAmendment {
  string orderID = 1 [(validator.field) = {string_not_empty : true}];
  string partyID = 2 [(validator.field) = {string_not_empty: true}];
  string marketID = 3;
  uint64 price = 4 [(validator.field) = {int_gt: 0}];
  uint64 size = 5 [(validator.field) = {int_gt: 0}];
  int64 expiresAt = 6;
  Side side = 7;
}

message OrderSubmission {
  string id = 1 [(validator.field) = {string_not_empty: false}];
  string marketID = 2 [(validator.field) = {string_not_empty: true}];
  string partyID = 3 [(validator.field) = {string_not_empty: true}];
  // do not enforce that price, as Market Order will not have price specified
  uint64 price = 4;
  uint64 size = 5 [(validator.field) = {int_gt: 0}];
  // make sur for both that they are non nil and the value is part of the respective enums.
  Side side = 6 [(validator.field) = {is_in_enum: true}];
  Order.TimeInForce TimeInForce = 7 [(validator.field) = {is_in_enum: true}];
  // do not enforce as not always required
  // althouth at least check it's not a negative integer, would be not that very handy to create a time.Time with it
  int64 expiresAt = 8;
  Order.Type type = 9 [(validator.field) = {is_in_enum : true}];
}

message OrderCancellation {
  string orderID = 1 [(validator.field) = {string_not_empty: true}];
  string marketID = 2 [(validator.field) = {string_not_empty: true}];
  string partyID = 3 [(validator.field) = {string_not_empty: true}];
}

enum AccountType {
  ALL = 0;
  INSURANCE = 1;
  SETTLEMENT = 2;
  MARGIN = 3;
  GENERAL = 4;
}

message Account {
  string id = 1;
  string owner = 2;
  int64 balance = 3;
  string asset = 4;
  string marketID = 5;
  AccountType type = 6;
}

message FinancialAmount {
  int64 amount = 1;
  string asset = 2;
  int64 minAmount = 3;
}

enum TransferType {
  LOSS = 0;
  WIN = 1;
  CLOSE = 2;
  MTM_LOSS = 3;
  MTM_WIN = 4;
  MARGIN_LOW = 5;
  MARGIN_HIGH = 6;
  MARGIN_CONFISCATED = 7;
}

message Transfer {
  string owner = 1;
  uint64 size = 2;
  FinancialAmount amount = 3;
  TransferType type = 4;
}

message TransferRequest {
  repeated Account fromAccount = 1;
  repeated Account toAccount = 2;
  uint64 amount = 3;
  uint64 minAmount = 4;
  string asset = 5;
  string reference = 6;
}

message LedgerEntry {
  string fromAccount = 1;
  string toAccount = 2;
  int64 amount = 3;
  string reference = 4;
  string type = 5;
  int64 timestamp = 6;
}

message TransferBalance {
  Account account = 1;
  int64 balance = 2;
}

message TransferResponse {
  repeated LedgerEntry transfers = 1;
  repeated TransferBalance balances = 2;
}

message MarginLevels {
  int64 maintenanceMargin = 1;
  int64 searchLevel = 2;
  int64 initialMargin = 3;
  int64 collateralReleaseLevel = 4;
  string partyID = 5;
  string marketID = 6;
  string asset = 7;
  int64 timestamp = 8;
}

message MarketData {
  uint64 markPrice = 1;
  uint64 bestBidPrice = 2;
  uint64 bestBidVolume = 3;
  uint64 bestOfferPrice = 4;
  uint64 bestOfferVolume = 5;
  uint64 midPrice = 6;
  string market = 7;
  int64 timestamp = 8;
}

message ErrorDetail {
  int32 code = 1;
  string message = 2;
}
