// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/protos/data-node/api/v2"
	"code.vegaprotocol.io/vega/protos/vega"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

// union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind
type Event interface {
	IsEvent()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type TransferKind interface {
	IsTransferKind()
}

// One of the possible asset sources for update assets proposals
type UpdateAssetSource interface {
	IsUpdateAssetSource()
}

type UpdateMarketRiskParameters interface {
	IsUpdateMarketRiskParameters()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// An auction duration is used to configure 3 auction periods:
// 1. `duration > 0`, `volume == 0`:
// The auction will last for at least N seconds.
// 2. `duration == 0`, `volume > 0`:
// The auction will end once the given volume will match at uncrossing.
// 3. `duration > 0`, `volume > 0`:
// The auction will take at least N seconds, but can end sooner if the market can trade a certain volume.
type AuctionDuration struct {
	// Duration of the auction in seconds
	DurationSecs int `json:"durationSecs"`
	// Target uncrossing trading volume
	Volume int `json:"volume"`
}

// A Vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

type BusEvent struct {
	// the ID for this event
	EventID string `json:"eventId"`
	// the block hash
	Block string `json:"block"`
	// the type of event
	Type BusEventType `json:"type"`
	// the payload - the wrapped event
	Event Event `json:"event"`
}

// A mode where Vega tries to execute orders as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

type DispatchStrategy struct {
	// Defines the data that will be used to compare markets so as to distribute rewards appropriately
	DispatchMetric vega.DispatchMetric `json:"dispatchMetric"`
	// The asset to use for measuring contribution to the metric
	DispatchMetricAssetID string `json:"dispatchMetricAssetId"`
	// Scope the dispatch to this market only under the metric asset
	MarketIdsInScope []string `json:"marketIdsInScope"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the ERC20 contract
	ContractAddress string `json:"contractAddress"`
	// The lifetime limits deposit per address
	// Note: this is a temporary measure for alpha mainnet
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum allowed per withdrawal
	// Note: this is a temporary measure for alpha mainnet
	WithdrawThreshold string `json:"withdrawThreshold"`
}

func (Erc20) IsAssetSource() {}

type EpochParticipation struct {
	Epoch *vega.Epoch `json:"epoch"`
	// RFC3339 timestamp
	Offline *string `json:"offline"`
	// RFC3339 timestamp
	Online       *string  `json:"online"`
	TotalRewards *float64 `json:"totalRewards"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawn
	Amount string `json:"amount"`
	// Timestamp in seconds for expiry of the approval
	Expiry string `json:"expiry"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
	// The target address which will receive the funds
	TargetAddress string `json:"targetAddress"`
	// Timestamp at which the withdrawal was created
	Creation string `json:"creation"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// An Ethereum oracle
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

type LedgerEntry struct {
	// Account from which the asset was taken
	FromAccount string `json:"fromAccount"`
	// Account to which the balance was transferred
	ToAccount string `json:"toAccount"`
	// The amount transferred
	Amount string `json:"amount"`
	// The transfer reference
	Reference string `json:"reference"`
	// Type of ledger entry
	Type string `json:"type"`
	// RFC3339Nano time at which the transfer was made
	Timestamp string `json:"timestamp"`
}

// Configuration of a market liquidity monitoring parameters
type LiquidityMonitoringParameters struct {
	// Specifies parameters related to target stake calculation
	TargetStakeParameters *TargetStakeParameters `json:"targetStakeParameters"`
	// Specifies the triggering ratio for entering liquidity auction
	TriggeringRatio float64 `json:"triggeringRatio"`
}

// The equity like share of liquidity fee for each liquidity provider
type LiquidityProviderFeeShare struct {
	// The liquidity provider party ID
	Party *vega.Party `json:"party"`
	// The share owned by this liquidity provider (float)
	EquityLikeShare string `json:"equityLikeShare"`
	// The average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
}

type LossSocialization struct {
	// the market ID where loss socialization happened
	MarketID string `json:"marketId"`
	// the party that was part of the loss socialization
	PartyID string `json:"partyId"`
	// the amount lost
	Amount string `json:"amount"`
}

func (LossSocialization) IsEvent() {}

// The liquidity commitments for this market
type MarketDataCommitments struct {
	// a set of liquidity sell orders to meet the liquidity provision obligation.
	Sells []*vega.LiquidityOrderReference `json:"sells"`
	// a set of liquidity buy orders to meet the liquidity provision obligation.
	Buys []*vega.LiquidityOrderReference `json:"buys"`
}

type MarketDepthTrade struct {
	// ID of the trade for the given market (if available)
	ID string `json:"id"`
	// Price of the trade
	Price string `json:"price"`
	// Size of the trade
	Size string `json:"size"`
}

type MarketEvent struct {
	// the market ID
	MarketID string `json:"marketId"`
	// the message - market events are used for logging
	Payload string `json:"payload"`
}

func (MarketEvent) IsEvent() {}

type MarketTick struct {
	// the market ID
	MarketID string `json:"marketId"`
	// the block time
	Time string `json:"time"`
}

func (MarketTick) IsEvent() {}

// The equity like share of liquidity fee for each liquidity provider
type ObservableLiquidityProviderFeeShare struct {
	// The liquidity provider party ID
	PartyID string `json:"partyId"`
	// The share owned by this liquidity provider (float)
	EquityLikeShare string `json:"equityLikeShare"`
	// The average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
}

type OffsetPagination struct {
	// Skip the number of records specified, default is 0
	Skip int `json:"skip"`
	// Limit the number of returned records to the value specified, default is 50
	Limit int `json:"limit"`
	// Descending reverses the order of the records returned
	// default is true, if false the results will be returned in ascending order
	Descending bool `json:"descending"`
}

// An estimate of the fee to be paid by the order
type OrderEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
	// The margin requirement for this order
	MarginLevels *vega.MarginLevels `json:"marginLevels"`
}

type PositionResolution struct {
	// The market ID where position resolution happened
	MarketID string `json:"marketId"`
	// Number of distressed parties on market
	Distressed int `json:"distressed"`
	// Number of parties closed out
	Closed int `json:"closed"`
	// The mark price at which parties were distressed/closed out
	MarkPrice string `json:"markPrice"`
}

func (PositionResolution) IsEvent() {}

// Range of valid prices and the associated price monitoring trigger
type PriceMonitoringBounds struct {
	// Minimum price that isn't currently breaching the specified price monitoring trigger
	MinValidPrice string `json:"minValidPrice"`
	// Maximum price that isn't currently breaching the specified price monitoring trigger
	MaxValidPrice string `json:"maxValidPrice"`
	// Price monitoring trigger associated with the bounds
	Trigger *PriceMonitoringTrigger `json:"trigger"`
	// Reference price used to calculate the valid price range
	ReferencePrice string `json:"referencePrice"`
}

// PriceMonitoringParameters holds a list of triggers
type PriceMonitoringParameters struct {
	// The list of triggers for this price monitoring
	Triggers []*PriceMonitoringTrigger `json:"triggers"`
}

// Configuration of a market price monitoring auctions triggers
type PriceMonitoringSettings struct {
	// Specified a set of PriceMonitoringParameters to be use for price monitoring purposes
	Parameters *PriceMonitoringParameters `json:"parameters"`
}

// PriceMonitoringParameters holds together price projection horizon τ, probability level p, and auction extension duration
type PriceMonitoringTrigger struct {
	// Price monitoring projection horizon τ in seconds (> 0).
	HorizonSecs int `json:"horizonSecs"`
	// Price monitoring probability level p. (>0 and < 1)
	Probability float64 `json:"probability"`
	// Price monitoring auction extension duration in seconds should the price
	// breach its theoretical level over the specified horizon at the specified
	// probability level (> 0)
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

type ProposalVote struct {
	// Cast vote
	Vote *vega.Vote `json:"vote"`
	// Proposal the vote is cast on
	ProposalID string `json:"proposalId"`
}

type ProposalVoteConnection struct {
	// The proposal votes in this connection
	Edges []*ProposalVoteEdge `json:"edges"`
	// The pagination information
	PageInfo *v2.PageInfo `json:"pageInfo"`
}

type ProposalVoteEdge struct {
	Node   *ProposalVote `json:"node"`
	Cursor *string       `json:"cursor"`
}

type ProposalVoteSide struct {
	// All votes cast for this side
	Votes []*vega.Vote `json:"votes"`
	// Total number of votes cast for this side
	TotalNumber string `json:"totalNumber"`
	// Total weight of governance token from the votes cast for this side
	TotalWeight string `json:"totalWeight"`
	// Total number of governance tokens from the votes cast for this side
	TotalTokens string `json:"totalTokens"`
}

type ProposalVotes struct {
	// Yes votes cast for this proposal
	Yes *ProposalVoteSide `json:"yes"`
	// No votes cast for this proposal
	No *ProposalVoteSide `json:"no"`
}

type RewardSummaryConnection struct {
	// List of reward summaries available for the connection
	Edges []*RewardSummaryEdge `json:"edges"`
	// Page information for the connection
	PageInfo *v2.PageInfo `json:"pageInfo"`
}

type RewardSummaryEdge struct {
	// The reward summary
	Node *vega.RewardSummary `json:"node"`
	// Cursor identifying the reward summary
	Cursor string `json:"cursor"`
}

type SettleDistressed struct {
	// the market in which a position was closed out
	MarketID string `json:"marketId"`
	// the party that was closed out
	PartyID string `json:"partyId"`
	// the margin taken from distressed party
	Margin string `json:"margin"`
	// the price at which the position was closed out
	Price string `json:"price"`
}

func (SettleDistressed) IsEvent() {}

type SettlePosition struct {
	// the market in which a position was settled
	MarketID string `json:"marketId"`
	// the party who settled a position
	PartyID string `json:"partyId"`
	// the settle price
	Price string `json:"price"`
	// the trades that were settled to close the overall position
	TradeSettlements []*TradeSettlement `json:"tradeSettlements"`
}

func (SettlePosition) IsEvent() {}

// All staking information related to a Party.
// Contains the current recognised balance by the network and
// all the StakeLink/Unlink seen by the network
type StakingSummary struct {
	// The stake currently available for the party
	CurrentStakeAvailable string `json:"currentStakeAvailable"`
	// The list of all stake link/unlink for the party
	Linkings *v2.StakesConnection `json:"linkings"`
}

// TargetStakeParameters contains parameters used in target stake calculation
type TargetStakeParameters struct {
	// Specifies length of time window expressed in seconds for target stake calculation
	TimeWindow int `json:"timeWindow"`
	// Specifies scaling factors used in target stake calculation
	ScalingFactor float64 `json:"scalingFactor"`
}

type TimeUpdate struct {
	// RFC3339Nano time of new block time
	Timestamp string `json:"timestamp"`
}

func (TimeUpdate) IsEvent() {}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, paid by the aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the validators to maintain the Vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the liquidity providers that committed liquidity to the market
	LiquidityFee string `json:"liquidityFee"`
}

type TradeSettlement struct {
	// the size of the trade
	Size int `json:"size"`
	// the price of the trade
	Price string `json:"price"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

type TransferBalance struct {
	// Account involved in transfer
	Account *vega.Account `json:"account"`
	// The new balance of the account
	Balance string `json:"balance"`
}

type TransferResponse struct {
	// The ledger entries and balances resulting from a transfer request
	Transfers []*LedgerEntry `json:"transfers"`
	// The balances of accounts involved in the transfer
	Balances []*TransferBalance `json:"balances"`
}

type TransferResponses struct {
	// A group of transfer responses - events from core
	Responses []*TransferResponse `json:"responses"`
}

func (TransferResponses) IsEvent() {}

// An asset originated from an Ethereum ERC20 Token
type UpdateErc20 struct {
	// The lifetime limits deposit per address
	// Note: this is a temporary measure for alpha mainnet
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum allowed per withdrawal
	// Note: this is a temporary measure for alpha mainnet
	WithdrawThreshold string `json:"withdrawThreshold"`
}

func (UpdateErc20) IsUpdateAssetSource() {}

type UpdateInstrumentConfiguration struct {
	Code    string                    `json:"code"`
	Product *vega.UpdateFutureProduct `json:"product"`
}

type AuctionTrigger string

const (
	// Invalid trigger (or no auction)
	AuctionTriggerUnspecified AuctionTrigger = "Unspecified"
	// Auction because market has a frequent batch auction trading mode
	AuctionTriggerBatch AuctionTrigger = "Batch"
	// Opening auction
	AuctionTriggerOpening AuctionTrigger = "Opening"
	// Price monitoring
	AuctionTriggerPrice AuctionTrigger = "Price"
	// Liquidity monitoring
	AuctionTriggerLiquidity AuctionTrigger = "Liquidity"
)

var AllAuctionTrigger = []AuctionTrigger{
	AuctionTriggerUnspecified,
	AuctionTriggerBatch,
	AuctionTriggerOpening,
	AuctionTriggerPrice,
	AuctionTriggerLiquidity,
}

func (e AuctionTrigger) IsValid() bool {
	switch e {
	case AuctionTriggerUnspecified, AuctionTriggerBatch, AuctionTriggerOpening, AuctionTriggerPrice, AuctionTriggerLiquidity:
		return true
	}
	return false
}

func (e AuctionTrigger) String() string {
	return string(e)
}

func (e *AuctionTrigger) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuctionTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuctionTrigger", str)
	}
	return nil
}

func (e AuctionTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BusEventType string

const (
	// Vega Time has changed
	BusEventTypeTimeUpdate BusEventType = "TimeUpdate"
	// A balance has been transferred between accounts
	BusEventTypeTransferResponses BusEventType = "TransferResponses"
	// A position resolution event has occurred
	BusEventTypePositionResolution BusEventType = "PositionResolution"
	// An order has been created or updated
	BusEventTypeOrder BusEventType = "Order"
	// An account has been updated
	BusEventTypeAccount BusEventType = "Account"
	// A party has been updated
	BusEventTypeParty BusEventType = "Party"
	// A trade has been created
	BusEventTypeTrade BusEventType = "Trade"
	// Margin levels have changed for a position
	BusEventTypeMarginLevels BusEventType = "MarginLevels"
	// A governance proposal has been created or updated
	BusEventTypeProposal BusEventType = "Proposal"
	// A vote has been placed on a governance proposal
	BusEventTypeVote BusEventType = "Vote"
	// Market data has been updated
	BusEventTypeMarketData BusEventType = "MarketData"
	// Validator node signatures for an event
	BusEventTypeNodeSignature BusEventType = "NodeSignature"
	// A position has been closed without sufficient insurance pool balance to cover it
	BusEventTypeLossSocialization BusEventType = "LossSocialization"
	// A position has been settled
	BusEventTypeSettlePosition BusEventType = "SettlePosition"
	// A distressed position has been settled
	BusEventTypeSettleDistressed BusEventType = "SettleDistressed"
	// A new market has been created
	BusEventTypeMarketCreated BusEventType = "MarketCreated"
	// A market has been updated
	BusEventTypeMarketUpdated BusEventType = "MarketUpdated"
	// An asset has been created or update
	BusEventTypeAsset BusEventType = "Asset"
	// A market has progressed by one tick
	BusEventTypeMarketTick BusEventType = "MarketTick"
	// A market has either entered or exited auction
	BusEventTypeAuction BusEventType = "Auction"
	// A risk factor adjustment was made
	BusEventTypeRiskFactor BusEventType = "RiskFactor"
	// A liquidity commitment change occurred
	BusEventTypeLiquidityProvision BusEventType = "LiquidityProvision"
	// Collateral has deposited in to this Vega network via the bridge
	BusEventTypeDeposit BusEventType = "Deposit"
	// Collateral has been withdrawn from this Vega network via the bridge
	BusEventTypeWithdrawal BusEventType = "Withdrawal"
	// An oracle spec has been registered
	BusEventTypeOracleSpec BusEventType = "OracleSpec"
	// constant for market events - mainly used for logging
	BusEventTypeMarket BusEventType = "Market"
)

var AllBusEventType = []BusEventType{
	BusEventTypeTimeUpdate,
	BusEventTypeTransferResponses,
	BusEventTypePositionResolution,
	BusEventTypeOrder,
	BusEventTypeAccount,
	BusEventTypeParty,
	BusEventTypeTrade,
	BusEventTypeMarginLevels,
	BusEventTypeProposal,
	BusEventTypeVote,
	BusEventTypeMarketData,
	BusEventTypeNodeSignature,
	BusEventTypeLossSocialization,
	BusEventTypeSettlePosition,
	BusEventTypeSettleDistressed,
	BusEventTypeMarketCreated,
	BusEventTypeMarketUpdated,
	BusEventTypeAsset,
	BusEventTypeMarketTick,
	BusEventTypeAuction,
	BusEventTypeRiskFactor,
	BusEventTypeLiquidityProvision,
	BusEventTypeDeposit,
	BusEventTypeWithdrawal,
	BusEventTypeOracleSpec,
	BusEventTypeMarket,
}

func (e BusEventType) IsValid() bool {
	switch e {
	case BusEventTypeTimeUpdate, BusEventTypeTransferResponses, BusEventTypePositionResolution, BusEventTypeOrder, BusEventTypeAccount, BusEventTypeParty, BusEventTypeTrade, BusEventTypeMarginLevels, BusEventTypeProposal, BusEventTypeVote, BusEventTypeMarketData, BusEventTypeNodeSignature, BusEventTypeLossSocialization, BusEventTypeSettlePosition, BusEventTypeSettleDistressed, BusEventTypeMarketCreated, BusEventTypeMarketUpdated, BusEventTypeAsset, BusEventTypeMarketTick, BusEventTypeAuction, BusEventTypeRiskFactor, BusEventTypeLiquidityProvision, BusEventTypeDeposit, BusEventTypeWithdrawal, BusEventTypeOracleSpec, BusEventTypeMarket:
		return true
	}
	return false
}

func (e BusEventType) String() string {
	return string(e)
}

func (e *BusEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusEventType", str)
	}
	return nil
}

func (e BusEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Comparator describes the type of comparison.
type ConditionOperator string

const (
	// Verify if the property values are strictly equal or not.
	ConditionOperatorOperatorEquals ConditionOperator = "OperatorEquals"
	// Verify if the oracle data value is greater than the Condition value.
	ConditionOperatorOperatorGreaterThan ConditionOperator = "OperatorGreaterThan"
	// Verify if the oracle data value is greater than or equal to the Condition
	// value.
	ConditionOperatorOperatorGreaterThanOrEqual ConditionOperator = "OperatorGreaterThanOrEqual"
	//  Verify if the oracle data value is less than the Condition value.
	ConditionOperatorOperatorLessThan ConditionOperator = "OperatorLessThan"
	// Verify if the oracle data value is less or equal to than the Condition
	// value.
	ConditionOperatorOperatorLessThanOrEqual ConditionOperator = "OperatorLessThanOrEqual"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorOperatorEquals,
	ConditionOperatorOperatorGreaterThan,
	ConditionOperatorOperatorGreaterThanOrEqual,
	ConditionOperatorOperatorLessThan,
	ConditionOperatorOperatorLessThanOrEqual,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorOperatorEquals, ConditionOperatorOperatorGreaterThan, ConditionOperatorOperatorGreaterThanOrEqual, ConditionOperatorOperatorLessThan, ConditionOperatorOperatorLessThanOrEqual:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a deposit
type DepositStatus string

const (
	// The deposit is open and being processed by the network
	DepositStatusOpen DepositStatus = "Open"
	// The deposit have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	DepositStatusCancelled DepositStatus = "Cancelled"
	// The deposit was finalised, it was valid, the foreign chain has executed it and the network updated all accounts
	DepositStatusFinalized DepositStatus = "Finalized"
)

var AllDepositStatus = []DepositStatus{
	DepositStatusOpen,
	DepositStatusCancelled,
	DepositStatusFinalized,
}

func (e DepositStatus) IsValid() bool {
	switch e {
	case DepositStatusOpen, DepositStatusCancelled, DepositStatusFinalized:
		return true
	}
	return false
}

func (e DepositStatus) String() string {
	return string(e)
}

func (e *DepositStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DepositStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DepositStatus", str)
	}
	return nil
}

func (e DepositStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval for trade candles when subscribing via Vega GraphQL, default is I15M
type Interval string

const (
	// 1 minute interval
	IntervalI1m Interval = "I1M"
	// 5 minute interval
	IntervalI5m Interval = "I5M"
	// 15 minute interval (default)
	IntervalI15m Interval = "I15M"
	// 1 hour interval
	IntervalI1h Interval = "I1H"
	// 6 hour interval
	IntervalI6h Interval = "I6H"
	// 1 day interval
	IntervalI1d Interval = "I1D"
)

var AllInterval = []Interval{
	IntervalI1m,
	IntervalI5m,
	IntervalI15m,
	IntervalI1h,
	IntervalI6h,
	IntervalI1d,
}

func (e Interval) IsValid() bool {
	switch e {
	case IntervalI1m, IntervalI5m, IntervalI15m, IntervalI1h, IntervalI6h, IntervalI1d:
		return true
	}
	return false
}

func (e Interval) String() string {
	return string(e)
}

func (e *Interval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Interval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Interval", str)
	}
	return nil
}

func (e Interval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a liquidity provision order
type LiquidityProvisionStatus string

const (
	// An active liquidity provision
	LiquidityProvisionStatusActive LiquidityProvisionStatus = "Active"
	// A liquidity provision stopped by the network
	LiquidityProvisionStatusStopped LiquidityProvisionStatus = "Stopped"
	// A cancelled liquidity provision
	LiquidityProvisionStatusCancelled LiquidityProvisionStatus = "Cancelled"
	// Liquidity provision was invalid and got rejected
	LiquidityProvisionStatusRejected LiquidityProvisionStatus = "Rejected"
	// The liquidity provision is valid and accepted by the network, but orders aren't deployed
	LiquidityProvisionStatusUndeployed LiquidityProvisionStatus = "Undeployed"
	// The liquidity provision is valid and accepted by the network, but orders aren't deployed and
	// have never been deployed. If when it's possible to deploy them for the first time the
	// margin check fails, then they will be cancelled without any penalties.
	LiquidityProvisionStatusPending LiquidityProvisionStatus = "Pending"
)

var AllLiquidityProvisionStatus = []LiquidityProvisionStatus{
	LiquidityProvisionStatusActive,
	LiquidityProvisionStatusStopped,
	LiquidityProvisionStatusCancelled,
	LiquidityProvisionStatusRejected,
	LiquidityProvisionStatusUndeployed,
	LiquidityProvisionStatusPending,
}

func (e LiquidityProvisionStatus) IsValid() bool {
	switch e {
	case LiquidityProvisionStatusActive, LiquidityProvisionStatusStopped, LiquidityProvisionStatusCancelled, LiquidityProvisionStatusRejected, LiquidityProvisionStatusUndeployed, LiquidityProvisionStatusPending:
		return true
	}
	return false
}

func (e LiquidityProvisionStatus) String() string {
	return string(e)
}

func (e *LiquidityProvisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LiquidityProvisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LiquidityProvisionStatus", str)
	}
	return nil
}

func (e LiquidityProvisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The current state of a market
type MarketState string

const (
	// The governance proposal valid and accepted
	MarketStateProposed MarketState = "Proposed"
	// Outcome of governance votes is to reject the market
	MarketStateRejected MarketState = "Rejected"
	// Governance vote passes/wins
	MarketStatePending MarketState = "Pending"
	// Market triggers cancellation condition or governance
	// votes to close before market becomes Active
	MarketStateCancelled MarketState = "Cancelled"
	// Enactment date reached and usual auction exit checks pass
	MarketStateActive MarketState = "Active"
	// Price monitoring or liquidity monitoring trigger
	MarketStateSuspended MarketState = "Suspended"
	// Governance vote (to close)
	MarketStateClosed MarketState = "Closed"
	// Defined by the product (i.e. from a product parameter,
	// specified in market definition, giving close date/time)
	MarketStateTradingTerminated MarketState = "TradingTerminated"
	// Settlement triggered and completed as defined by product
	MarketStateSettled MarketState = "Settled"
)

var AllMarketState = []MarketState{
	MarketStateProposed,
	MarketStateRejected,
	MarketStatePending,
	MarketStateCancelled,
	MarketStateActive,
	MarketStateSuspended,
	MarketStateClosed,
	MarketStateTradingTerminated,
	MarketStateSettled,
}

func (e MarketState) IsValid() bool {
	switch e {
	case MarketStateProposed, MarketStateRejected, MarketStatePending, MarketStateCancelled, MarketStateActive, MarketStateSuspended, MarketStateClosed, MarketStateTradingTerminated, MarketStateSettled:
		return true
	}
	return false
}

func (e MarketState) String() string {
	return string(e)
}

func (e *MarketState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketState", str)
	}
	return nil
}

func (e MarketState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// What market trading mode is the market in
type MarketTradingMode string

const (
	// Continuous trading where orders are processed and potentially matched on arrival
	MarketTradingModeContinuous MarketTradingMode = "Continuous"
	// Auction trading where orders are uncrossed at the end of the opening auction period
	MarketTradingModeOpeningAuction MarketTradingMode = "OpeningAuction"
	// Auction as normal trading mode for the market, where orders are uncrossed periodically
	MarketTradingModeBatchAuction MarketTradingMode = "BatchAuction"
	// Auction triggered by price/liquidity monitoring
	MarketTradingModeMonitoringAuction MarketTradingMode = "MonitoringAuction"
	// No trading allowed
	MarketTradingModeNoTrading MarketTradingMode = "NoTrading"
)

var AllMarketTradingMode = []MarketTradingMode{
	MarketTradingModeContinuous,
	MarketTradingModeOpeningAuction,
	MarketTradingModeBatchAuction,
	MarketTradingModeMonitoringAuction,
	MarketTradingModeNoTrading,
}

func (e MarketTradingMode) IsValid() bool {
	switch e {
	case MarketTradingModeContinuous, MarketTradingModeOpeningAuction, MarketTradingModeBatchAuction, MarketTradingModeMonitoringAuction, MarketTradingModeNoTrading:
		return true
	}
	return false
}

func (e MarketTradingMode) String() string {
	return string(e)
}

func (e *MarketTradingMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketTradingMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketTradingMode", str)
	}
	return nil
}

func (e MarketTradingMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status describe the status of the oracle spec
type OracleSpecStatus string

const (
	// StatusActive describes an active oracle spec.
	OracleSpecStatusStatusActive OracleSpecStatus = "StatusActive"
	// StatusUnused describes an oracle spec that is not listening to data
	// anymore.
	OracleSpecStatusStatusUnused OracleSpecStatus = "StatusUnused"
)

var AllOracleSpecStatus = []OracleSpecStatus{
	OracleSpecStatusStatusActive,
	OracleSpecStatusStatusUnused,
}

func (e OracleSpecStatus) IsValid() bool {
	switch e {
	case OracleSpecStatusStatusActive, OracleSpecStatusStatusUnused:
		return true
	}
	return false
}

func (e OracleSpecStatus) String() string {
	return string(e)
}

func (e *OracleSpecStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OracleSpecStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OracleSpecStatus", str)
	}
	return nil
}

func (e OracleSpecStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the order being rejected by the core node
type OrderRejectionReason string

const (
	// Market ID is invalid
	OrderRejectionReasonInvalidMarketID OrderRejectionReason = "InvalidMarketId"
	// Order ID is invalid
	OrderRejectionReasonInvalidOrderID OrderRejectionReason = "InvalidOrderId"
	// Order is out of sequence
	OrderRejectionReasonOrderOutOfSequence OrderRejectionReason = "OrderOutOfSequence"
	// Remaining size in the order is invalid
	OrderRejectionReasonInvalidRemainingSize OrderRejectionReason = "InvalidRemainingSize"
	// Time has failed us
	OrderRejectionReasonTimeFailure OrderRejectionReason = "TimeFailure"
	// Unable to remove the order
	OrderRejectionReasonOrderRemovalFailure OrderRejectionReason = "OrderRemovalFailure"
	// Expiration time is invalid
	OrderRejectionReasonInvalidExpirationTime OrderRejectionReason = "InvalidExpirationTime"
	// Order reference is invalid
	OrderRejectionReasonInvalidOrderReference OrderRejectionReason = "InvalidOrderReference"
	// Edit is not allowed
	OrderRejectionReasonEditNotAllowed OrderRejectionReason = "EditNotAllowed"
	// Amending the order failed
	OrderRejectionReasonOrderAmendFailure OrderRejectionReason = "OrderAmendFailure"
	// Order does not exist
	OrderRejectionReasonOrderNotFound OrderRejectionReason = "OrderNotFound"
	// Party ID is invalid
	OrderRejectionReasonInvalidPartyID OrderRejectionReason = "InvalidPartyId"
	// Market is closed
	OrderRejectionReasonMarketClosed OrderRejectionReason = "MarketClosed"
	// Margin check failed - not enough available margin
	OrderRejectionReasonMarginCheckFailed OrderRejectionReason = "MarginCheckFailed"
	// Order missing general account
	OrderRejectionReasonMissingGeneralAccount OrderRejectionReason = "MissingGeneralAccount"
	// An internal error happened
	OrderRejectionReasonInternalError OrderRejectionReason = "InternalError"
	// Invalid size
	OrderRejectionReasonInvalidSize OrderRejectionReason = "InvalidSize"
	// Invalid persistence
	OrderRejectionReasonInvalidPersistence OrderRejectionReason = "InvalidPersistence"
	// Invalid type
	OrderRejectionReasonInvalidType OrderRejectionReason = "InvalidType"
	// Order cannot be filled because it would require self trading
	OrderRejectionReasonSelfTrading OrderRejectionReason = "SelfTrading"
	// Insufficient funds to pay fees
	OrderRejectionReasonInsufficientFundsToPayFees OrderRejectionReason = "InsufficientFundsToPayFees"
	// Invalid Time In Force
	OrderRejectionReasonInvalidTimeInForce OrderRejectionReason = "InvalidTimeInForce"
	// Attempt to amend order to Good til Time without expiry time
	OrderRejectionReasonAmendToGTTWithoutExpiryAt OrderRejectionReason = "AmendToGTTWithoutExpiryAt"
	// Attempt to amend expiry time to a value before time order was created
	OrderRejectionReasonExpiryAtBeforeCreatedAt OrderRejectionReason = "ExpiryAtBeforeCreatedAt"
	// Attempt to amend to Good till Cancelled without an expiry time
	OrderRejectionReasonGTCWithExpiryAtNotValid OrderRejectionReason = "GTCWithExpiryAtNotValid"
	// Amending to Fill or Kill, or Immediate or Cancel is invalid
	OrderRejectionReasonCannotAmendToFOKOrIoc OrderRejectionReason = "CannotAmendToFOKOrIOC"
	// Amending to Good for Auction or Good for Normal is invalid
	OrderRejectionReasonCannotAmendToGFAOrGfn OrderRejectionReason = "CannotAmendToGFAOrGFN"
	// Amending from Good for Auction or Good for Normal is invalid
	OrderRejectionReasonCannotAmendFromGFAOrGfn OrderRejectionReason = "CannotAmendFromGFAOrGFN"
	// Invalid market type
	OrderRejectionReasonInvalidMarketType OrderRejectionReason = "InvalidMarketType"
	// Good for Normal order received during an auction
	OrderRejectionReasonGFNOrderDuringAuction OrderRejectionReason = "GFNOrderDuringAuction"
	// Good for Auction order received during continuous trading
	OrderRejectionReasonGFAOrderDuringContinuousTrading OrderRejectionReason = "GFAOrderDuringContinuousTrading"
	// Immediate or Cancel orders are not allowed during auction
	OrderRejectionReasonIOCOrderDuringAuction OrderRejectionReason = "IOCOrderDuringAuction"
	// Fill or Kill orders are not allowed during auction
	OrderRejectionReasonFOKOrderDuringAuction OrderRejectionReason = "FOKOrderDuringAuction"
	// Pegged orders must be limit orders
	OrderRejectionReasonPeggedOrderMustBeLimitOrder OrderRejectionReason = "PeggedOrderMustBeLimitOrder"
	// Pegged orders can only have a time in force of Good til Cancelled or Good til Time
	OrderRejectionReasonPeggedOrderMustBeGTTOrGtc OrderRejectionReason = "PeggedOrderMustBeGTTOrGTC"
	// Pegged order must have a reference price
	OrderRejectionReasonPeggedOrderWithoutReferencePrice OrderRejectionReason = "PeggedOrderWithoutReferencePrice"
	// Buy pegged order cannot reference best ask price
	OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice OrderRejectionReason = "PeggedOrderBuyCannotReferenceBestAskPrice"
	// Pegged order offset must be >= 0
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero OrderRejectionReason = "PeggedOrderOffsetMustBeGreaterOrEqualToZero"
	// Sell pegged order cannot reference best bid price
	OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice OrderRejectionReason = "PeggedOrderSellCannotReferenceBestBidPrice"
	// Pegged order offset must be > zero
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero OrderRejectionReason = "PeggedOrderOffsetMustBeGreaterThanZero"
	// Insufficient balance to submit the order (no deposit made)
	OrderRejectionReasonInsufficientAssetBalance OrderRejectionReason = "InsufficientAssetBalance"
	// Cannot change pegged order fields on a non pegged order
	OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder OrderRejectionReason = "CannotAmendPeggedOrderDetailsOnNonPeggedOrder"
	// Unable to reprice a pegged order
	OrderRejectionReasonUnableToRepricePeggedOrder OrderRejectionReason = "UnableToRepricePeggedOrder"
	// Unable to amend pegged order price
	OrderRejectionReasonUnableToAmendPeggedOrderPrice OrderRejectionReason = "UnableToAmendPeggedOrderPrice"
	// Non-persistent order exceeds price bounds
	OrderRejectionReasonNonPersistentOrderExceedsPriceBounds OrderRejectionReason = "NonPersistentOrderExceedsPriceBounds"
)

var AllOrderRejectionReason = []OrderRejectionReason{
	OrderRejectionReasonInvalidMarketID,
	OrderRejectionReasonInvalidOrderID,
	OrderRejectionReasonOrderOutOfSequence,
	OrderRejectionReasonInvalidRemainingSize,
	OrderRejectionReasonTimeFailure,
	OrderRejectionReasonOrderRemovalFailure,
	OrderRejectionReasonInvalidExpirationTime,
	OrderRejectionReasonInvalidOrderReference,
	OrderRejectionReasonEditNotAllowed,
	OrderRejectionReasonOrderAmendFailure,
	OrderRejectionReasonOrderNotFound,
	OrderRejectionReasonInvalidPartyID,
	OrderRejectionReasonMarketClosed,
	OrderRejectionReasonMarginCheckFailed,
	OrderRejectionReasonMissingGeneralAccount,
	OrderRejectionReasonInternalError,
	OrderRejectionReasonInvalidSize,
	OrderRejectionReasonInvalidPersistence,
	OrderRejectionReasonInvalidType,
	OrderRejectionReasonSelfTrading,
	OrderRejectionReasonInsufficientFundsToPayFees,
	OrderRejectionReasonInvalidTimeInForce,
	OrderRejectionReasonAmendToGTTWithoutExpiryAt,
	OrderRejectionReasonExpiryAtBeforeCreatedAt,
	OrderRejectionReasonGTCWithExpiryAtNotValid,
	OrderRejectionReasonCannotAmendToFOKOrIoc,
	OrderRejectionReasonCannotAmendToGFAOrGfn,
	OrderRejectionReasonCannotAmendFromGFAOrGfn,
	OrderRejectionReasonInvalidMarketType,
	OrderRejectionReasonGFNOrderDuringAuction,
	OrderRejectionReasonGFAOrderDuringContinuousTrading,
	OrderRejectionReasonIOCOrderDuringAuction,
	OrderRejectionReasonFOKOrderDuringAuction,
	OrderRejectionReasonPeggedOrderMustBeLimitOrder,
	OrderRejectionReasonPeggedOrderMustBeGTTOrGtc,
	OrderRejectionReasonPeggedOrderWithoutReferencePrice,
	OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice,
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero,
	OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice,
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero,
	OrderRejectionReasonInsufficientAssetBalance,
	OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder,
	OrderRejectionReasonUnableToRepricePeggedOrder,
	OrderRejectionReasonUnableToAmendPeggedOrderPrice,
	OrderRejectionReasonNonPersistentOrderExceedsPriceBounds,
}

func (e OrderRejectionReason) IsValid() bool {
	switch e {
	case OrderRejectionReasonInvalidMarketID, OrderRejectionReasonInvalidOrderID, OrderRejectionReasonOrderOutOfSequence, OrderRejectionReasonInvalidRemainingSize, OrderRejectionReasonTimeFailure, OrderRejectionReasonOrderRemovalFailure, OrderRejectionReasonInvalidExpirationTime, OrderRejectionReasonInvalidOrderReference, OrderRejectionReasonEditNotAllowed, OrderRejectionReasonOrderAmendFailure, OrderRejectionReasonOrderNotFound, OrderRejectionReasonInvalidPartyID, OrderRejectionReasonMarketClosed, OrderRejectionReasonMarginCheckFailed, OrderRejectionReasonMissingGeneralAccount, OrderRejectionReasonInternalError, OrderRejectionReasonInvalidSize, OrderRejectionReasonInvalidPersistence, OrderRejectionReasonInvalidType, OrderRejectionReasonSelfTrading, OrderRejectionReasonInsufficientFundsToPayFees, OrderRejectionReasonInvalidTimeInForce, OrderRejectionReasonAmendToGTTWithoutExpiryAt, OrderRejectionReasonExpiryAtBeforeCreatedAt, OrderRejectionReasonGTCWithExpiryAtNotValid, OrderRejectionReasonCannotAmendToFOKOrIoc, OrderRejectionReasonCannotAmendToGFAOrGfn, OrderRejectionReasonCannotAmendFromGFAOrGfn, OrderRejectionReasonInvalidMarketType, OrderRejectionReasonGFNOrderDuringAuction, OrderRejectionReasonGFAOrderDuringContinuousTrading, OrderRejectionReasonIOCOrderDuringAuction, OrderRejectionReasonFOKOrderDuringAuction, OrderRejectionReasonPeggedOrderMustBeLimitOrder, OrderRejectionReasonPeggedOrderMustBeGTTOrGtc, OrderRejectionReasonPeggedOrderWithoutReferencePrice, OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice, OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero, OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice, OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero, OrderRejectionReasonInsufficientAssetBalance, OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder, OrderRejectionReasonUnableToRepricePeggedOrder, OrderRejectionReasonUnableToAmendPeggedOrderPrice, OrderRejectionReasonNonPersistentOrderExceedsPriceBounds:
		return true
	}
	return false
}

func (e OrderRejectionReason) String() string {
	return string(e)
}

func (e *OrderRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderRejectionReason", str)
	}
	return nil
}

func (e OrderRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
type OrderStatus string

const (
	// The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
	// Active does not necessarily mean it's still on the order book.
	OrderStatusActive OrderStatus = "Active"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
	OrderStatusExpired OrderStatus = "Expired"
	// The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
	OrderStatusCancelled OrderStatus = "Cancelled"
	// This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity.
	OrderStatusStopped OrderStatus = "Stopped"
	// This order is fully filled with remaining equalling zero.
	OrderStatusFilled OrderStatus = "Filled"
	// This order was rejected while being processed.
	OrderStatusRejected OrderStatus = "Rejected"
	// This order was partially filled.
	OrderStatusPartiallyFilled OrderStatus = "PartiallyFilled"
	// This order has been removed from the order book because the market is in auction, the reference price doesn't exist, or the order needs to be repriced and can't. Applies to pegged orders only
	OrderStatusParked OrderStatus = "Parked"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusActive,
	OrderStatusExpired,
	OrderStatusCancelled,
	OrderStatusStopped,
	OrderStatusFilled,
	OrderStatusRejected,
	OrderStatusPartiallyFilled,
	OrderStatusParked,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusActive, OrderStatusExpired, OrderStatusCancelled, OrderStatusStopped, OrderStatusFilled, OrderStatusRejected, OrderStatusPartiallyFilled, OrderStatusParked:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order types, these determine what happens when an order is added to the book
type OrderTimeInForce string

const (
	// Fill or Kill: The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
	OrderTimeInForceFok OrderTimeInForce = "FOK"
	// Immediate or Cancel: The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
	OrderTimeInForceIoc OrderTimeInForce = "IOC"
	// Good 'til Cancelled: This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
	OrderTimeInForceGtc OrderTimeInForce = "GTC"
	// Good 'til Time: This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
	// NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
	OrderTimeInForceGtt OrderTimeInForce = "GTT"
	// Good for Auction: This order is only accepted during an auction period
	OrderTimeInForceGfa OrderTimeInForce = "GFA"
	// Good for Normal: This order is only accepted during normal trading (continuous trading or frequent batched auctions)
	OrderTimeInForceGfn OrderTimeInForce = "GFN"
)

var AllOrderTimeInForce = []OrderTimeInForce{
	OrderTimeInForceFok,
	OrderTimeInForceIoc,
	OrderTimeInForceGtc,
	OrderTimeInForceGtt,
	OrderTimeInForceGfa,
	OrderTimeInForceGfn,
}

func (e OrderTimeInForce) IsValid() bool {
	switch e {
	case OrderTimeInForceFok, OrderTimeInForceIoc, OrderTimeInForceGtc, OrderTimeInForceGtt, OrderTimeInForceGfa, OrderTimeInForceGfn:
		return true
	}
	return false
}

func (e OrderTimeInForce) String() string {
	return string(e)
}

func (e *OrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTimeInForce", str)
	}
	return nil
}

func (e OrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderType string

const (
	// An order to buy or sell at the market's current best available price
	OrderTypeMarket OrderType = "Market"
	// Order that uses a pre-specified price to buy or sell
	OrderTypeLimit OrderType = "Limit"
	// Used for distressed parties, an order placed by the network to close out distressed parties
	// similar to Market order, only no party is attached to the order.
	OrderTypeNetwork OrderType = "Network"
)

var AllOrderType = []OrderType{
	OrderTypeMarket,
	OrderTypeLimit,
	OrderTypeNetwork,
}

func (e OrderType) IsValid() bool {
	switch e {
	case OrderTypeMarket, OrderTypeLimit, OrderTypeNetwork:
		return true
	}
	return false
}

func (e OrderType) String() string {
	return string(e)
}

func (e *OrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderType", str)
	}
	return nil
}

func (e OrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid references used for pegged orders.
type PeggedReference string

const (
	// Peg the order against the mid price of the order book
	PeggedReferenceMid PeggedReference = "Mid"
	// Peg the order against the best bid price of the order book
	PeggedReferenceBestBid PeggedReference = "BestBid"
	// Peg the order against the best ask price of the order book
	PeggedReferenceBestAsk PeggedReference = "BestAsk"
)

var AllPeggedReference = []PeggedReference{
	PeggedReferenceMid,
	PeggedReferenceBestBid,
	PeggedReferenceBestAsk,
}

func (e PeggedReference) IsValid() bool {
	switch e {
	case PeggedReferenceMid, PeggedReferenceBestBid, PeggedReferenceBestAsk:
		return true
	}
	return false
}

func (e PeggedReference) String() string {
	return string(e)
}

func (e *PeggedReference) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeggedReference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeggedReference", str)
	}
	return nil
}

func (e PeggedReference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type describes the type of properties that are supported by the oracle
// engine.
type PropertyKeyType string

const (
	// Any type.
	PropertyKeyTypeTypeEmpty PropertyKeyType = "TypeEmpty"
	// Integer type.
	PropertyKeyTypeTypeInteger PropertyKeyType = "TypeInteger"
	// String type.
	PropertyKeyTypeTypeString PropertyKeyType = "TypeString"
	// Boolean type.
	PropertyKeyTypeTypeBoolean PropertyKeyType = "TypeBoolean"
	// Any floating point decimal type.
	PropertyKeyTypeTypeDecimal PropertyKeyType = "TypeDecimal"
	// Timestamp date type.
	PropertyKeyTypeTypeTimestamp PropertyKeyType = "TypeTimestamp"
)

var AllPropertyKeyType = []PropertyKeyType{
	PropertyKeyTypeTypeEmpty,
	PropertyKeyTypeTypeInteger,
	PropertyKeyTypeTypeString,
	PropertyKeyTypeTypeBoolean,
	PropertyKeyTypeTypeDecimal,
	PropertyKeyTypeTypeTimestamp,
}

func (e PropertyKeyType) IsValid() bool {
	switch e {
	case PropertyKeyTypeTypeEmpty, PropertyKeyTypeTypeInteger, PropertyKeyTypeTypeString, PropertyKeyTypeTypeBoolean, PropertyKeyTypeTypeDecimal, PropertyKeyTypeTypeTimestamp:
		return true
	}
	return false
}

func (e PropertyKeyType) String() string {
	return string(e)
}

func (e *PropertyKeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertyKeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertyKeyType", str)
	}
	return nil
}

func (e PropertyKeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the proposal being rejected by the core node
type ProposalRejectionReason string

const (
	// The specified close time is too early based on network parameters
	ProposalRejectionReasonCloseTimeTooSoon ProposalRejectionReason = "CloseTimeTooSoon"
	// The specified close time is too late based on network parameters
	ProposalRejectionReasonCloseTimeTooLate ProposalRejectionReason = "CloseTimeTooLate"
	// The specified enactment time is too early based on network parameters
	ProposalRejectionReasonEnactTimeTooSoon ProposalRejectionReason = "EnactTimeTooSoon"
	// The specified enactment time is too late based on network parameters
	ProposalRejectionReasonEnactTimeTooLate ProposalRejectionReason = "EnactTimeTooLate"
	// The proposer for this proposal has insufficient tokens
	ProposalRejectionReasonInsufficientTokens ProposalRejectionReason = "InsufficientTokens"
	// The instrument quote name and base name were the same
	ProposalRejectionReasonInvalidInstrumentSecurity ProposalRejectionReason = "InvalidInstrumentSecurity"
	// The proposal has no product specified
	ProposalRejectionReasonNoProduct ProposalRejectionReason = "NoProduct"
	// The specified product is not supported
	ProposalRejectionReasonUnsupportedProduct ProposalRejectionReason = "UnsupportedProduct"
	// Invalid future maturity timestamp (expect RFC3339)
	ProposalRejectionReasonInvalidFutureMaturityTimestamp ProposalRejectionReason = "InvalidFutureMaturityTimestamp"
	// The product maturity is already in the past
	ProposalRejectionReasonProductMaturityIsPassed ProposalRejectionReason = "ProductMaturityIsPassed"
	// The proposal has no trading mode
	ProposalRejectionReasonNoTradingMode ProposalRejectionReason = "NoTradingMode"
	// The proposal has an unsupported trading mode
	ProposalRejectionReasonUnsupportedTradingMode ProposalRejectionReason = "UnsupportedTradingMode"
	// The proposal failed node validation
	ProposalRejectionReasonNodeValidationFailed ProposalRejectionReason = "NodeValidationFailed"
	// A builtin asset configuration is missing
	ProposalRejectionReasonMissingBuiltinAssetField ProposalRejectionReason = "MissingBuiltinAssetField"
	// The ERC20 contract address is missing from an ERC20 asset proposal
	ProposalRejectionReasonMissingERC20ContractAddress ProposalRejectionReason = "MissingERC20ContractAddress"
	// The specified asset for the market proposal is invalid
	ProposalRejectionReasonInvalidAsset ProposalRejectionReason = "InvalidAsset"
	// proposal terms timestamps are not compatible (Validation < Closing < Enactment)
	ProposalRejectionReasonIncompatibleTimestamps ProposalRejectionReason = "IncompatibleTimestamps"
	// Risk parameters are missing from the market proposal
	ProposalRejectionReasonNoRiskParameters ProposalRejectionReason = "NoRiskParameters"
	// Invalid key in update network parameter proposal
	ProposalRejectionReasonNetworkParameterInvalidKey ProposalRejectionReason = "NetworkParameterInvalidKey"
	// Invalid value in update network parameter proposal
	ProposalRejectionReasonNetworkParameterInvalidValue ProposalRejectionReason = "NetworkParameterInvalidValue"
	// Validation failed for network parameter proposal
	ProposalRejectionReasonNetworkParameterValidationFailed ProposalRejectionReason = "NetworkParameterValidationFailed"
	// Opening auction duration is less than the network minimum opening auction time
	ProposalRejectionReasonOpeningAuctionDurationTooSmall ProposalRejectionReason = "OpeningAuctionDurationTooSmall"
	// Opening auction duration is more than the network minimum opening auction time
	ProposalRejectionReasonOpeningAuctionDurationTooLarge ProposalRejectionReason = "OpeningAuctionDurationTooLarge"
	// Market proposal is missing a liquidity commitment
	ProposalRejectionReasonMarketMissingLiquidityCommitment ProposalRejectionReason = "MarketMissingLiquidityCommitment"
	// Market could not be created
	ProposalRejectionReasonCouldNotInstantiateMarket ProposalRejectionReason = "CouldNotInstantiateMarket"
	// Market proposal market contained invalid product definition
	ProposalRejectionReasonInvalidFutureProduct ProposalRejectionReason = "InvalidFutureProduct"
	// Market proposal is missing commitment amount
	ProposalRejectionReasonMissingCommitmentAmount ProposalRejectionReason = "MissingCommitmentAmount"
	// Market proposal has invalid fee amount
	ProposalRejectionReasonInvalidFeeAmount ProposalRejectionReason = "InvalidFeeAmount"
	// Market proposal has one or more invalid liquidity shapes
	ProposalRejectionReasonInvalidShape ProposalRejectionReason = "InvalidShape"
	// Market proposal uses an invalid risk parameter
	ProposalRejectionReasonInvalidRiskParameter ProposalRejectionReason = "InvalidRiskParameter"
	// Proposal declined because the majority threshold was not reached
	ProposalRejectionReasonMajorityThresholdNotReached ProposalRejectionReason = "MajorityThresholdNotReached"
	// Proposal declined because the participation threshold was not reached
	ProposalRejectionReasonParticipationThresholdNotReached ProposalRejectionReason = "ParticipationThresholdNotReached"
	// Asset details are invalid
	ProposalRejectionReasonInvalidAssetDetails ProposalRejectionReason = "InvalidAssetDetails"
	// Too many price monitoring triggers specified in market
	ProposalRejectionReasonTooManyPriceMonitoringTriggers ProposalRejectionReason = "TooManyPriceMonitoringTriggers"
	// Too many decimal places specified in market
	ProposalRejectionReasonTooManyMarketDecimalPlaces ProposalRejectionReason = "TooManyMarketDecimalPlaces"
	// The market is invalid
	ProposalRejectionReasonInvalidMarket ProposalRejectionReason = "InvalidMarket"
	// The proposal is rejected because the party does not have enough equity like share in the market
	ProposalRejectionReasonInsufficientEquityLikeShare ProposalRejectionReason = "InsufficientEquityLikeShare"
)

var AllProposalRejectionReason = []ProposalRejectionReason{
	ProposalRejectionReasonCloseTimeTooSoon,
	ProposalRejectionReasonCloseTimeTooLate,
	ProposalRejectionReasonEnactTimeTooSoon,
	ProposalRejectionReasonEnactTimeTooLate,
	ProposalRejectionReasonInsufficientTokens,
	ProposalRejectionReasonInvalidInstrumentSecurity,
	ProposalRejectionReasonNoProduct,
	ProposalRejectionReasonUnsupportedProduct,
	ProposalRejectionReasonInvalidFutureMaturityTimestamp,
	ProposalRejectionReasonProductMaturityIsPassed,
	ProposalRejectionReasonNoTradingMode,
	ProposalRejectionReasonUnsupportedTradingMode,
	ProposalRejectionReasonNodeValidationFailed,
	ProposalRejectionReasonMissingBuiltinAssetField,
	ProposalRejectionReasonMissingERC20ContractAddress,
	ProposalRejectionReasonInvalidAsset,
	ProposalRejectionReasonIncompatibleTimestamps,
	ProposalRejectionReasonNoRiskParameters,
	ProposalRejectionReasonNetworkParameterInvalidKey,
	ProposalRejectionReasonNetworkParameterInvalidValue,
	ProposalRejectionReasonNetworkParameterValidationFailed,
	ProposalRejectionReasonOpeningAuctionDurationTooSmall,
	ProposalRejectionReasonOpeningAuctionDurationTooLarge,
	ProposalRejectionReasonMarketMissingLiquidityCommitment,
	ProposalRejectionReasonCouldNotInstantiateMarket,
	ProposalRejectionReasonInvalidFutureProduct,
	ProposalRejectionReasonMissingCommitmentAmount,
	ProposalRejectionReasonInvalidFeeAmount,
	ProposalRejectionReasonInvalidShape,
	ProposalRejectionReasonInvalidRiskParameter,
	ProposalRejectionReasonMajorityThresholdNotReached,
	ProposalRejectionReasonParticipationThresholdNotReached,
	ProposalRejectionReasonInvalidAssetDetails,
	ProposalRejectionReasonTooManyPriceMonitoringTriggers,
	ProposalRejectionReasonTooManyMarketDecimalPlaces,
	ProposalRejectionReasonInvalidMarket,
	ProposalRejectionReasonInsufficientEquityLikeShare,
}

func (e ProposalRejectionReason) IsValid() bool {
	switch e {
	case ProposalRejectionReasonCloseTimeTooSoon, ProposalRejectionReasonCloseTimeTooLate, ProposalRejectionReasonEnactTimeTooSoon, ProposalRejectionReasonEnactTimeTooLate, ProposalRejectionReasonInsufficientTokens, ProposalRejectionReasonInvalidInstrumentSecurity, ProposalRejectionReasonNoProduct, ProposalRejectionReasonUnsupportedProduct, ProposalRejectionReasonInvalidFutureMaturityTimestamp, ProposalRejectionReasonProductMaturityIsPassed, ProposalRejectionReasonNoTradingMode, ProposalRejectionReasonUnsupportedTradingMode, ProposalRejectionReasonNodeValidationFailed, ProposalRejectionReasonMissingBuiltinAssetField, ProposalRejectionReasonMissingERC20ContractAddress, ProposalRejectionReasonInvalidAsset, ProposalRejectionReasonIncompatibleTimestamps, ProposalRejectionReasonNoRiskParameters, ProposalRejectionReasonNetworkParameterInvalidKey, ProposalRejectionReasonNetworkParameterInvalidValue, ProposalRejectionReasonNetworkParameterValidationFailed, ProposalRejectionReasonOpeningAuctionDurationTooSmall, ProposalRejectionReasonOpeningAuctionDurationTooLarge, ProposalRejectionReasonMarketMissingLiquidityCommitment, ProposalRejectionReasonCouldNotInstantiateMarket, ProposalRejectionReasonInvalidFutureProduct, ProposalRejectionReasonMissingCommitmentAmount, ProposalRejectionReasonInvalidFeeAmount, ProposalRejectionReasonInvalidShape, ProposalRejectionReasonInvalidRiskParameter, ProposalRejectionReasonMajorityThresholdNotReached, ProposalRejectionReasonParticipationThresholdNotReached, ProposalRejectionReasonInvalidAssetDetails, ProposalRejectionReasonTooManyPriceMonitoringTriggers, ProposalRejectionReasonTooManyMarketDecimalPlaces, ProposalRejectionReasonInvalidMarket, ProposalRejectionReasonInsufficientEquityLikeShare:
		return true
	}
	return false
}

func (e ProposalRejectionReason) String() string {
	return string(e)
}

func (e *ProposalRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalRejectionReason", str)
	}
	return nil
}

func (e ProposalRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Various states a proposal can transition through:
// Open ->
// - Passed -> Enacted.
// - Rejected.
// Proposal can enter Failed state from any other state.
type ProposalState string

const (
	// Proposal became invalid and cannot be processed
	ProposalStateFailed ProposalState = "Failed"
	// Proposal is open for voting
	ProposalStateOpen ProposalState = "Open"
	// Proposal has gained enough support to be executed
	ProposalStatePassed ProposalState = "Passed"
	// Proposal didn't get enough votes
	ProposalStateDeclined ProposalState = "Declined"
	// Proposal could not gain enough support to be executed
	ProposalStateRejected ProposalState = "Rejected"
	// Proposal has been executed and the changes under this proposal have now been applied
	ProposalStateEnacted ProposalState = "Enacted"
	// Proposal is waiting for the node to run validation
	ProposalStateWaitingForNodeVote ProposalState = "WaitingForNodeVote"
)

var AllProposalState = []ProposalState{
	ProposalStateFailed,
	ProposalStateOpen,
	ProposalStatePassed,
	ProposalStateDeclined,
	ProposalStateRejected,
	ProposalStateEnacted,
	ProposalStateWaitingForNodeVote,
}

func (e ProposalState) IsValid() bool {
	switch e {
	case ProposalStateFailed, ProposalStateOpen, ProposalStatePassed, ProposalStateDeclined, ProposalStateRejected, ProposalStateEnacted, ProposalStateWaitingForNodeVote:
		return true
	}
	return false
}

func (e ProposalState) String() string {
	return string(e)
}

func (e *ProposalState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalState", str)
	}
	return nil
}

func (e ProposalState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Various proposal types that are supported by Vega
type ProposalType string

const (
	// Propose a new market
	ProposalTypeNewMarket ProposalType = "NewMarket"
	// Update an existing market
	ProposalTypeUpdateMarket ProposalType = "UpdateMarket"
	// Proposal to change Vega network parameters
	ProposalTypeNetworkParameters ProposalType = "NetworkParameters"
	// Proposal to add a new asset
	ProposalTypeNewAsset ProposalType = "NewAsset"
	// Proposal to update an existing asset
	ProposalTypeUpdateAsset ProposalType = "UpdateAsset"
	// Proposal to create a new freeform proposal
	ProposalTypeNewFreeForm ProposalType = "NewFreeForm"
)

var AllProposalType = []ProposalType{
	ProposalTypeNewMarket,
	ProposalTypeUpdateMarket,
	ProposalTypeNetworkParameters,
	ProposalTypeNewAsset,
	ProposalTypeUpdateAsset,
	ProposalTypeNewFreeForm,
}

func (e ProposalType) IsValid() bool {
	switch e {
	case ProposalTypeNewMarket, ProposalTypeUpdateMarket, ProposalTypeNetworkParameters, ProposalTypeNewAsset, ProposalTypeUpdateAsset, ProposalTypeNewFreeForm:
		return true
	}
	return false
}

func (e ProposalType) String() string {
	return string(e)
}

func (e *ProposalType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalType", str)
	}
	return nil
}

func (e ProposalType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the stake linking
type StakeLinkingStatus string

const (
	// The stake linking is pending in the Vega network. This means that
	// the Vega network have seen a stake linking, but is still to confirm
	// it's valid on the ethereum chain and accepted by all nodes of the network
	StakeLinkingStatusPending StakeLinkingStatus = "Pending"
	// The stake linking has been accepted and processed fully (balance updated) by the network
	StakeLinkingStatusAccepted StakeLinkingStatus = "Accepted"
	// The Vega network has rejected this stake linking
	StakeLinkingStatusRejected StakeLinkingStatus = "Rejected"
)

var AllStakeLinkingStatus = []StakeLinkingStatus{
	StakeLinkingStatusPending,
	StakeLinkingStatusAccepted,
	StakeLinkingStatusRejected,
}

func (e StakeLinkingStatus) IsValid() bool {
	switch e {
	case StakeLinkingStatusPending, StakeLinkingStatusAccepted, StakeLinkingStatusRejected:
		return true
	}
	return false
}

func (e StakeLinkingStatus) String() string {
	return string(e)
}

func (e *StakeLinkingStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakeLinkingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakeLinkingStatus", str)
	}
	return nil
}

func (e StakeLinkingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of stake linking
type StakeLinkingType string

const (
	// The stake is being linked (deposited) to a Vega stake account
	StakeLinkingTypeLink StakeLinkingType = "Link"
	// The stake is being unlinked (removed) from a Vega stake account
	StakeLinkingTypeUnlink StakeLinkingType = "Unlink"
)

var AllStakeLinkingType = []StakeLinkingType{
	StakeLinkingTypeLink,
	StakeLinkingTypeUnlink,
}

func (e StakeLinkingType) IsValid() bool {
	switch e {
	case StakeLinkingTypeLink, StakeLinkingTypeUnlink:
		return true
	}
	return false
}

func (e StakeLinkingType) String() string {
	return string(e)
}

func (e *StakeLinkingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakeLinkingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakeLinkingType", str)
	}
	return nil
}

func (e StakeLinkingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid trade types
type TradeType string

const (
	// Default trade type
	TradeTypeDefault TradeType = "Default"
	// Network close-out - good
	TradeTypeNetworkCloseOutGood TradeType = "NetworkCloseOutGood"
	// Network close-out - bad
	TradeTypeNetworkCloseOutBad TradeType = "NetworkCloseOutBad"
)

var AllTradeType = []TradeType{
	TradeTypeDefault,
	TradeTypeNetworkCloseOutGood,
	TradeTypeNetworkCloseOutBad,
}

func (e TradeType) IsValid() bool {
	switch e {
	case TradeTypeDefault, TradeTypeNetworkCloseOutGood, TradeTypeNetworkCloseOutBad:
		return true
	}
	return false
}

func (e TradeType) String() string {
	return string(e)
}

func (e *TradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeType", str)
	}
	return nil
}

func (e TradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransferDirection string

const (
	TransferDirectionTo       TransferDirection = "To"
	TransferDirectionFrom     TransferDirection = "From"
	TransferDirectionToOrFrom TransferDirection = "ToOrFrom"
)

var AllTransferDirection = []TransferDirection{
	TransferDirectionTo,
	TransferDirectionFrom,
	TransferDirectionToOrFrom,
}

func (e TransferDirection) IsValid() bool {
	switch e {
	case TransferDirectionTo, TransferDirectionFrom, TransferDirectionToOrFrom:
		return true
	}
	return false
}

func (e TransferDirection) String() string {
	return string(e)
}

func (e *TransferDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransferDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransferDirection", str)
	}
	return nil
}

func (e TransferDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteValue string

const (
	// No reject a proposal
	VoteValueNo VoteValue = "No"
	// Yes accept a proposal
	VoteValueYes VoteValue = "Yes"
)

var AllVoteValue = []VoteValue{
	VoteValueNo,
	VoteValueYes,
}

func (e VoteValue) IsValid() bool {
	switch e {
	case VoteValueNo, VoteValueYes:
		return true
	}
	return false
}

func (e VoteValue) String() string {
	return string(e)
}

func (e *VoteValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteValue", str)
	}
	return nil
}

func (e VoteValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a withdrawal
type WithdrawalStatus string

const (
	// The withdrawal is open and being processed by the network
	WithdrawalStatusOpen WithdrawalStatus = "Open"
	// The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	WithdrawalStatusRejected WithdrawalStatus = "Rejected"
	// The withdrawal was finalised, it was valid, the foreign chain has executed it and the network updated all accounts
	WithdrawalStatusFinalized WithdrawalStatus = "Finalized"
)

var AllWithdrawalStatus = []WithdrawalStatus{
	WithdrawalStatusOpen,
	WithdrawalStatusRejected,
	WithdrawalStatusFinalized,
}

func (e WithdrawalStatus) IsValid() bool {
	switch e {
	case WithdrawalStatusOpen, WithdrawalStatusRejected, WithdrawalStatusFinalized:
		return true
	}
	return false
}

func (e WithdrawalStatus) String() string {
	return string(e)
}

func (e *WithdrawalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WithdrawalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WithdrawalStatus", str)
	}
	return nil
}

func (e WithdrawalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
