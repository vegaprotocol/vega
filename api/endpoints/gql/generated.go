// Code generated by github.com/vektah/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	context "context"
	strconv "strconv"
	msg "vega/msg"

	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

// MakeExecutableSchema creates an ExecutableSchema from the Resolvers interface.
func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(resolvers ResolverRoot) graphql.ExecutableSchema {
	return MakeExecutableSchema(shortMapper{r: resolvers})
}

type Resolvers interface {
	Candle_high(ctx context.Context, obj *msg.Candle) (string, error)
	Candle_low(ctx context.Context, obj *msg.Candle) (string, error)
	Candle_open(ctx context.Context, obj *msg.Candle) (string, error)
	Candle_close(ctx context.Context, obj *msg.Candle) (string, error)
	Candle_volume(ctx context.Context, obj *msg.Candle) (string, error)
	Candle_openBlockNumber(ctx context.Context, obj *msg.Candle) (string, error)
	Candle_closeBlockNumber(ctx context.Context, obj *msg.Candle) (string, error)

	Market_orders(ctx context.Context, obj *Market, where *OrderFilter, skip *int, first *int, last *int) ([]msg.Order, error)
	Market_trades(ctx context.Context, obj *Market, where *TradeFilter, skip *int, first *int, last *int) ([]msg.Trade, error)
	Market_depth(ctx context.Context, obj *Market) (msg.MarketDepth, error)
	Market_candles(ctx context.Context, obj *Market, last int, interval int) ([]msg.Candle, error)

	MarketDepth_buy(ctx context.Context, obj *msg.MarketDepth) ([]msg.PriceLevel, error)
	MarketDepth_sell(ctx context.Context, obj *msg.MarketDepth) ([]msg.PriceLevel, error)
	Mutation_orderCreate(ctx context.Context, market string, party string, price string, size string, side Side, type_ OrderType) (PreConsensus, error)
	Mutation_orderCancel(ctx context.Context, id string, market string, party string) (PreConsensus, error)

	Order_price(ctx context.Context, obj *msg.Order) (string, error)
	Order_type(ctx context.Context, obj *msg.Order) (OrderType, error)
	Order_side(ctx context.Context, obj *msg.Order) (Side, error)
	Order_market(ctx context.Context, obj *msg.Order) (Market, error)
	Order_size(ctx context.Context, obj *msg.Order) (string, error)
	Order_remaining(ctx context.Context, obj *msg.Order) (string, error)

	Order_timestamp(ctx context.Context, obj *msg.Order) (string, error)
	Order_status(ctx context.Context, obj *msg.Order) (OrderStatus, error)

	Party_orders(ctx context.Context, obj *Party, where *OrderFilter, skip *int, first *int, last *int) ([]msg.Order, error)
	Party_positions(ctx context.Context, obj *Party) ([]msg.MarketPosition, error)
	Position_market(ctx context.Context, obj *msg.MarketPosition) (Market, error)
	Position_realisedVolume(ctx context.Context, obj *msg.MarketPosition) (string, error)
	Position_realisedProfitValue(ctx context.Context, obj *msg.MarketPosition) (string, error)
	Position_realisedProfitDirection(ctx context.Context, obj *msg.MarketPosition) (ValueDirection, error)
	Position_unrealisedVolume(ctx context.Context, obj *msg.MarketPosition) (string, error)
	Position_unrealisedProfitValue(ctx context.Context, obj *msg.MarketPosition) (string, error)
	Position_unrealisedProfitDirection(ctx context.Context, obj *msg.MarketPosition) (ValueDirection, error)
	Position_averageEntryPrice(ctx context.Context, obj *msg.MarketPosition) (string, error)
	Position_minimumMargin(ctx context.Context, obj *msg.MarketPosition) (string, error)

	PriceLevel_price(ctx context.Context, obj *msg.PriceLevel) (string, error)
	PriceLevel_volume(ctx context.Context, obj *msg.PriceLevel) (string, error)
	PriceLevel_numberOfOrders(ctx context.Context, obj *msg.PriceLevel) (string, error)
	PriceLevel_cumulativeVolume(ctx context.Context, obj *msg.PriceLevel) (string, error)
	Query_vega(ctx context.Context) (Vega, error)

	Subscription_candles(ctx context.Context, market string, interval int) (<-chan msg.Candle, error)
	Subscription_orders(ctx context.Context, market *string, party *string) (<-chan msg.Order, error)
	Subscription_trades(ctx context.Context, market *string, party *string) (<-chan msg.Trade, error)
	Subscription_positions(ctx context.Context, party string) (<-chan msg.MarketPosition, error)
	Subscription_marketDepth(ctx context.Context, market string) (<-chan msg.MarketDepth, error)

	Trade_market(ctx context.Context, obj *msg.Trade) (Market, error)

	Trade_aggressor(ctx context.Context, obj *msg.Trade) (Side, error)
	Trade_price(ctx context.Context, obj *msg.Trade) (string, error)
	Trade_size(ctx context.Context, obj *msg.Trade) (string, error)
	Trade_timestamp(ctx context.Context, obj *msg.Trade) (string, error)
	Vega_markets(ctx context.Context, obj *Vega, name *string) ([]Market, error)
	Vega_parties(ctx context.Context, obj *Vega, name *string) ([]Party, error)
}

type ResolverRoot interface {
	Candle() CandleResolver
	Market() MarketResolver
	MarketDepth() MarketDepthResolver
	Mutation() MutationResolver
	Order() OrderResolver
	Party() PartyResolver
	Position() PositionResolver
	PriceLevel() PriceLevelResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	Trade() TradeResolver
	Vega() VegaResolver
}
type CandleResolver interface {
	High(ctx context.Context, obj *msg.Candle) (string, error)
	Low(ctx context.Context, obj *msg.Candle) (string, error)
	Open(ctx context.Context, obj *msg.Candle) (string, error)
	Close(ctx context.Context, obj *msg.Candle) (string, error)
	Volume(ctx context.Context, obj *msg.Candle) (string, error)
	OpenBlockNumber(ctx context.Context, obj *msg.Candle) (string, error)
	CloseBlockNumber(ctx context.Context, obj *msg.Candle) (string, error)
}
type MarketResolver interface {
	Orders(ctx context.Context, obj *Market, where *OrderFilter, skip *int, first *int, last *int) ([]msg.Order, error)
	Trades(ctx context.Context, obj *Market, where *TradeFilter, skip *int, first *int, last *int) ([]msg.Trade, error)
	Depth(ctx context.Context, obj *Market) (msg.MarketDepth, error)
	Candles(ctx context.Context, obj *Market, last int, interval int) ([]msg.Candle, error)
}
type MarketDepthResolver interface {
	Buy(ctx context.Context, obj *msg.MarketDepth) ([]msg.PriceLevel, error)
	Sell(ctx context.Context, obj *msg.MarketDepth) ([]msg.PriceLevel, error)
}
type MutationResolver interface {
	OrderCreate(ctx context.Context, market string, party string, price string, size string, side Side, type_ OrderType) (PreConsensus, error)
	OrderCancel(ctx context.Context, id string, market string, party string) (PreConsensus, error)
}
type OrderResolver interface {
	Price(ctx context.Context, obj *msg.Order) (string, error)
	Type(ctx context.Context, obj *msg.Order) (OrderType, error)
	Side(ctx context.Context, obj *msg.Order) (Side, error)
	Market(ctx context.Context, obj *msg.Order) (Market, error)
	Size(ctx context.Context, obj *msg.Order) (string, error)
	Remaining(ctx context.Context, obj *msg.Order) (string, error)

	Timestamp(ctx context.Context, obj *msg.Order) (string, error)
	Status(ctx context.Context, obj *msg.Order) (OrderStatus, error)
}
type PartyResolver interface {
	Orders(ctx context.Context, obj *Party, where *OrderFilter, skip *int, first *int, last *int) ([]msg.Order, error)
	Positions(ctx context.Context, obj *Party) ([]msg.MarketPosition, error)
}
type PositionResolver interface {
	Market(ctx context.Context, obj *msg.MarketPosition) (Market, error)
	RealisedVolume(ctx context.Context, obj *msg.MarketPosition) (string, error)
	RealisedProfitValue(ctx context.Context, obj *msg.MarketPosition) (string, error)
	RealisedProfitDirection(ctx context.Context, obj *msg.MarketPosition) (ValueDirection, error)
	UnrealisedVolume(ctx context.Context, obj *msg.MarketPosition) (string, error)
	UnrealisedProfitValue(ctx context.Context, obj *msg.MarketPosition) (string, error)
	UnrealisedProfitDirection(ctx context.Context, obj *msg.MarketPosition) (ValueDirection, error)
	AverageEntryPrice(ctx context.Context, obj *msg.MarketPosition) (string, error)
	MinimumMargin(ctx context.Context, obj *msg.MarketPosition) (string, error)
}
type PriceLevelResolver interface {
	Price(ctx context.Context, obj *msg.PriceLevel) (string, error)
	Volume(ctx context.Context, obj *msg.PriceLevel) (string, error)
	NumberOfOrders(ctx context.Context, obj *msg.PriceLevel) (string, error)
	CumulativeVolume(ctx context.Context, obj *msg.PriceLevel) (string, error)
}
type QueryResolver interface {
	Vega(ctx context.Context) (Vega, error)
}
type SubscriptionResolver interface {
	Candles(ctx context.Context, market string, interval int) (<-chan msg.Candle, error)
	Orders(ctx context.Context, market *string, party *string) (<-chan msg.Order, error)
	Trades(ctx context.Context, market *string, party *string) (<-chan msg.Trade, error)
	Positions(ctx context.Context, party string) (<-chan msg.MarketPosition, error)
	MarketDepth(ctx context.Context, market string) (<-chan msg.MarketDepth, error)
}
type TradeResolver interface {
	Market(ctx context.Context, obj *msg.Trade) (Market, error)

	Aggressor(ctx context.Context, obj *msg.Trade) (Side, error)
	Price(ctx context.Context, obj *msg.Trade) (string, error)
	Size(ctx context.Context, obj *msg.Trade) (string, error)
	Timestamp(ctx context.Context, obj *msg.Trade) (string, error)
}
type VegaResolver interface {
	Markets(ctx context.Context, obj *Vega, name *string) ([]Market, error)
	Parties(ctx context.Context, obj *Vega, name *string) ([]Party, error)
}

type shortMapper struct {
	r ResolverRoot
}

func (s shortMapper) Candle_high(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().High(ctx, obj)
}

func (s shortMapper) Candle_low(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().Low(ctx, obj)
}

func (s shortMapper) Candle_open(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().Open(ctx, obj)
}

func (s shortMapper) Candle_close(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().Close(ctx, obj)
}

func (s shortMapper) Candle_volume(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().Volume(ctx, obj)
}

func (s shortMapper) Candle_openBlockNumber(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().OpenBlockNumber(ctx, obj)
}

func (s shortMapper) Candle_closeBlockNumber(ctx context.Context, obj *msg.Candle) (string, error) {
	return s.r.Candle().CloseBlockNumber(ctx, obj)
}

func (s shortMapper) Market_orders(ctx context.Context, obj *Market, where *OrderFilter, skip *int, first *int, last *int) ([]msg.Order, error) {
	return s.r.Market().Orders(ctx, obj, where, skip, first, last)
}

func (s shortMapper) Market_trades(ctx context.Context, obj *Market, where *TradeFilter, skip *int, first *int, last *int) ([]msg.Trade, error) {
	return s.r.Market().Trades(ctx, obj, where, skip, first, last)
}

func (s shortMapper) Market_depth(ctx context.Context, obj *Market) (msg.MarketDepth, error) {
	return s.r.Market().Depth(ctx, obj)
}

func (s shortMapper) Market_candles(ctx context.Context, obj *Market, last int, interval int) ([]msg.Candle, error) {
	return s.r.Market().Candles(ctx, obj, last, interval)
}

func (s shortMapper) MarketDepth_buy(ctx context.Context, obj *msg.MarketDepth) ([]msg.PriceLevel, error) {
	return s.r.MarketDepth().Buy(ctx, obj)
}

func (s shortMapper) MarketDepth_sell(ctx context.Context, obj *msg.MarketDepth) ([]msg.PriceLevel, error) {
	return s.r.MarketDepth().Sell(ctx, obj)
}

func (s shortMapper) Mutation_orderCreate(ctx context.Context, market string, party string, price string, size string, side Side, type_ OrderType) (PreConsensus, error) {
	return s.r.Mutation().OrderCreate(ctx, market, party, price, size, side, type_)
}

func (s shortMapper) Mutation_orderCancel(ctx context.Context, id string, market string, party string) (PreConsensus, error) {
	return s.r.Mutation().OrderCancel(ctx, id, market, party)
}

func (s shortMapper) Order_price(ctx context.Context, obj *msg.Order) (string, error) {
	return s.r.Order().Price(ctx, obj)
}

func (s shortMapper) Order_type(ctx context.Context, obj *msg.Order) (OrderType, error) {
	return s.r.Order().Type(ctx, obj)
}

func (s shortMapper) Order_side(ctx context.Context, obj *msg.Order) (Side, error) {
	return s.r.Order().Side(ctx, obj)
}

func (s shortMapper) Order_market(ctx context.Context, obj *msg.Order) (Market, error) {
	return s.r.Order().Market(ctx, obj)
}

func (s shortMapper) Order_size(ctx context.Context, obj *msg.Order) (string, error) {
	return s.r.Order().Size(ctx, obj)
}

func (s shortMapper) Order_remaining(ctx context.Context, obj *msg.Order) (string, error) {
	return s.r.Order().Remaining(ctx, obj)
}

func (s shortMapper) Order_timestamp(ctx context.Context, obj *msg.Order) (string, error) {
	return s.r.Order().Timestamp(ctx, obj)
}

func (s shortMapper) Order_status(ctx context.Context, obj *msg.Order) (OrderStatus, error) {
	return s.r.Order().Status(ctx, obj)
}

func (s shortMapper) Party_orders(ctx context.Context, obj *Party, where *OrderFilter, skip *int, first *int, last *int) ([]msg.Order, error) {
	return s.r.Party().Orders(ctx, obj, where, skip, first, last)
}

func (s shortMapper) Party_positions(ctx context.Context, obj *Party) ([]msg.MarketPosition, error) {
	return s.r.Party().Positions(ctx, obj)
}

func (s shortMapper) Position_market(ctx context.Context, obj *msg.MarketPosition) (Market, error) {
	return s.r.Position().Market(ctx, obj)
}

func (s shortMapper) Position_realisedVolume(ctx context.Context, obj *msg.MarketPosition) (string, error) {
	return s.r.Position().RealisedVolume(ctx, obj)
}

func (s shortMapper) Position_realisedProfitValue(ctx context.Context, obj *msg.MarketPosition) (string, error) {
	return s.r.Position().RealisedProfitValue(ctx, obj)
}

func (s shortMapper) Position_realisedProfitDirection(ctx context.Context, obj *msg.MarketPosition) (ValueDirection, error) {
	return s.r.Position().RealisedProfitDirection(ctx, obj)
}

func (s shortMapper) Position_unrealisedVolume(ctx context.Context, obj *msg.MarketPosition) (string, error) {
	return s.r.Position().UnrealisedVolume(ctx, obj)
}

func (s shortMapper) Position_unrealisedProfitValue(ctx context.Context, obj *msg.MarketPosition) (string, error) {
	return s.r.Position().UnrealisedProfitValue(ctx, obj)
}

func (s shortMapper) Position_unrealisedProfitDirection(ctx context.Context, obj *msg.MarketPosition) (ValueDirection, error) {
	return s.r.Position().UnrealisedProfitDirection(ctx, obj)
}

func (s shortMapper) Position_averageEntryPrice(ctx context.Context, obj *msg.MarketPosition) (string, error) {
	return s.r.Position().AverageEntryPrice(ctx, obj)
}

func (s shortMapper) Position_minimumMargin(ctx context.Context, obj *msg.MarketPosition) (string, error) {
	return s.r.Position().MinimumMargin(ctx, obj)
}

func (s shortMapper) PriceLevel_price(ctx context.Context, obj *msg.PriceLevel) (string, error) {
	return s.r.PriceLevel().Price(ctx, obj)
}

func (s shortMapper) PriceLevel_volume(ctx context.Context, obj *msg.PriceLevel) (string, error) {
	return s.r.PriceLevel().Volume(ctx, obj)
}

func (s shortMapper) PriceLevel_numberOfOrders(ctx context.Context, obj *msg.PriceLevel) (string, error) {
	return s.r.PriceLevel().NumberOfOrders(ctx, obj)
}

func (s shortMapper) PriceLevel_cumulativeVolume(ctx context.Context, obj *msg.PriceLevel) (string, error) {
	return s.r.PriceLevel().CumulativeVolume(ctx, obj)
}

func (s shortMapper) Query_vega(ctx context.Context) (Vega, error) {
	return s.r.Query().Vega(ctx)
}

func (s shortMapper) Subscription_candles(ctx context.Context, market string, interval int) (<-chan msg.Candle, error) {
	return s.r.Subscription().Candles(ctx, market, interval)
}

func (s shortMapper) Subscription_orders(ctx context.Context, market *string, party *string) (<-chan msg.Order, error) {
	return s.r.Subscription().Orders(ctx, market, party)
}

func (s shortMapper) Subscription_trades(ctx context.Context, market *string, party *string) (<-chan msg.Trade, error) {
	return s.r.Subscription().Trades(ctx, market, party)
}

func (s shortMapper) Subscription_positions(ctx context.Context, party string) (<-chan msg.MarketPosition, error) {
	return s.r.Subscription().Positions(ctx, party)
}

func (s shortMapper) Subscription_marketDepth(ctx context.Context, market string) (<-chan msg.MarketDepth, error) {
	return s.r.Subscription().MarketDepth(ctx, market)
}

func (s shortMapper) Trade_market(ctx context.Context, obj *msg.Trade) (Market, error) {
	return s.r.Trade().Market(ctx, obj)
}

func (s shortMapper) Trade_aggressor(ctx context.Context, obj *msg.Trade) (Side, error) {
	return s.r.Trade().Aggressor(ctx, obj)
}

func (s shortMapper) Trade_price(ctx context.Context, obj *msg.Trade) (string, error) {
	return s.r.Trade().Price(ctx, obj)
}

func (s shortMapper) Trade_size(ctx context.Context, obj *msg.Trade) (string, error) {
	return s.r.Trade().Size(ctx, obj)
}

func (s shortMapper) Trade_timestamp(ctx context.Context, obj *msg.Trade) (string, error) {
	return s.r.Trade().Timestamp(ctx, obj)
}

func (s shortMapper) Vega_markets(ctx context.Context, obj *Vega, name *string) ([]Market, error) {
	return s.r.Vega().Markets(ctx, obj, name)
}

func (s shortMapper) Vega_parties(ctx context.Context, obj *Vega, name *string) ([]Party, error) {
	return s.r.Vega().Parties(ctx, obj, name)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	next := ec._Subscription(ctx, op.Selections)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		return &graphql.Response{
			Data:   buf,
			Errors: ec.Errors,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var candleImplementors = []string{"Candle"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Candle(ctx context.Context, sel []query.Selection, obj *msg.Candle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, candleImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Candle")
		case "date":
			out.Values[i] = ec._Candle_date(ctx, field, obj)
		case "high":
			out.Values[i] = ec._Candle_high(ctx, field, obj)
		case "low":
			out.Values[i] = ec._Candle_low(ctx, field, obj)
		case "open":
			out.Values[i] = ec._Candle_open(ctx, field, obj)
		case "close":
			out.Values[i] = ec._Candle_close(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._Candle_volume(ctx, field, obj)
		case "openBlockNumber":
			out.Values[i] = ec._Candle_openBlockNumber(ctx, field, obj)
		case "closeBlockNumber":
			out.Values[i] = ec._Candle_closeBlockNumber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Candle_date(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Candle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Date
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Candle_high(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_high(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Candle_low(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_low(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Candle_open(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_open(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Candle_close(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_close(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Candle_volume(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_volume(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Candle_openBlockNumber(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_openBlockNumber(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Candle_closeBlockNumber(ctx context.Context, field graphql.CollectedField, obj *msg.Candle) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Candle",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Candle_closeBlockNumber(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

var marketImplementors = []string{"Market"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Market(ctx context.Context, sel []query.Selection, obj *Market) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, marketImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Market")
		case "name":
			out.Values[i] = ec._Market_name(ctx, field, obj)
		case "orders":
			out.Values[i] = ec._Market_orders(ctx, field, obj)
		case "trades":
			out.Values[i] = ec._Market_trades(ctx, field, obj)
		case "depth":
			out.Values[i] = ec._Market_depth(ctx, field, obj)
		case "candles":
			out.Values[i] = ec._Market_candles(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Market_name(ctx context.Context, field graphql.CollectedField, obj *Market) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Market"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Market_orders(ctx context.Context, field graphql.CollectedField, obj *Market) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *OrderFilter
	if tmp, ok := field.Args["where"]; ok {
		var err error
		var ptr1 OrderFilter
		if tmp != nil {
			ptr1, err = UnmarshalOrderFilter(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["where"] = arg0
	var arg1 *int
	if tmp, ok := field.Args["skip"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["skip"] = arg1
	var arg2 *int
	if tmp, ok := field.Args["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Market",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Market_orders(ctx, obj, args["where"].(*OrderFilter), args["skip"].(*int), args["first"].(*int), args["last"].(*int))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.Order)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Order(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Market_trades(ctx context.Context, field graphql.CollectedField, obj *Market) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *TradeFilter
	if tmp, ok := field.Args["where"]; ok {
		var err error
		var ptr1 TradeFilter
		if tmp != nil {
			ptr1, err = UnmarshalTradeFilter(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["where"] = arg0
	var arg1 *int
	if tmp, ok := field.Args["skip"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["skip"] = arg1
	var arg2 *int
	if tmp, ok := field.Args["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Market",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Market_trades(ctx, obj, args["where"].(*TradeFilter), args["skip"].(*int), args["first"].(*int), args["last"].(*int))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.Trade)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Trade(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Market_depth(ctx context.Context, field graphql.CollectedField, obj *Market) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Market",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Market_depth(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(msg.MarketDepth)
		return ec._MarketDepth(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Market_candles(ctx context.Context, field graphql.CollectedField, obj *Market) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		arg0, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg0
	var arg1 int
	if tmp, ok := field.Args["interval"]; ok {
		var err error
		arg1, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["interval"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Market",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Market_candles(ctx, obj, args["last"].(int), args["interval"].(int))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.Candle)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Candle(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

var marketDepthImplementors = []string{"MarketDepth"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MarketDepth(ctx context.Context, sel []query.Selection, obj *msg.MarketDepth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, marketDepthImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketDepth")
		case "name":
			out.Values[i] = ec._MarketDepth_name(ctx, field, obj)
		case "buy":
			out.Values[i] = ec._MarketDepth_buy(ctx, field, obj)
		case "sell":
			out.Values[i] = ec._MarketDepth_sell(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _MarketDepth_name(ctx context.Context, field graphql.CollectedField, obj *msg.MarketDepth) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "MarketDepth"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _MarketDepth_buy(ctx context.Context, field graphql.CollectedField, obj *msg.MarketDepth) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "MarketDepth",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.MarketDepth_buy(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.PriceLevel)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._PriceLevel(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _MarketDepth_sell(ctx context.Context, field graphql.CollectedField, obj *msg.MarketDepth) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "MarketDepth",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.MarketDepth_sell(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.PriceLevel)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._PriceLevel(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, mutationImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "orderCreate":
			out.Values[i] = ec._Mutation_orderCreate(ctx, field)
		case "orderCancel":
			out.Values[i] = ec._Mutation_orderCancel(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_orderCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["market"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["market"] = arg0
	var arg1 string
	if tmp, ok := field.Args["party"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["party"] = arg1
	var arg2 string
	if tmp, ok := field.Args["price"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["price"] = arg2
	var arg3 string
	if tmp, ok := field.Args["size"]; ok {
		var err error
		arg3, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["size"] = arg3
	var arg4 Side
	if tmp, ok := field.Args["side"]; ok {
		var err error
		err = (&arg4).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["side"] = arg4
	var arg5 OrderType
	if tmp, ok := field.Args["type"]; ok {
		var err error
		err = (&arg5).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["type"] = arg5
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_orderCreate(ctx, args["market"].(string), args["party"].(string), args["price"].(string), args["size"].(string), args["side"].(Side), args["type"].(OrderType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(PreConsensus)
	return ec._PreConsensus(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_orderCancel(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := field.Args["market"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["market"] = arg1
	var arg2 string
	if tmp, ok := field.Args["party"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["party"] = arg2
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_orderCancel(ctx, args["id"].(string), args["market"].(string), args["party"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(PreConsensus)
	return ec._PreConsensus(ctx, field.Selections, &res)
}

var orderImplementors = []string{"Order"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Order(ctx context.Context, sel []query.Selection, obj *msg.Order) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, orderImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Order")
		case "id":
			out.Values[i] = ec._Order_id(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Order_price(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Order_type(ctx, field, obj)
		case "side":
			out.Values[i] = ec._Order_side(ctx, field, obj)
		case "market":
			out.Values[i] = ec._Order_market(ctx, field, obj)
		case "size":
			out.Values[i] = ec._Order_size(ctx, field, obj)
		case "remaining":
			out.Values[i] = ec._Order_remaining(ctx, field, obj)
		case "party":
			out.Values[i] = ec._Order_party(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._Order_timestamp(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Order_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Order_id(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Order"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Id
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Order_price(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_price(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Order_type(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_type(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(OrderType)
		return res
	})
}

func (ec *executionContext) _Order_side(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_side(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Side)
		return res
	})
}

func (ec *executionContext) _Order_market(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_market(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Market)
		return ec._Market(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Order_size(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_size(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Order_remaining(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_remaining(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Order_party(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Order"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Party
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Order_timestamp(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_timestamp(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Order_status(ctx context.Context, field graphql.CollectedField, obj *msg.Order) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Order_status(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(OrderStatus)
		return res
	})
}

var partyImplementors = []string{"Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Party(ctx context.Context, sel []query.Selection, obj *Party) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, partyImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Party")
		case "name":
			out.Values[i] = ec._Party_name(ctx, field, obj)
		case "orders":
			out.Values[i] = ec._Party_orders(ctx, field, obj)
		case "positions":
			out.Values[i] = ec._Party_positions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Party_name(ctx context.Context, field graphql.CollectedField, obj *Party) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Party"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Party_orders(ctx context.Context, field graphql.CollectedField, obj *Party) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *OrderFilter
	if tmp, ok := field.Args["where"]; ok {
		var err error
		var ptr1 OrderFilter
		if tmp != nil {
			ptr1, err = UnmarshalOrderFilter(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["where"] = arg0
	var arg1 *int
	if tmp, ok := field.Args["skip"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["skip"] = arg1
	var arg2 *int
	if tmp, ok := field.Args["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Party",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Party_orders(ctx, obj, args["where"].(*OrderFilter), args["skip"].(*int), args["first"].(*int), args["last"].(*int))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.Order)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Order(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Party_positions(ctx context.Context, field graphql.CollectedField, obj *Party) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Party",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Party_positions(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]msg.MarketPosition)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Position(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

var positionImplementors = []string{"Position"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Position(ctx context.Context, sel []query.Selection, obj *msg.MarketPosition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, positionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Position")
		case "market":
			out.Values[i] = ec._Position_market(ctx, field, obj)
		case "realisedVolume":
			out.Values[i] = ec._Position_realisedVolume(ctx, field, obj)
		case "realisedProfitValue":
			out.Values[i] = ec._Position_realisedProfitValue(ctx, field, obj)
		case "realisedProfitDirection":
			out.Values[i] = ec._Position_realisedProfitDirection(ctx, field, obj)
		case "unrealisedVolume":
			out.Values[i] = ec._Position_unrealisedVolume(ctx, field, obj)
		case "unrealisedProfitValue":
			out.Values[i] = ec._Position_unrealisedProfitValue(ctx, field, obj)
		case "unrealisedProfitDirection":
			out.Values[i] = ec._Position_unrealisedProfitDirection(ctx, field, obj)
		case "averageEntryPrice":
			out.Values[i] = ec._Position_averageEntryPrice(ctx, field, obj)
		case "minimumMargin":
			out.Values[i] = ec._Position_minimumMargin(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Position_market(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_market(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Market)
		return ec._Market(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Position_realisedVolume(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_realisedVolume(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Position_realisedProfitValue(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_realisedProfitValue(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Position_realisedProfitDirection(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_realisedProfitDirection(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(ValueDirection)
		return res
	})
}

func (ec *executionContext) _Position_unrealisedVolume(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_unrealisedVolume(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Position_unrealisedProfitValue(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_unrealisedProfitValue(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Position_unrealisedProfitDirection(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_unrealisedProfitDirection(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(ValueDirection)
		return res
	})
}

func (ec *executionContext) _Position_averageEntryPrice(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_averageEntryPrice(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Position_minimumMargin(ctx context.Context, field graphql.CollectedField, obj *msg.MarketPosition) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Position",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Position_minimumMargin(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

var preConsensusImplementors = []string{"PreConsensus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PreConsensus(ctx context.Context, sel []query.Selection, obj *PreConsensus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, preConsensusImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreConsensus")
		case "accepted":
			out.Values[i] = ec._PreConsensus_accepted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _PreConsensus_accepted(ctx context.Context, field graphql.CollectedField, obj *PreConsensus) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PreConsensus"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Accepted
	return graphql.MarshalBoolean(res)
}

var priceLevelImplementors = []string{"PriceLevel"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PriceLevel(ctx context.Context, sel []query.Selection, obj *msg.PriceLevel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, priceLevelImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PriceLevel")
		case "price":
			out.Values[i] = ec._PriceLevel_price(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._PriceLevel_volume(ctx, field, obj)
		case "numberOfOrders":
			out.Values[i] = ec._PriceLevel_numberOfOrders(ctx, field, obj)
		case "cumulativeVolume":
			out.Values[i] = ec._PriceLevel_cumulativeVolume(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _PriceLevel_price(ctx context.Context, field graphql.CollectedField, obj *msg.PriceLevel) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "PriceLevel",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.PriceLevel_price(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _PriceLevel_volume(ctx context.Context, field graphql.CollectedField, obj *msg.PriceLevel) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "PriceLevel",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.PriceLevel_volume(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _PriceLevel_numberOfOrders(ctx context.Context, field graphql.CollectedField, obj *msg.PriceLevel) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "PriceLevel",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.PriceLevel_numberOfOrders(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _PriceLevel_cumulativeVolume(ctx context.Context, field graphql.CollectedField, obj *msg.PriceLevel) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "PriceLevel",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.PriceLevel_cumulativeVolume(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "vega":
			out.Values[i] = ec._Query_vega(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_vega(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_vega(ctx)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Vega)
		return ec._Vega(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var subscriptionImplementors = []string{"Subscription"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscription(ctx context.Context, sel []query.Selection) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, subscriptionImplementors, ec.Variables)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "candles":
		return ec._Subscription_candles(ctx, fields[0])
	case "orders":
		return ec._Subscription_orders(ctx, fields[0])
	case "trades":
		return ec._Subscription_trades(ctx, fields[0])
	case "positions":
		return ec._Subscription_positions(ctx, fields[0])
	case "marketDepth":
		return ec._Subscription_marketDepth(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

func (ec *executionContext) _Subscription_candles(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["market"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["market"] = arg0
	var arg1 int
	if tmp, ok := field.Args["interval"]; ok {
		var err error
		arg1, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["interval"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{Field: field})
	results, err := ec.resolvers.Subscription_candles(ctx, args["market"].(string), args["interval"].(int))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler { return ec._Candle(ctx, field.Selections, &res) }())
		return &out
	}
}

func (ec *executionContext) _Subscription_orders(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["market"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["market"] = arg0
	var arg1 *string
	if tmp, ok := field.Args["party"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["party"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{Field: field})
	results, err := ec.resolvers.Subscription_orders(ctx, args["market"].(*string), args["party"].(*string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler { return ec._Order(ctx, field.Selections, &res) }())
		return &out
	}
}

func (ec *executionContext) _Subscription_trades(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["market"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["market"] = arg0
	var arg1 *string
	if tmp, ok := field.Args["party"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["party"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{Field: field})
	results, err := ec.resolvers.Subscription_trades(ctx, args["market"].(*string), args["party"].(*string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler { return ec._Trade(ctx, field.Selections, &res) }())
		return &out
	}
}

func (ec *executionContext) _Subscription_positions(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["party"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["party"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{Field: field})
	results, err := ec.resolvers.Subscription_positions(ctx, args["party"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler { return ec._Position(ctx, field.Selections, &res) }())
		return &out
	}
}

func (ec *executionContext) _Subscription_marketDepth(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["market"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return nil
		}
	}
	args["market"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{Field: field})
	results, err := ec.resolvers.Subscription_marketDepth(ctx, args["market"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler { return ec._MarketDepth(ctx, field.Selections, &res) }())
		return &out
	}
}

var tradeImplementors = []string{"Trade"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Trade(ctx context.Context, sel []query.Selection, obj *msg.Trade) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, tradeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trade")
		case "id":
			out.Values[i] = ec._Trade_id(ctx, field, obj)
		case "market":
			out.Values[i] = ec._Trade_market(ctx, field, obj)
		case "buyer":
			out.Values[i] = ec._Trade_buyer(ctx, field, obj)
		case "seller":
			out.Values[i] = ec._Trade_seller(ctx, field, obj)
		case "aggressor":
			out.Values[i] = ec._Trade_aggressor(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Trade_price(ctx, field, obj)
		case "size":
			out.Values[i] = ec._Trade_size(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._Trade_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Trade_id(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Trade"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Id
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Trade_market(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Trade",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Trade_market(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Market)
		return ec._Market(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Trade_buyer(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Trade"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Buyer
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Trade_seller(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Trade"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Seller
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Trade_aggressor(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Trade",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Trade_aggressor(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(Side)
		return res
	})
}

func (ec *executionContext) _Trade_price(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Trade",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Trade_price(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Trade_size(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Trade",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Trade_size(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

func (ec *executionContext) _Trade_timestamp(ctx context.Context, field graphql.CollectedField, obj *msg.Trade) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Trade",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Trade_timestamp(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(string)
		return graphql.MarshalString(res)
	})
}

var vegaImplementors = []string{"Vega"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Vega(ctx context.Context, sel []query.Selection, obj *Vega) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, vegaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Vega")
		case "markets":
			out.Values[i] = ec._Vega_markets(ctx, field, obj)
		case "parties":
			out.Values[i] = ec._Vega_parties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Vega_markets(ctx context.Context, field graphql.CollectedField, obj *Vega) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Vega",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Vega_markets(ctx, obj, args["name"].(*string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]Market)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Market(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Vega_parties(ctx context.Context, field graphql.CollectedField, obj *Vega) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Vega",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Vega_parties(ctx, obj, args["name"].(*string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]Party)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Party(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func UnmarshalOrderFilter(v interface{}) (OrderFilter, error) {
	var it OrderFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "AND":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.AND = make([]OrderFilter, len(rawIf1))
			for idx1 := range rawIf1 {
				it.AND[idx1], err = UnmarshalOrderFilter(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.OR = make([]OrderFilter, len(rawIf1))
			for idx1 := range rawIf1 {
				it.OR[idx1], err = UnmarshalOrderFilter(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "open":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.Open = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.ID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.Id_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "market":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Market = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "market_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Market_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "party":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Party = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "party_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Party_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "side":
			var err error
			var ptr1 Side
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Side = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "side_neq":
			var err error
			var ptr1 Side
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Side_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "remaining":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Remaining = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "remaining_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Remaining_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "remaining_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Remaining_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "remaining_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Remaining_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "type":
			var err error
			var ptr1 OrderType
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Type = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "type_neq":
			var err error
			var ptr1 OrderType
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Type_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "status":
			var err error
			var ptr1 OrderStatus
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Status = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "status_neq":
			var err error
			var ptr1 OrderStatus
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Status_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalTradeFilter(v interface{}) (TradeFilter, error) {
	var it TradeFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "AND":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.AND = make([]TradeFilter, len(rawIf1))
			for idx1 := range rawIf1 {
				it.AND[idx1], err = UnmarshalTradeFilter(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.OR = make([]TradeFilter, len(rawIf1))
			for idx1 := range rawIf1 {
				it.OR[idx1], err = UnmarshalTradeFilter(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.ID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "id_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.Id_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "market":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Market = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "market_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Market_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "buyer":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Buyer = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "buyer_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Buyer_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "seller":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Seller = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "seller_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Seller_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "aggressor":
			var err error
			var ptr1 Side
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Aggressor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "aggressor_neq":
			var err error
			var ptr1 Side
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Aggressor_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "price_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Price_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "size_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Size_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp_neq":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp_neq = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp_from":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp_from = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timestamp_to":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Timestamp_to = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`## GQL - TODO
###############
# Trades subscription
# Orders subscription
#   >>> open orders filter (future?)
# Candles subscription
# Positions subscription
# Depth subscription


# Represents a date/time
scalar DateTime

schema {
    query: Query,
    subscription: Subscription,
    mutation: Mutation
}

# Mutations are similar to GraphQL queries, however they allow a caller to change or mutate data.
type Mutation {
    
    # Send a create order request into VEGA network, this does not immediately create the order.
    # It validates and sends the request out for consensus. Price and Size will be converted to uint64 internally.
    orderCreate(market: String!, party: String!, price: String!, size: String!, side: Side!, type: OrderType!): PreConsensus!

    # Send a cancel order request into VEGA network, this does not immediately cancel an order.
    # It validates and sends the request out for consensus.
    orderCancel(id: ID!, market: String!, party: String!): PreConsensus!
}

# Queries allow a caller to read data and filter data via GraphQL.
type Query {
    # Int64 not yet supported, strings are returned and will need to be handled by clients:
    # https://github.com/graphql-go/graphql/issues/257
    
    # VEGA root query
    vega: Vega!
}

# Subscriptions allow a caller to receive new information as it is available from the VEGA platform.
type Subscription {
    candles(market: String!, interval: Int!): Candle!
    orders(market: String, party: String): Order!
    trades(market: String, party: String): Trade!
    positions(party: String!): Position!
    marketDepth(market: String!): MarketDepth!
}

# An operation that is run before passing on to consensus, e.g. cancelling an order, will report whether it was accepted.
type PreConsensus {

    # If true then the operation was validated and passed on for consensus with other nodes on the VEGA platform.
    accepted: Boolean!
}

# VEGA the world's premier distributed derivatives trading platform
type Vega {
    
    # An instrument that is trading on the VEGA network
    markets(name: String): [Market!]

    # An entity that is trading on the VEGA network
    parties(name: String): [Party!]
}

# Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market {
    
    # Market full name
    name: String!

    # Orders on a market
    orders (where: OrderFilter, skip: Int, first: Int, last: Int): [Order!]

    # Trades on a market
    trades (where: TradeFilter, skip: Int, first: Int, last: Int): [Trade!]

    # Current depth on the orderbook for this market
    depth: MarketDepth!

    # Candles on a market
    candles (last: Int!, interval: Int!): [Candle!]
}

# Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
# The depth of market measure provides an indication of the liquidity and depth for the instrument.
type MarketDepth {

    # Market name
    name: String!

    # Buy side price levels if available
    buy: [PriceLevel!]
    
    # Sell side price levels (if available)
    sell: [PriceLevel!]
}


# Represents a price on either the buy or sell side and all the orders at that price
type PriceLevel {

    # The price of all the orders at this level (uint64)
    price: String!

    # The total remaining size of all orders at this level (uint64)
    volume: String!

    # The number of orders at this price level (uint64)
    numberOfOrders: String!

    # The cumulative total volume to this price level (uint64)
    cumulativeVolume: String!
}

# Candle stick representation of trading
type Candle {

    # The date and time for the candlestick
    date: DateTime!

    # High price (uint64)
    high: String!

    # Low price (uint64)
    low: String!

    # Open price (uint64)
    open: String!

    # Close price (uint64)
    close: String!

    # Volume price (uint64)
    volume: String!

    # The block number of the opening trade (uint64)
    openBlockNumber: String!

    # The block number of the closing trade (uint64)
    closeBlockNumber: String!
}

# Represents a party on Vega, could be an ethereum wallet address in the future
type Party {
    # Party identifier
    name: String!

    # Orders relating to a party
    orders(where: OrderFilter, skip: Int, first: Int, last: Int): [Order!]

    # Trading positions relating to a party
    positions: [Position!]
}


# An individual trader at any point in time is considered net long or net short.
# This refers to their Open Volume, calculated using FIFO. This volume should now be signed as either
# negative for LONG positions and positive for SHORT positions. A single trade may end up "splitting" with some
# of its volume matched into closed volume and some of its volume remaining as open volume. This is why we don't
# refer to positions being comprised of trades, rather of volume.
type Position {

    # Market relating to this position
    market: Market!

    # Realised volume (uint64)
    realisedVolume: String!

    # Realised Profit and Loss (int64, will be converted to uint64 with +ve/-ve indicator in future)
    realisedProfitValue: String!

    # Realised Profit or Loss direction
    realisedProfitDirection: ValueDirection!

    # Unrealised volume (uint64)
    unrealisedVolume: String!

    # Unrealised Profit and Loss  (int64, will be converted to uint64 with +ve/-ve indicator in future)
    unrealisedProfitValue: String!

    # Unrealised Profit or Loss direction
    unrealisedProfitDirection: ValueDirection!

    # Average entry price for this position
    averageEntryPrice: String!

    # Minimum margin for this position
    minimumMargin: String!
}


# An order in Vega, if active it will be on the OrderBoook for the market
type Order {

    # Hash of the order data
    id: ID!

    # The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)
    price: String!

    # The type of order (determines how and if it executes, and whether it persists on the book)
    type: OrderType!

    # Whether the order is to buy or sell
    side: Side!

    # The market the order is trading on (probably stored internally as a hash of the market details)
    market: Market!

    # Total number of contracts that may be bought or sold (immutable) (uint64)
    size: String!

    # Number of contracts remaining of the total that have not yet been bought or sold (uint64)
    remaining: String!

    # The trader who place the order (probably stored internally as the trader's public key)
    party: String!

    # If the order was added to the book or uncrossed at any point, the timestamp when that was done
    timestamp: String!

    # The status of an order, for example 'Active'
    status: OrderStatus!
}


# A trade on Vega, the result of two orders being "matched" in the market
type Trade {

    # The hash of the trade data
    id: ID!

    # The market the trade occurred on
    market: Market!

    # The order that bought
    buyer: String!

    # The order that sold
    seller: String!

    # The aggressor indicates whether this trade was related to a BUY or SELL
    aggressor: Side!

    # The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)
    price: String!

    # The number of contracts trades, will always be <= the remaining size of both orders immediately before the trade (uint64)
    size: String!

    # When the trade occured, probably the timestamp of the agressive order
    timestamp: String!
}

# Valid order types, these determine what happens when an order is added to the book
enum OrderType {

    # The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
    FOK,

    # The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
    ENE,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
    GTC,

    # This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
    # NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
    GTT,
}

# Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
enum OrderStatus {

    # The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
    # Active does not necessarily mean it's still on the order book.
    Active,

    # The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
    Cancelled,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
    Expired,
}

# Whether the placer of an order is aiming to buy or sell on the market
enum Side {
    Buy
    Sell
}

# Whether the position etc value is in profit (positive) or loss (negative).
enum ValueDirection {
    Positive
    Negative
}

# Filters for Trade queries on VEGA graphql, typically specified by WHERE clause
input TradeFilter {
    # logical operators
    AND: [TradeFilter!] # combines all passed ` + "`" + `TradeFilter` + "`" + ` objects with logical AND
    OR: [TradeFilter!] # combines all passed ` + "`" + `TradeFilter` + "`" + ` objects with logical OR

    # ID filters
    id: ID # matches all trades with exact ID value
    id_neq: ID # matches all trades with different ID to value

    # Market filters
    market: String # matches all trades with exact market value
    market_neq: String # matches all trades with different market to value
    
    # Buyer filters
    buyer: String # matches all trades with exact buyer value
    buyer_neq: String # matches all trades with different buyer to value

    # Buyer filters
    seller: String # matches all trades with exact seller value
    seller_neq: String # matches all trades with different seller to value

    # Aggressor filters
    aggressor: Side # matches all trades with exact aggressor value e.g. Buy
    aggressor_neq: Side # matches all trades with different aggressor to value

    # Price filters
    price: String # matches all trades with exact price value
    price_neq: String # matches all trades with different price to value
    price_from: String # matches all trades from this price value
    price_to: String # matches all trades to this price value

    # Size filters
    size: String # matches all trades with exact size value
    size_neq: String # matches all trades with different size to value
    size_from: String # matches all trades from this size value
    size_to: String # matches all trades to this size value

    # TimeStamp filters
    timestamp: String # matches all trades with exact timestamp value
    timestamp_neq: String # matches all trades with different timestamp to value
    timestamp_from: String # matches all trades from this timestamp value
    timestamp_to: String # matches all trades to this timestamp value
}

# Filters for Order queries on VEGA graphql, typically specified by WHERE clause
input OrderFilter {
    # logical operators
    AND: [OrderFilter!] # combines all passed ` + "`" + `OrderFilter` + "`" + ` objects with logical AND
    OR: [OrderFilter!] # combines all passed ` + "`" + `OrderFilter` + "`" + ` objects with logical OR

    # Open only filter
    open: Boolean # Include only open orders in results (default: False)

    # ID filters
    id: ID # matches all orders with exact ID value
    id_neq: ID # matches all orders with different ID to value

    # Market filters
    market: String # matches all orders with exact market value
    market_neq: String # matches all orders with different market to value

    # Party filters
    party: String # matches all orders with exact party value
    party_neq: String # matches all orders with different party to value

    # Side filters
    side: Side # matches all orders with exact side value e.g. Buy
    side_neq: Side # matches all orders with different side to value

    # Price filters
    price: String # matches all orders with exact price value
    price_neq: String # matches all orders with different price to value
    price_from: String # matches all orders from this price value
    price_to: String # matches all orders to this price value

    # Size filters
    size: String # matches all orders with exact size value
    size_neq: String # matches all orders with different size to value
    size_from: String # matches all orders from this size value
    size_to: String # matches all orders to this size value

    # Remaining filters
    remaining: String # matches all orders with exact remaining value
    remaining_neq: String # matches all orders with different remaining to value
    remaining_from: String # matches all orders from this remaining value
    remaining_to: String # matches all orders to this remaining value

    # Type filters
    type: OrderType # matches all orders with exact type value
    type_neq: OrderType # matches all orders with different type to value
    
    # Timestamp filters
    timestamp: String # matches all orders with exact timestamp value
    timestamp_neq: String # matches all orders with different timestamp to value
    timestamp_from: String # matches all orders from this timestamp value
    timestamp_to: String # matches all orders to this timestamp value

    # Status filters
    status: OrderStatus # matches all orders with exact status value
    status_neq: OrderStatus # matches all orders with different status to value
}`)
