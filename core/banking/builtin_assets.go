// Copyright (C) 2023 Gobalsky Labs Limited
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package banking

import (
	"context"
	"encoding/binary"
	"encoding/hex"
	"sync/atomic"

	"code.vegaprotocol.io/vega/core/events"
	"code.vegaprotocol.io/vega/core/types"
	vgcrypto "code.vegaprotocol.io/vega/libs/crypto"
	"code.vegaprotocol.io/vega/libs/num"
	"code.vegaprotocol.io/vega/logging"
)

func (e *Engine) WithdrawBuiltinAsset(
	ctx context.Context, id, party, assetID string, amount *num.Uint,
) error {
	// build the withdrawal type
	w, ref := e.newWithdrawal(id, party, assetID, amount, nil)
	w.Status = types.WithdrawalStatusRejected // default
	e.withdrawals[w.ID] = withdrawalRef{w, ref}

	asset, err := e.assets.Get(assetID)
	if err != nil {
		e.broker.Send(events.NewWithdrawalEvent(ctx, *w))
		e.log.Error("unable to get asset by id",
			logging.AssetID(assetID),
			logging.Error(err))
		return err
	}

	if !asset.IsBuiltinAsset() {
		e.broker.Send(events.NewWithdrawalEvent(ctx, *w))
		return ErrWrongAssetTypeUsedInBuiltinAssetChainEvent
	}

	return e.finalizeWithdraw(ctx, w)
}

func (e *Engine) DepositBuiltinAsset(
	ctx context.Context, d *types.BuiltinAssetDeposit, id string, nonce uint64,
) error {
	dep := e.newDeposit(id, d.PartyID, d.VegaAssetID, d.Amount, "") // no hash
	e.broker.Send(events.NewDepositEvent(ctx, *dep))
	asset, err := e.assets.Get(d.VegaAssetID)
	if err != nil {
		dep.Status = types.DepositStatusCancelled
		e.broker.Send(events.NewDepositEvent(ctx, *dep))
		e.log.Error("unable to get asset by id",
			logging.AssetID(d.VegaAssetID),
			logging.Error(err))
		return err
	}
	if !asset.IsBuiltinAsset() {
		dep.Status = types.DepositStatusCancelled
		e.broker.Send(events.NewDepositEvent(ctx, *dep))
		return ErrWrongAssetTypeUsedInBuiltinAssetChainEvent
	}

	// create a pretend "hash" from the nonce (which is randomly generated by the faucet)
	// ready for calls to getRef()
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, nonce)

	state := &atomic.Uint32{}
	state.Store(pendingState)

	aa := &assetAction{
		id:       dep.ID,
		state:    state,
		builtinD: d,
		asset:    asset,
		txHash:   hex.EncodeToString(vgcrypto.Hash(b)),
	}
	e.assetActions[aa.id] = aa
	e.deposits[dep.ID] = dep
	return e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))
}

func (e *Engine) EnableBuiltinAsset(ctx context.Context, assetID string) error {
	return e.finalizeAssetList(ctx, assetID)
}
