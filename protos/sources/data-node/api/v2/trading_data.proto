syntax = "proto3";

package datanode.api.v2;

import "google/api/field_behavior.proto";
import "google/api/httpbody.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "vega/assets.proto";
import "vega/commands/v1/validator_commands.proto";
import "vega/events/v1/events.proto";
import "vega/governance.proto";
import "vega/markets.proto";
import "vega/oracle.proto";
import "vega/vega.proto";

option go_package = "code.vegaprotocol.io/vega/protos/data-node/api/v2";
option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "Vega data node APIs";
    version: "v0.77.7";
  }
  schemes: [
    HTTP,
    HTTPS
  ];
  host: "https://api.testnet.vega.xyz";
  consumes: "application/json";
  responses: {// can add more keys here to specify common errors between all endpoints, can also be overwritten per rpc call
    key: "500";
    value: {
      description: "An internal server error";
      schema: {
        json_schema: {ref: ".google.rpc.Status"}
      }
    }
  }
};

service TradingDataService {
  // List accounts
  //
  // Get a list of accounts matching the supplied filter, including their current balances.
  // If a given account has never had a balance, it will be absent from the list.
  rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Accounts"};
  }

  // Accounts subscription
  //
  // Subscribe to a stream of accounts
  rpc ObserveAccounts(ObserveAccountsRequest) returns (stream ObserveAccountsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Accounts"};
  }

  // Data node information
  //
  // Get information about the data node.
  // Response contains a semver formatted version of the data node and the commit hash, from which the data node was built
  rpc Info(InfoRequest) returns (InfoResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Node information"};
  }

  // Get order
  //
  // Get an order by its ID. An order's ID will be the SHA3-256 hash of the signature that the order was submitted with
  rpc GetOrder(GetOrderRequest) returns (GetOrderResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // List orders
  //
  // Get a list of orders that match the given filters
  rpc ListOrders(ListOrdersRequest) returns (ListOrdersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // List order versions
  //
  // Get a list of all versions of an order in the order history
  rpc ListOrderVersions(ListOrderVersionsRequest) returns (ListOrderVersionsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // Observe orders
  //
  // Subscribe to a stream of orders
  rpc ObserveOrders(ObserveOrdersRequest) returns (stream ObserveOrdersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // Get stop order
  //
  // Get a stop order by its ID. A stop order's ID will be the SHA3-256 hash of the signature that the order was submitted with.
  // A stop order's ID is likely to be different from the ID of the order that will be submitted when the stop is triggered.
  rpc GetStopOrder(GetStopOrderRequest) returns (GetStopOrderResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // List stop orders
  //
  // Get a list of stop orders that match the given filters
  rpc ListStopOrders(ListStopOrdersRequest) returns (ListStopOrdersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // List game team scores
  //
  // Get a list of team scores for the given filters
  rpc ListGameTeamScores(ListGameTeamScoresRequest) returns (ListGameTeamScoresResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Games"};
  }

  // List game party scores
  //
  // Get a list of party scores for the given filters
  rpc ListGamePartyScores(ListGamePartyScoresRequest) returns (ListGamePartyScoresResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Games"};
  }

  // Deprecated: List positions
  //
  // Get a list of positions by party's public key using cursor based pagination
  // Deprecated: use ListAllPositions instead
  rpc ListPositions(ListPositionsRequest) returns (ListPositionsResponse) {
    option deprecated = true;
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Positions"};
  }

  // List positions
  //
  // Get a list of all of a party's positions
  rpc ListAllPositions(ListAllPositionsRequest) returns (ListAllPositionsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Positions"};
  }

  // Observe positions
  //
  // Subscribe to a stream of position updates. The first messages sent through the stream will contain
  // information about current positions, followed by updates to those positions.
  rpc ObservePositions(ObservePositionsRequest) returns (stream ObservePositionsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Positions"};
  }

  // List ledger entries
  //
  // Get a list of ledger entries within the given date range. The date range is restricted to a maximum of 5 days.
  // This query requests and sums the number of ledger entries from a given subset of accounts, specified via the 'filter' argument.
  // It returns a time series - implemented as a list of AggregateLedgerEntry structs - with a row for every time
  // the summed ledger entries of the set of specified accounts changes.
  // Each account filter must contain no more than one party ID.
  // At least one party ID must be specified in the from or to account filter.
  //
  // Entries can be filtered by:
  //   - the sending account (market ID, asset ID, account type)
  //   - receiving account (market ID, asset ID, account type)
  //   - sending AND receiving account
  //   - transfer type either in addition to the above filters or as a standalone option
  // Note: The date range is restricted to any 5 days.
  //   If no start or end date is provided, only ledger entries from the last 5 days will be returned.
  //   If a start and end date are provided, but the end date is more than 5 days after the start date, only data up to 5 days after the start date will be returned.
  //   If a start date is provided but no end date, the end date will be set to 5 days after the start date.
  //   If no start date is provided, but the end date is, the start date will be set to 5 days before the end date.
  rpc ListLedgerEntries(ListLedgerEntriesRequest) returns (ListLedgerEntriesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Ledger entries"};
  }

  // Export ledger entries
  //
  // Export ledger entries records ledger entries to a csv file.
  // May or may not contain a date range - if no date range is provided, list all records for all times.
  //
  // Ledger entries can be exported by:
  //   - export ledger entries for a single party for a given asset within a given time range
  //   - export ledger entries for a single party for a given asset for all times
  // buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
  // buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
  rpc ExportLedgerEntries(ExportLedgerEntriesRequest) returns (stream google.api.HttpBody) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Ledger entries"};
  }

  // List balance changes
  //
  // Get a list of the changes in account balances over a period of time.
  rpc ListBalanceChanges(ListBalanceChangesRequest) returns (ListBalanceChangesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Accounts"};
  }

  // Get latest market data
  //
  // Get the latest market data for a given market
  rpc GetLatestMarketData(GetLatestMarketDataRequest) returns (GetLatestMarketDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List latest market data
  //
  // Get a list of the latest market data for every market
  rpc ListLatestMarketData(ListLatestMarketDataRequest) returns (ListLatestMarketDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Get latest market depth
  //
  // Get the latest market depth for a given market
  rpc GetLatestMarketDepth(GetLatestMarketDepthRequest) returns (GetLatestMarketDepthResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Observe markets depth
  //
  // Subscribe to a stream of the latest market depth for a given market
  rpc ObserveMarketsDepth(ObserveMarketsDepthRequest) returns (stream ObserveMarketsDepthResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Observe markets depth updates
  //
  // Subscribe to a stream of updates on market depth for a given market
  rpc ObserveMarketsDepthUpdates(ObserveMarketsDepthUpdatesRequest) returns (stream ObserveMarketsDepthUpdatesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Observe markets data
  //
  // Subscribe to a stream of data about a given market
  rpc ObserveMarketsData(ObserveMarketsDataRequest) returns (stream ObserveMarketsDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Get market data history
  //
  // Get market data history for a market ID from between a given date range
  rpc GetMarketDataHistoryByID(GetMarketDataHistoryByIDRequest) returns (GetMarketDataHistoryByIDResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List transfers
  //
  // Get a list of transfers between public keys. A valid value for public key can be one of:
  // - a party ID
  // - "network"
  // - "0000000000000000000000000000000000000000000000000000000000000000", the public key for the global rewards account
  rpc ListTransfers(ListTransfersRequest) returns (ListTransfersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Transfers"};
  }

  // Get transfer by ID
  //
  // Get a specific transfer by ID
  rpc GetTransfer(GetTransferRequest) returns (GetTransferResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Transfers"};
  }

  // Get network limits
  //
  // Get the network limits relating to asset and market creation
  rpc GetNetworkLimits(GetNetworkLimitsRequest) returns (GetNetworkLimitsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List candle data
  //
  // Get a list of candle data for a given candle ID.
  // A candle ID encapsulates a market ID and candle interval. A list of available candle IDs, and therefore candle intervals can be found using the list-candle-intervals API.
  rpc ListCandleData(ListCandleDataRequest) returns (ListCandleDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Candles"};
  }

  // Observe candle data
  //
  // Subscribe to a stream of candle updates given a candle ID.
  // A candle ID encapsulates a market ID and candle interval. A list of available candle IDs, and therefore candle intervals can be found using the list-candle-intervals API.
  rpc ObserveCandleData(ObserveCandleDataRequest) returns (stream ObserveCandleDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Candles"};
  }

  // List candle intervals
  //
  // Get a list of all available candle intervals for a given market along with the corresponding candle ID.
  rpc ListCandleIntervals(ListCandleIntervalsRequest) returns (ListCandleIntervalsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Candles"};
  }

  // List votes
  //
  // Get a list of votes. A party ID or a proposal ID must be provided.
  rpc ListVotes(ListVotesRequest) returns (ListVotesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Governance"};
  }

  // Observe votes
  //
  // Subscribe to a stream of votes cast on a given proposal, or by all votes made by a given party
  rpc ObserveVotes(ObserveVotesRequest) returns (stream ObserveVotesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Governance"};
  }

  // List ERC20 multisig signer added bundles
  //
  // Get a list of the signature bundles to add a particular validator to the signer list of the multisig contract
  rpc ListERC20MultiSigSignerAddedBundles(ListERC20MultiSigSignerAddedBundlesRequest) returns (ListERC20MultiSigSignerAddedBundlesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "ERC20 bridge"};
  }

  // List ERC20 multisig signer removed bundles
  //
  // Get a list of the signature bundles to remove a particular validator from signer list of the multisig contract
  rpc ListERC20MultiSigSignerRemovedBundles(ListERC20MultiSigSignerRemovedBundlesRequest) returns (ListERC20MultiSigSignerRemovedBundlesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "ERC20 bridge"};
  }

  // Get ERC20 list asset bundle
  //
  // Get the signatures bundle to allowlist an ERC20 token in the collateral bridge
  rpc GetERC20ListAssetBundle(GetERC20ListAssetBundleRequest) returns (GetERC20ListAssetBundleResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "ERC20 bridge"};
  }

  // Get ERC20 set asset limits bundle
  //
  // Get the signature bundle to update the token limits. These are `maxLifetimeDeposit` and `withdrawThreshold` for a given ERC20 token that is
  // already allowlisted in the collateral bridge.
  rpc GetERC20SetAssetLimitsBundle(GetERC20SetAssetLimitsBundleRequest) returns (GetERC20SetAssetLimitsBundleResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "ERC20 bridge"};
  }

  // Get ERC20 withdrawal approval
  //
  // Get the signature bundle to finalise a withdrawal on Ethereum
  rpc GetERC20WithdrawalApproval(GetERC20WithdrawalApprovalRequest) returns (GetERC20WithdrawalApprovalResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "ERC20 bridge"};
  }

  // Get last trade
  //
  // Get the last trade made for a given market.
  rpc GetLastTrade(GetLastTradeRequest) returns (GetLastTradeResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Trades"};
  }

  // List trades
  //
  // Get a list of all trades, optionally filtered by party/market/order
  rpc ListTrades(ListTradesRequest) returns (ListTradesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Trades"};
  }

  // Observe trades
  //
  // Subscribe to a stream of trades, optionally filtered by party/market
  rpc ObserveTrades(ObserveTradesRequest) returns (stream ObserveTradesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Trades"};
  }

  // Get oracle spec
  //
  // Get an oracle spec by ID. Oracle spec IDs can be found by querying markets that use them as a data source
  rpc GetOracleSpec(GetOracleSpecRequest) returns (GetOracleSpecResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Data sources"};
  }

  // List oracle specs
  //
  // Get a list of all oracles specs that are defined against all markets
  rpc ListOracleSpecs(ListOracleSpecsRequest) returns (ListOracleSpecsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Data sources"};
  }

  // List oracle data
  //
  // Get a list of all oracle data that have been broadcast to any market
  rpc ListOracleData(ListOracleDataRequest) returns (ListOracleDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Data sources"};
  }

  // Get market
  //
  // Get information about a specific market using its ID. A market's ID will be the same as the ID of the proposal that
  // generated it
  rpc GetMarket(GetMarketRequest) returns (GetMarketResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List markets
  //
  // Get a list of markets
  rpc ListMarkets(ListMarketsRequest) returns (ListMarketsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List successor markets
  //
  // Given a market ID, return the full lineage of markets since inception, or all successor markets since and including
  // the given market ID. The markets will be returned in succession order, i.e. the market at position i will be the parent
  // of the market at position i+1.
  rpc ListSuccessorMarkets(ListSuccessorMarketsRequest) returns (ListSuccessorMarketsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Get party
  //
  // Get a single party
  rpc GetParty(GetPartyRequest) returns (GetPartyResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Parties"};
  }

  // List parties
  //
  // Get a list of parties
  rpc ListParties(ListPartiesRequest) returns (ListPartiesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Parties"};
  }

  // List parties' profiles
  //
  // Get a list of profiles for multiple parties
  rpc ListPartiesProfiles(ListPartiesProfilesRequest) returns (ListPartiesProfilesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Parties"};
  }

  // List margin levels
  //
  // Get a list of margin levels that match the provided criteria. If no filter is provided, all margin levels will be returned.
  rpc ListMarginLevels(ListMarginLevelsRequest) returns (ListMarginLevelsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Margin"};
  }

  // Observe margin levels
  //
  // Subscribe to a stream of margin levels updates
  rpc ObserveMarginLevels(ObserveMarginLevelsRequest) returns (stream ObserveMarginLevelsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Margin"};
  }

  // List rewards
  //
  // Get a list of rewards that match the provided criteria. If no filter is provided, all rewards will be returned.
  rpc ListRewards(ListRewardsRequest) returns (ListRewardsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Rewards"};
  }

  // List reward summaries
  //
  // Get a list of reward summaries where the reward amount is the total rewards received over all epochs
  // per party ID and asset ID.
  // Request parameters are optional party ID and asset ID.
  // If no data is provided, all reward summaries will be returned grouped by party and asset ID.
  rpc ListRewardSummaries(ListRewardSummariesRequest) returns (ListRewardSummariesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Rewards"};
  }

  // List epoch reward summaries
  //
  // Get a list of reward summaries by epoch for a given range of epochs.
  // The result is filtered by a list of asset IDs, market IDs and starting and ending epochs, for which to return rewards.
  // If no data is provided, all reward summaries will be returned, grouped by epochs, market IDs, asset IDs and reward type.
  rpc ListEpochRewardSummaries(ListEpochRewardSummariesRequest) returns (ListEpochRewardSummariesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Rewards"};
  }

  // Get deposit
  //
  // Get a deposit by its ID
  rpc GetDeposit(GetDepositRequest) returns (GetDepositResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Assets"};
  }

  // List deposits
  //
  // Get a list of deposits for a given party.
  // If a date range is provided, filtering will be based on the last time the deposit
  // has been updated in Vega time.
  rpc ListDeposits(ListDepositsRequest) returns (ListDepositsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Assets"};
  }

  // Get withdrawal
  //
  // Get a withdrawal by its ID. A withdrawal's ID will be the SHA3-256 hash of the signature that the withdrawal was submitted with
  rpc GetWithdrawal(GetWithdrawalRequest) returns (GetWithdrawalResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Assets"};
  }

  // List withdrawals
  //
  // Get a list of withdrawals for a given party
  rpc ListWithdrawals(ListWithdrawalsRequest) returns (ListWithdrawalsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Assets"};
  }

  // Get asset
  //
  // Get a single asset using its ID. Use the assets list query to get an asset's ID
  rpc GetAsset(GetAssetRequest) returns (GetAssetResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Assets"};
  }

  // List assets
  //
  // Get a list of assets available on the Vega network
  rpc ListAssets(ListAssetsRequest) returns (ListAssetsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Assets"};
  }

  // List liquidity provisions
  //
  // DEPRECATED: When a liquidity provider amends a provision, and it's accepted by the network, the pending
  // provision is returned by the API instead of the provision that is currently active.
  // Use ListAllLiquidityProvisions instead.
  rpc ListLiquidityProvisions(ListLiquidityProvisionsRequest) returns (ListLiquidityProvisionsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Liquidity"};
    option deprecated = true;
  }

  // List liquidity provisions
  //
  // Get a list of liquidity provisions for a given market. This API returns a current and pending liquidity provision
  // in the event that a provision has been updated by the provider but the updated provision will not be active until the next epoch.
  rpc ListAllLiquidityProvisions(ListAllLiquidityProvisionsRequest) returns (ListAllLiquidityProvisionsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Liquidity"};
  }

  // Observe liquidity provisions
  //
  // Subscribe to a stream of liquidity provision events for a given market and party
  rpc ObserveLiquidityProvisions(ObserveLiquidityProvisionsRequest) returns (stream ObserveLiquidityProvisionsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Liquidity"};
  }

  // List liquidity providers data
  //
  // List information about active liquidity provider(s) for a given market, or liquidity provider's party ID.
  rpc ListLiquidityProviders(ListLiquidityProvidersRequest) returns (ListLiquidityProvidersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Liquidity"};
  }

  // List paid liquidity fees data
  //
  // List information about paid liquidity fees for a given market, or asset ID.
  rpc ListPaidLiquidityFees(ListPaidLiquidityFeesRequest) returns (ListPaidLiquidityFeesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Liquidity"};
  }

  // Get governance data
  //
  // Get a single proposal's details either by proposal ID or by reference
  rpc GetGovernanceData(GetGovernanceDataRequest) returns (GetGovernanceDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Governance"};
  }

  // List governance data
  //
  // Get a list of proposals
  rpc ListGovernanceData(ListGovernanceDataRequest) returns (ListGovernanceDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Governance"};
  }

  // Observe governance
  //
  // Subscribe to a stream of updates to governance proposals
  rpc ObserveGovernance(ObserveGovernanceRequest) returns (stream ObserveGovernanceResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Governance"};
  }

  // List delegations
  //
  // Get a list of the token delegations on the network
  rpc ListDelegations(ListDelegationsRequest) returns (ListDelegationsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get network data
  //
  // Get data regarding the nodes of the network
  rpc GetNetworkData(GetNetworkDataRequest) returns (GetNetworkDataResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get node
  //
  // Get information about a given node
  rpc GetNode(GetNodeRequest) returns (GetNodeResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List nodes
  //
  // Get a list of the nodes on the network along with the related information.
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List node signatures
  //
  // Get a list of aggregate signatures from all the nodes of the network
  rpc ListNodeSignatures(ListNodeSignaturesRequest) returns (ListNodeSignaturesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "ERC20 bridge"};
  }

  // Get epoch
  //
  // Get data for a specific epoch, if ID is omitted, it retrieves the current epoch
  rpc GetEpoch(GetEpochRequest) returns (GetEpochResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Estimate fee
  //
  // Estimate the fee that would be incurred for submitting an order
  // with the specified price and size on the market.
  rpc EstimateFee(EstimateFeeRequest) returns (EstimateFeeResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
  }

  // Estimate margin
  //
  // Estimate the margin that would be required for submitting this order
  rpc EstimateMargin(EstimateMarginRequest) returns (EstimateMarginResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Orders"};
    option deprecated = true;
  }

  // Estimate position
  //
  // Estimate the margin that would be required for maintaining the specified position, collateral increase needed to open the specified position and the liquidation price estimate.
  // Margin estimates are scaled to asset decimal places.
  // Liquidation price estimates are scaled to asset decimal places by default, unless an argument to scale to market decimal places is specified in the request.
  rpc EstimatePosition(EstimatePositionRequest) returns (EstimatePositionResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Positions"};
  }

  // List network parameters
  //
  // Get a list of the network parameter keys and their values
  rpc ListNetworkParameters(ListNetworkParametersRequest) returns (ListNetworkParametersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get network parameter
  //
  // Get a network parameter's value by its key
  rpc GetNetworkParameter(GetNetworkParameterRequest) returns (GetNetworkParameterResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List checkpoints
  //
  // Get a list of information about checkpoints generated by the network
  rpc ListCheckpoints(ListCheckpointsRequest) returns (ListCheckpointsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get stake
  //
  // Get staking information for a given party
  rpc GetStake(GetStakeRequest) returns (GetStakeResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get risk factors
  //
  // Get risk factor data for a given market
  rpc GetRiskFactors(GetRiskFactorsRequest) returns (GetRiskFactorsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // Observe event bus
  //
  // Subscribe to a stream of events from the core
  rpc ObserveEventBus(stream ObserveEventBusRequest) returns (stream ObserveEventBusResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Events"};
  }

  // Observe ledger movements
  //
  // Subscribe to a stream of transfer responses
  rpc ObserveLedgerMovements(ObserveLedgerMovementsRequest) returns (stream ObserveLedgerMovementsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Ledger movements"};
  }

  // List key rotations
  //
  // Get a list of information about Vega key rotations that have been performed by validator nodes
  rpc ListKeyRotations(ListKeyRotationsRequest) returns (ListKeyRotationsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List Ethereum key rotations
  //
  // Get a list of information about Ethereum key rotations that have been performed by validator nodes
  rpc ListEthereumKeyRotations(ListEthereumKeyRotationsRequest) returns (ListEthereumKeyRotationsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get Vega time
  //
  // Get the current time of the network in Unix nanoseconds
  rpc GetVegaTime(GetVegaTimeRequest) returns (GetVegaTimeResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Get protocol upgrade status
  //
  // Get status of a protocol upgrade
  rpc GetProtocolUpgradeStatus(GetProtocolUpgradeStatusRequest) returns (GetProtocolUpgradeStatusResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List protocol upgrade proposals
  //
  // Get a list of protocol upgrade proposals, optionally filtering on status or approver.
  rpc ListProtocolUpgradeProposals(ListProtocolUpgradeProposalsRequest) returns (ListProtocolUpgradeProposalsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // List snapshots
  //
  // Get a list of core snapshots taken
  rpc ListCoreSnapshots(ListCoreSnapshotsRequest) returns (ListCoreSnapshotsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network"};
  }

  // Network History
  //
  // Network history allows the data node to reach out to peer nodes and fetch the most recent history, as well as
  // older history if desired, such that it can quickly get itself up to the latest block height of the network and start
  // to consume events for the latest block from the Vega core.
  // See https://github.com/vegaprotocol/vega/tree/develop/datanode/networkhistory/README.md for a full description of network history

  // Get most recent network history segment
  //
  // Get the network's most recently history segment
  rpc GetMostRecentNetworkHistorySegment(GetMostRecentNetworkHistorySegmentRequest) returns (GetMostRecentNetworkHistorySegmentResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network history"};
  }

  // List all network history segments
  //
  // Get a list of all history segments stored by the data node currently connected to
  rpc ListAllNetworkHistorySegments(ListAllNetworkHistorySegmentsRequest) returns (ListAllNetworkHistorySegmentsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network history"};
  }

  // Get active network history peer addresses
  //
  // Get a list of the addresses of all active network history peers
  rpc GetActiveNetworkHistoryPeerAddresses(GetActiveNetworkHistoryPeerAddressesRequest) returns (GetActiveNetworkHistoryPeerAddressesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network history"};
  }

  // Network history status
  //
  // Get information about the current state of network history's IPFS swarm
  rpc GetNetworkHistoryStatus(GetNetworkHistoryStatusRequest) returns (GetNetworkHistoryStatusResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network history"};
  }

  // Network history bootstrap peers
  //
  // Get a list of IPFS peers that can be used to initialise a new data node with network history
  rpc GetNetworkHistoryBootstrapPeers(GetNetworkHistoryBootstrapPeersRequest) returns (GetNetworkHistoryBootstrapPeersResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network history"};
  }

  // List entities
  //
  // Get a list of all entities created by transaction hash
  rpc ListEntities(ListEntitiesRequest) returns (ListEntitiesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Explorer"};
  }

  // List funding periods
  //
  // Get a list of funding periods for a perpetual market.
  rpc ListFundingPeriods(ListFundingPeriodsRequest) returns (ListFundingPeriodsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List funding period data points
  //
  // Get a list of data points for a perpetual market's funding periods.
  rpc ListFundingPeriodDataPoints(ListFundingPeriodDataPointsRequest) returns (ListFundingPeriodDataPointsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List funding payments
  //
  // Get a list of funding payment gains and losses for a party as a result of their position on a perpetual market when a funding
  // period ends.
  rpc ListFundingPayments(ListFundingPaymentsRequest) returns (ListFundingPaymentsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Markets"};
  }

  // List party activity streak
  //
  // Get a party's activity across epochs.
  rpc GetPartyActivityStreak(GetPartyActivityStreakRequest) returns (GetPartyActivityStreakResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Referral program"};
  }

  // Get current referral program
  //
  // Get the current referral program for the network. This program may not be active if it has ended
  // and has not been replaced by another.
  rpc GetCurrentReferralProgram(GetCurrentReferralProgramRequest) returns (GetCurrentReferralProgramResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Referral program"};
  }

  // List referral sets
  //
  // List all referral sets, or a specific referral set if you know its ID.
  rpc ListReferralSets(ListReferralSetsRequest) returns (ListReferralSetsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Referral program"};
  }

  // List referral set referees
  //
  // List all referees that belong to a referral set.
  rpc ListReferralSetReferees(ListReferralSetRefereesRequest) returns (ListReferralSetRefereesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Referral program"};
  }

  // Get referral set statistics
  //
  // Get the total taker volume, and each referee's taker volume and, reward and discount factors for a referral set
  // at the latest or a specific epoch. You can also optionally filter for a specific referee's statistics.
  rpc GetReferralSetStats(GetReferralSetStatsRequest) returns (GetReferralSetStatsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Referral program"};
  }

  // List teams
  //
  // Get a list of all teams, or for a specific team by using team ID, or party ID of a referrer or referee
  rpc ListTeams(ListTeamsRequest) returns (ListTeamsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Teams"};
  }

  // List teams statistics
  //
  // Get the statistics of all teams, or for a specific team by using team ID, over a number of epochs.
  // If a team does not have at least the number of epochs' worth of data, it is ignored.
  rpc ListTeamsStatistics(ListTeamsStatisticsRequest) returns (ListTeamsStatisticsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Teams"};
  }

  // List team members' statistics
  //
  // Get the statistics for all members of a given team, or for a specific member by using party ID, over a number of epochs.
  // If a team does not have at least the number of epochs' worth of data, it is ignored.
  rpc ListTeamMembersStatistics(ListTeamMembersStatisticsRequest) returns (ListTeamMembersStatisticsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Teams"};
  }

  // List team referees
  //
  // Get a list of all referees for a given team ID
  rpc ListTeamReferees(ListTeamRefereesRequest) returns (ListTeamRefereesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Teams"};
  }

  // List referee team history
  //
  // Get a list of a referee's team history, i.e. the teams that a referee has been a member of and transferred from/to.
  rpc ListTeamRefereeHistory(ListTeamRefereeHistoryRequest) returns (ListTeamRefereeHistoryResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Teams"};
  }

  // Get fees statistics
  //
  // Get accumulated fees, rewards, and applied discount information. Either a market or an asset must be supplied as a filter.
  rpc GetFeesStats(GetFeesStatsRequest) returns (GetFeesStatsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Fees"};
  }

  // Get fees statistics for a party
  //
  // Get accumulated fees, rewards, and applied discount information. A party ID must be supplied as a filter.
  rpc GetFeesStatsForParty(GetFeesStatsForPartyRequest) returns (GetFeesStatsForPartyResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Fees"};
  }

  // Get current volume discount program
  //
  // Get the current volume discount program for the network. This program may not be active if it has ended
  // and has not been replaced by another.
  rpc GetCurrentVolumeDiscountProgram(GetCurrentVolumeDiscountProgramRequest) returns (GetCurrentVolumeDiscountProgramResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Volume discount program"};
  }

  // Get volume discount statistics
  //
  // Get the information about a party's running traded volume, and the discount factor it earns them.
  rpc GetVolumeDiscountStats(GetVolumeDiscountStatsRequest) returns (GetVolumeDiscountStatsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Volume discount program"};
  }

  // Get vesting balances summary
  //
  // Get information about a party's vesting and locked balances
  rpc GetVestingBalancesSummary(GetVestingBalancesSummaryRequest) returns (GetVestingBalancesSummaryResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Vesting"};
  }

  // Get vesting balance statistics
  //
  // Get information about a party's vesting rewards
  rpc GetPartyVestingStats(GetPartyVestingStatsRequest) returns (GetPartyVestingStatsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Vesting"};
  }

  // Observe transaction results
  //
  // Subscribe to a stream of transaction results, optionally filtered by party/hash/status
  rpc ObserveTransactionResults(ObserveTransactionResultsRequest) returns (stream ObserveTransactionResultsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Transaction results"};
  }

  // Estimate transfer fee costs
  //
  // Estimate transfer fee costs with potential discount applied
  rpc EstimateTransferFee(EstimateTransferFeeRequest) returns (EstimateTransferFeeResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Transfers"};
  }

  // Available transfer fee discount
  //
  // Returns available per party per asset transfer discount
  rpc GetTotalTransferFeeDiscount(GetTotalTransferFeeDiscountRequest) returns (GetTotalTransferFeeDiscountResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Transfers"};
  }

  // List games
  //
  // Get a list of games and corresponding game data, given the provided filters
  rpc ListGames(ListGamesRequest) returns (ListGamesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Games"};
  }

  // List margin modes per party per market
  //
  // Get a list of all margin modes, or for a specific market ID, or party ID.
  rpc ListPartyMarginModes(ListPartyMarginModesRequest) returns (ListPartyMarginModesResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Margin"};
  }

  // Get time weighted notional position
  //
  // Get the time weighted notional position for a given party and asset. The time weighted notional position
  // is used to check if a party qualifies for a reward.
  // If no epoch is specified, the final time weighted notional position from the end of the most recently completed epoch is returned.
  // If an epoch is specified, the final time weighted notional position at that epoch is returned.
  rpc GetTimeWeightedNotionalPosition(GetTimeWeightedNotionalPositionRequest) returns (GetTimeWeightedNotionalPositionResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Positions"};
  }

  // List AMMs
  //
  // Get a list of AMM or filter by market ID, party ID or AMM ID
  rpc ListAMMs(ListAMMsRequest) returns (ListAMMsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "AMMs"};
  }

  // Estimate AMM bounds
  //
  // Get a list of AMMs or filter by market ID, party ID or AMM ID
  rpc EstimateAMMBounds(EstimateAMMBoundsRequest) returns (EstimateAMMBoundsResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "AMMs"};
  }

  // Export network history as CSV
  //
  // Export CSV table data from network history between two block heights.
  //
  // The requested block heights must fall on network history segment boundaries, which can
  // be discovered by calling the API to list all network history segments. By default
  // segments contain 1000 blocks. In that case ranges such as (1, 1000), (1001, 2000), (1, 3000)
  // would all fall on segment boundaries and be valid.
  //
  // The generated CSV file is compressed into a ZIP file and returned, with the file name
  // in the following format: `[chain id]-[table name]-[start block]-[end block].zip`
  //
  // In gRPC, results are returned in a chunked stream of base64 encoded data.
  //
  // Through the REST gateway, the base64 data chunks are decoded and streamed as a
  // `content-type: application/zip` HTTP response.
  //
  // The CSV exported data uses a comma as a DELIMITER between fields, and " for QUOTE-ing fields.
  //
  // If a value contains any of: DELIMITER, QUOTE, carriage return, or line feed then the whole
  // value is prefixed and suffixed by the QUOTE character and any occurrence within
  // the value of a QUOTE character preceded by another QUOTE.
  //
  // A NULL is output as the NULL parameter string and is not quoted, while a non-NULL value
  // matching the NULL parameter string is quoted.
  //
  // For example, with the default settings, a NULL is written as an unquoted empty string,
  // while an empty string data value is written with double quotes.
  //
  // Note that CSV files produced may contain quoted values containing embedded carriage returns and line feeds.
  // Thus the files are not strictly one line per table row like text-format files.
  //
  // The first row of the CSV file is a header that describes the contents of each column
  // in subsequent rows.
  //
  // Usually the ZIP file will contain only a single CSV file. However it is possible that
  // the (from_block, to_block) request spans over a range of blocks in which the underlying
  // schema of the database changes. For example, a column may have been added, removed, or renamed.
  //
  // If this happens, the CSV file will be split at the point of the schema change and the zip
  // file will contain multiple CSV files, with a potentially different set of headers. The
  // 'version' number of the database schema is part of the in the CSV filename:
  //
  //  `[chain id]-[table name]-[schema version]-[start block]-[end block].zip`
  //
  // For example, a zip file might be called mainnet-sometable-000001-003000.zip
  //
  // And contain two CSV files: `mainnet-sometable-1-000001-002000.csv`:
  //
  // timestamp, value
  // 1, foo
  // 2, bar
  //
  // And `mainnet-sometable-2-002001-003000.csv`:
  //
  // timestamp, value, extra_value
  // 3, baz, apple
  //
  // It is worth noting that the schema will not change within a single network history segment.
  // buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
  // buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
  rpc ExportNetworkHistory(ExportNetworkHistoryRequest) returns (stream google.api.HttpBody) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Network history"};
  }

  // Ping
  //
  // Ping the data node
  rpc Ping(PingRequest) returns (PingResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {tags: "Misc"};
  }
}

// -- Pagination --

// All data returned from the API is ordered in a well-defined manner.
// The specific columns and the order in which the sorting is performed
// depend on the API endpoint being called. However, the primary sorting
// column is usually the timestamp of the block in which the data was last updated.
//
// To prevent excessively large response messages and to avoid overloading
// database resources, the API employs a cursor-based pagination mechanism.
//
// This Pagination message can be optionally provided as part of the request to specify:
// - The starting point within the total result set for beginning the page
// - The size of the returned page
// - The ordering of the data within that page
//
// If no Pagination message is provided, the API will return the first page of
// data using the default page size. The default page size is 1000.
//
// To retrieve subsequent pages, the caller must examine the PageInfo structure
// returned in the response to find a cursor string that uniquely identifies the
// last row of that page. This cursor should then be passed in the 'after' field
// of the Pagination message in a subsequent request.
//
// For paging backward, take the cursor for the first row of the page from PageInfo
// and pass it in the 'before' field of the Pagination message.
//
// Pagination message that uses both first/after and last/before is considered invalid.
message Pagination {
  // Number of records to be returned that sort greater than row identified by cursor supplied in 'after'.
  optional int32 first = 1;
  // If paging forwards, the cursor string for the last row of the previous page.
  optional string after = 2;
  // Number of records to be returned that sort less than row identified by cursor supplied in 'before'.
  optional int32 last = 3;
  // If paging forwards, the cursor string for the first row of the previous page.
  optional string before = 4;
  // Whether to order the results with the newest records first. If not set, the default value is true.
  optional bool newest_first = 5;
}

// Page information for cursor based pagination
message PageInfo {
  // Indicator if there is a next page.
  bool has_next_page = 1;
  // Indicator if there is a previous page.
  bool has_previous_page = 2;
  // Start cursor.
  string start_cursor = 3;
  // End cursor.
  string end_cursor = 4;
}

// Request sent to get statistics about the vesting rewards for a party
message GetPartyVestingStatsRequest {
  // Party ID to query the vesting stats for.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Vesting reward statistics for a given party
message GetPartyVestingStatsResponse {
  // Party ID.
  string party_id = 1;
  // Reward bonus multiplier.
  string reward_bonus_multiplier = 2;
  // Epoch for which this information is valid.
  uint64 epoch_seq = 3;
  // The balance of the party, in quantum.
  string quantum_balance = 4;
  // Bonus multiplier applied on the reward, summed across all derived accounts.
  string summed_reward_bonus_multiplier = 5;
  // The balance of the party and derived keys, in quantum.
  string summed_quantum_balance = 6;
}

// Request sent to list the vesting and locked balances for a party
message GetVestingBalancesSummaryRequest {
  // Party ID to query vesting balances for.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Optional asset ID, all asset balances returned if not set.
  optional string asset_id = 2;
}

// List of vesting and locked balances for a party.
message GetVestingBalancesSummaryResponse {
  // Party ID.
  string party_id = 1;
  // Epoch for which these balances are valid.
  optional uint64 epoch_seq = 2;
  // List of locked balances for the party.
  repeated vega.events.v1.PartyLockedBalance locked_balances = 3;
  // List of vesting balances for the party.
  repeated vega.events.v1.PartyVestingBalance vesting_balances = 4;
}

// -- Accounts --

// Represents the current balance of an account for an asset on Vega, for a particular owner or party
message AccountBalance {
  // Party that owns the account.
  // Special values include `network` - represents the Vega network and is
  // most commonly seen during liquidation of a distressed trading position.
  string owner = 2;
  // Asset balance represented as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  // Balances cannot be negative.
  string balance = 3;
  // Asset ID for the account.
  string asset = 4;
  // Market ID for the account, this field will be empty if the asset is in a general account.
  string market_id = 5;
  // Account type of this account.
  vega.AccountType type = 6;
  // Parent party ID of the account.
  // This field is optional and is used in cases where the account is derived from another party's account.
  optional string parent_party_id = 7;
}

// Request that is sent when listing accounts.
message ListAccountsRequest {
  // Account filter contains all filter conditions and values that can be applied to the listing.
  AccountFilter filter = 1;
  // Optional pagination control.
  optional Pagination pagination = 2;
  // Whether to return all derived parties from AMMs for the given party.
  // If used, party ID is required.
  optional bool include_derived_parties = 3;
}

// Response that is received from listing accounts query.
message ListAccountsResponse {
  // Page of accounts data and corresponding page information.
  AccountsConnection accounts = 1;
}

// Page of accounts data and corresponding page information.
message AccountsConnection {
  // Page of accounts data and their corresponding cursors.
  repeated AccountEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Account data item with the corresponding cursor.
message AccountEdge {
  // Account balance data.
  AccountBalance node = 1;
  // Cursor that can be used to fetch further pages with reference to this account.
  string cursor = 2;
}

// Request that is sent when getting a subscription to a stream of accounts.
message ObserveAccountsRequest {
  // Market ID to filter accounts by. If empty, no markets will be filtered.
  string market_id = 1;
  // Party ID to filter accounts by. If empty, no parties will be filtered.
  string party_id = 2;
  // Asset ID to filter accounts by. If empty, no assets will be filtered.
  string asset = 3;
  // Account type to subscribe to, required field.
  vega.AccountType type = 4;
  // Whether to return all derived parties from AMMs for the given party.
  // If used, party ID is required.
  optional bool include_derived_parties = 5;
}

// Response that is received when subscribing to a stream of accounts.
message ObserveAccountsResponse {
  oneof response {
    // 'Initial image' snapshot containing current account balances.
    AccountSnapshotPage snapshot = 1;
    // List of account updates in the last block.
    AccountUpdates updates = 2;
  }
}

// 'Initial image' snapshot containing current account balances - may be sent over several response messages
message AccountSnapshotPage {
  // List of account balances.
  repeated AccountBalance accounts = 1;
  // Indicator if the current page is the last one or not.
  bool last_page = 2;
}

// List of account updates in the last block
message AccountUpdates {
  // List of account balances.
  repeated AccountBalance accounts = 1;
}

// -- Data node information --

// Request that is sent when querying node information
message InfoRequest {}

// Response that is received from the node information query
message InfoResponse {
  // Semver formatted version of the data node.
  string version = 1;
  // Commit hash from which the data node was built.
  string commit_hash = 2;
}

// -- Orders --

// Request that is sent when executing the query for getting a single order
message GetOrderRequest {
  // Order ID to retrieve order information for.
  string order_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Historic version number of the order to return. If not set, the most current version will be returned.
  optional int32 version = 2;
}

// Response received from the query for getting a single order
message GetOrderResponse {
  // Order details, if one was found.
  vega.Order order = 1;
}

// Order filter that contains all filtering conditions and values that are applied to the orders listing
message OrderFilter {
  // Restrict orders to those with the given statuses.
  repeated vega.Order.Status statuses = 1;
  // Restrict orders to those with the given types.
  repeated vega.Order.Type types = 2;
  // Restrict orders to those with the given Time In Force.
  repeated vega.Order.TimeInForce time_in_forces = 3;
  // Indicator if liquidity provisions should be included or not in the list.
  bool exclude_liquidity = 4;
  // Restrict orders to those placed by the given party IDs.
  repeated string party_ids = 5;
  // Restrict orders to those placed on the given market IDs.
  repeated string market_ids = 6;
  // Restrict orders to those with the given reference.
  optional string reference = 7;
  // Restrict orders to those placed during the given date range. If not set, all orders will be returned.
  optional DateRange date_range = 8;
  // Restrict orders to those that are live. If not set, it is treated as being false.
  optional bool live_only = 9;
}

// Request that is sent when executing a query for a list of orders
message ListOrdersRequest {
  // Optional pagination control.
  optional Pagination pagination = 2;
  // Order filter contains all filtering conditions and values that are applied to the orders listing.
  optional OrderFilter filter = 5;
}

// Response that is received from the query to list orders
message ListOrdersResponse {
  // Page of orders data and corresponding page information.
  OrderConnection orders = 1;
}

// Request that is sent when listing possible order versions
message ListOrderVersionsRequest {
  // Order ID to list versions for.
  string order_id = 1 [(google.api.field_behavior) = REQUIRED];

  // Optional pagination control.
  optional Pagination pagination = 4;
}

// Response that is received when listing possible order versions
message ListOrderVersionsResponse {
  // Page of order versions and corresponding page information.
  OrderConnection orders = 1;
}

// Request to subscribe to a stream of orders.
//
// Request fields market ID and party ID are both optional filters:
// If omitted all orders, for all parties on all markets will be returned on the stream
// Both filters can be combined
message ObserveOrdersRequest {
  // Restrict orders to those placed on the given markets.
  repeated string market_ids = 1;
  // Restrict orders to those placed on the market by the given parties.
  repeated string party_ids = 2;
  // Whether liquidity orders should be excluded from the stream. If not set, liquidity orders will be included.
  optional bool exclude_liquidity = 3;
}

// Response that is received from an orders subscription.
message ObserveOrdersResponse {
  oneof response {
    // An 'initial image' snapshot containing current live orders.
    OrderSnapshotPage snapshot = 1;
    // List of order updates in the last block.
    OrderUpdates updates = 2;
  }
}

// 'Initial image' of live orders, may be sent over multiple response messages.
message OrderSnapshotPage {
  // List of order data parts.
  repeated vega.Order orders = 1;
  // Indicator if the last page is reached or not.
  bool last_page = 2;
}

// List of order updates in the last block.
message OrderUpdates {
  // List of orders data.
  repeated vega.Order orders = 1;
}

// Request that is sent when executing the query for getting a single stop order.
message GetStopOrderRequest {
  // Order ID to retrieve order information for.
  string order_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response received from the query for getting a single stop order.
message GetStopOrderResponse {
  // Order details, if one was found.
  vega.events.v1.StopOrderEvent order = 1;
}

// Request that is sent when executing a query for a list of team game scores.
message ListGameTeamScoresRequest {
  // Optional pagination control.
  optional Pagination pagination = 1;
  // Team games filter contains all filtering conditions and values that are applied to the team games score listing.
  optional GameTeamScoresFilter filter = 2;
}

message GameTeamScoresFilter {
  // Restrict game scores to the given ones.
  repeated string game_ids = 1;
  // Restrict game scores to those for the given teams.
  repeated string team_ids = 2;
  // Restrict game scores to those from a given epoch.
  optional uint64 epoch_from = 3;
  // Restrict game scores to those up to a given epoch.
  optional uint64 epoch_to = 4;
}

// Response received from the query for getting a list of game scores for teams.
message ListGameTeamScoresResponse {
  // Page of team game scores data and corresponding page information.
  GameTeamScoresConnection team_scores = 1;
}

// Page of team game scores data and corresponding page information.
message GameTeamScoresConnection {
  // Page of orders and their corresponding cursors.
  repeated GameTeamScoresEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

message GameTeamScoresEdge {
  // Data associated with an order submitted to a Vega node.
  vega.events.v1.GameTeamScore node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Request that is sent when executing a query for a list of party game scores.
message ListGamePartyScoresRequest {
  // Optional pagination control.
  optional Pagination pagination = 1;
  // Party games filter contains all filtering conditions and values that are applied to the party games score listing.
  optional GamePartyScoresFilter filter = 2;
}

message GamePartyScoresFilter {
  // Restrict game scores to those in the given games.
  repeated string game_ids = 1;
  // Restrict game scores to the parties in the given teams.
  repeated string team_ids = 2;
  // Restrict game scores to those relating to the given parties.
  repeated string party_ids = 3;
  // Restrict game scores to those from a given epoch.
  optional uint64 epoch_from = 4;
  // Restrict game scores to those up to a given epoch.
  optional uint64 epoch_to = 5;
}

// Response received from the query for getting a list of game scores for teams.
message ListGamePartyScoresResponse {
  // Page of party game scores data and corresponding page information.
  GamePartyScoresConnection party_scores = 1;
}

// Page of party game scores data and corresponding page information.
message GamePartyScoresConnection {
  // Page of orders and their corresponding cursors.
  repeated GamePartyScoresEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

message GamePartyScoresEdge {
  // Data associated with an order submitted to a Vega node.
  vega.events.v1.GamePartyScore node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Request that is sent when executing a query for a list of stop orders.
message ListStopOrdersRequest {
  // Optional pagination control.
  optional Pagination pagination = 2;
  // Order filter contains all filtering conditions and values that are applied to the orders listing.
  optional StopOrderFilter filter = 5;
}

// Stop order filter
//
// Stop order filter that contains all filtering conditions and values that are applied to the stop orders listing.
message StopOrderFilter {
  // Restrict orders to those with the given statuses.
  repeated vega.StopOrder.Status statuses = 1;
  // Restrict orders to those with the given expiry strategies.
  repeated vega.StopOrder.ExpiryStrategy expiry_strategies = 2;
  // Restrict orders to those placed during the given date range. If not set, all orders will be returned.
  optional DateRange date_range = 3;
  // Restrict orders to those placed by the given party IDs.
  repeated string party_ids = 4;
  // Restrict orders to those placed on the given market IDs.
  repeated string market_ids = 5;
  // Live stop orders only
  optional bool live_only = 6;
}

// Order data with the corresponding cursor.
message StopOrderEdge {
  // Data associated with an order submitted to a Vega node.
  vega.events.v1.StopOrderEvent node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of stop orders data and corresponding page information.
message StopOrderConnection {
  // Page of stop orders and their corresponding cursors.
  repeated StopOrderEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Response that is received from the query to list stop orders.
message ListStopOrdersResponse {
  // Page of stop orders data and corresponding page information.
  StopOrderConnection orders = 1;
}

// -- Positions --

// Request used to list all positions for a party.
// Optionally, if a market ID is set, the results will be filtered for that market only.
message ListPositionsRequest {
  option deprecated = true;
  // Party ID to list positions for, required field.
  string party_id = 1;
  // Market ID to filter for. If empty, no markets will be filtered.
  string market_id = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Response for a list of positions for a party
message ListPositionsResponse {
  option deprecated = true;
  // Page of positions data and corresponding page information.
  PositionConnection positions = 1;
}

// Filter to apply to the ListAllPositionsRequest
message PositionsFilter {
  // Restrict positions to those related to the given parties.
  repeated string party_ids = 1;
  // Restrict positions to those on the given markets.
  repeated string market_ids = 2;
}

// Request to list positions, given the position filter is supplied.
message ListAllPositionsRequest {
  // Filter to apply to the positions.
  PositionsFilter filter = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
}

// Response to query for listing of positions, given the filter is supplied
message ListAllPositionsResponse {
  // Page of positions data and corresponding page information.
  PositionConnection positions = 1;
}

// Position data with the corresponding cursor.
message PositionEdge {
  // Position data for a party on a market.
  vega.Position node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of positions and corresponding page information
message PositionConnection {
  // Page of positions data and their corresponding cursors.
  repeated PositionEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request that is used to subscribe to a stream of positions
message ObservePositionsRequest {
  // Restrict position updates to those related to the given parties.
  optional string party_id = 1;
  // Restrict position updates to those related to the given markets.
  optional string market_id = 2;
  // Whether to return all derived parties from AMMs for the given party.
  // If used, party ID is required.
  optional bool include_derived_parties = 3;
}

// Response received from a positions subscription request
message ObservePositionsResponse {
  oneof response {
    // An 'initial image' snapshot containing current positions.
    PositionSnapshotPage snapshot = 1;
    // List of position updates in the last block.
    PositionUpdates updates = 2;
  }
}

// 'Initial image' of current positions, may be sent over multiple response messages
message PositionSnapshotPage {
  // List of positions data.
  repeated vega.Position positions = 1;
  // Indicator if last page is reached or not.
  bool last_page = 2;
}

// List of position updates in the last block
message PositionUpdates {
  // List of positions data.
  repeated vega.Position positions = 1;
}

// Ledger entry filter sets filters on returned set of ledger entries.
message LedgerEntryFilter {
  // Determines whether an entry must have accounts matching both the account_from_filter
  // and the account_to_filter. If set to 'true', entries must have matches in both filters.
  // If set to `false`, entries matching only the account_from_filter or the account_to_filter will also be included.
  bool close_on_account_filters = 1;
  // Used to set values for filtering sender accounts. Party must be provided in this filter or 'to' account filter, or both.
  AccountFilter from_account_filter = 2;
  // Used to set values for filtering receiver accounts. Party must be provided in this filter or 'from' account filter, or both.
  AccountFilter to_account_filter = 3;
  // List of transfer types that is used for filtering sender and receiver accounts.
  repeated vega.TransferType transfer_types = 5;
  // List ledger entries that are associated with a specific transfer ID. If provided, all other filters are ignored
  optional string transfer_id = 6;
}

// List of fields for a ledger entry
enum LedgerEntryField {
  LEDGER_ENTRY_FIELD_UNSPECIFIED = 0;
  LEDGER_ENTRY_FIELD_ACCOUNT_FROM_ID = 1;
  LEDGER_ENTRY_FIELD_ACCOUNT_TO_ID = 2;
  LEDGER_ENTRY_FIELD_TRANSFER_TYPE = 3;
}

// Represents an aggregated view of ledger entry data, sender and receiver accounts,
// details and balances for both sides after the transfer has been made
message AggregatedLedgerEntry {
  // Removed ID field as it is not used, there is no ID for an aggregated ledger entry
  reserved 1;
  // Timestamp in Unix nanoseconds of the block in which the result is referring to.
  int64 timestamp = 2;
  // Amount of ledger entries for the set of requested accounts at the time above.
  string quantity = 3;
  // Transfer type.
  vega.TransferType transfer_type = 4;
  // Asset ID for the asset associated with the entry.
  optional string asset_id = 5;
  // Type of account sent from.
  vega.AccountType from_account_type = 6;
  // Type of account received to.
  vega.AccountType to_account_type = 7;
  // Sender's party ID.
  optional string from_account_party_id = 8;
  // Receiver's party ID.
  optional string to_account_party_id = 9;
  // Sender market ID.
  optional string from_account_market_id = 10;
  // Receiver market ID.
  optional string to_account_market_id = 11;
  // Sender account balance after the transfer.
  string from_account_balance = 12;
  // Receiver account balance after the transfer.
  string to_account_balance = 13;
  // Transfer ID associated with the ledger entry.
  string transfer_id = 14;
}

// -- LedgerEntries --

// Request that is sent when listing ledger entries.
message ListLedgerEntriesRequest {
  // Ledger entry filter that contains all values and conditions according to which
  // the listing of ledger entries is filtered.You must provide at least one party in
  // 'from' account filter, or 'to' account filter.
  LedgerEntryFilter filter = 1;
  // Optional pagination control.
  optional Pagination pagination = 2;
  // Date range for which to list ledger entries.
  // If not set, the date range is restricted to the last 5 days.
  // If a start and end date is provided, but the range is more than 5 days, the end date will be restricted to 5 days from the start.
  // If a start date is provided, but no end date, the end date will be set to 5 days from the start.
  // If an end date is provided, but no start date, the start date will be set to 5 days before the end.
  optional DateRange date_range = 3;
}

// Request that is sent when exporting ledger entries to csv
message ExportLedgerEntriesRequest {
  // Restrict exported ledger entries to those relating to the given party ID.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Restrict exported ledger entries to those relating to the given asset ID.
  optional string asset_id = 2;
  // Date range to export ledger entries for.
  optional DateRange date_range = 4;
}

// Response that is received when listing ledger entries
message ListLedgerEntriesResponse {
  // Page of aggregated ledger entries data and corresponding page information.
  AggregatedLedgerEntriesConnection ledger_entries = 1;
}

// Represents the aggregated ledger entry data with corresponding cursor for it
message AggregatedLedgerEntriesEdge {
  // 'AggregatedLedgerEntry' data.
  AggregatedLedgerEntry node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of aggregated ledger entries data and corresponding page information.
message AggregatedLedgerEntriesConnection {
  // Page of 'AggregatedLedgerEntry' data and their corresponding cursors.
  repeated AggregatedLedgerEntriesEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to use when querying balances changes.
message ListBalanceChangesRequest {
  // Limit the accounts considered according to the filter supplied.
  AccountFilter filter = 1;
  // Pagination controls.
  optional Pagination pagination = 5;
  // Date range over which to query. If a cursor is not provided in the pagination controls,
  // the date range must be provided with a start or end date, or both.
  // The date range is inclusive of the start date and exclusive of the end date.
  // The date range must be no more than 1 year in duration.
  // Dates before 2020-01-01 will not be accepted.
  optional DateRange date_range = 6;
}

// Response that is received from querying balances changes.
message ListBalanceChangesResponse {
  // Page of aggregated balances data and corresponding page information.
  AggregatedBalanceConnection balances = 1;
}

// -- Balances --

// Request that is used when querying balance history
message GetBalanceHistoryRequest {
  // Account filter contains values that can be set in order to limit balance history data to them.
  AccountFilter filter = 1;
  // By default the net balances of all the accounts specified by the filter are returned.
  // If a list of fields is given in group_by, split out those balances by the supplied criteria.
  repeated AccountField group_by = 2;
  optional Pagination pagination = 3;
  optional DateRange date_range = 4;
}

// Response that is received when querying for balance history
message GetBalanceHistoryResponse {
  // Page of aggregated balances with the corresponding page information.
  AggregatedBalanceConnection balances = 1;
}

// Aggregated balance data with the corresponding cursor.
message AggregatedBalanceEdge {
  // Balance of the set of requested accounts.
  AggregatedBalance node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of aggregated balance objects and corresponding page information
message AggregatedBalanceConnection {
  // Page of aggregated balance data and their corresponding cursors.
  repeated AggregatedBalanceEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Account filter is used to filter account data.
//
// An account is defined as a set of asset ID, type, party ID, and market ID.
// - Every account has an associated asset and type.
// - Certain account types such as the global reward pool for example, do not have an associated party.
//   These are denoted by the special party ID 'network'.
// - Certain account types do not have an associated market such as the general party accounts, for example.
//   These are denoted by the special market ID '' (an empty string).
message AccountFilter {
  // Restrict accounts to those holding balances in this asset ID.
  string asset_id = 1;
  // Restrict accounts to those owned by the parties in this list. Pass an empty list for no filter.
  repeated string party_ids = 2;
  // Restrict accounts to those connected to the markets in this list. Pass an empty list for no filter.
  repeated string market_ids = 3;
  // Restrict accounts to those connected to any of the types in this list. Pass an empty list for no filter.
  repeated vega.AccountType account_types = 4;
}

// List of the properties of an account, used for grouping
enum AccountField {
  ACCOUNT_FIELD_UNSPECIFIED = 0;
  ACCOUNT_FIELD_ID = 1;
  ACCOUNT_FIELD_PARTY_ID = 2;
  ACCOUNT_FIELD_ASSET_ID = 3;
  ACCOUNT_FIELD_MARKET_ID = 4;
  ACCOUNT_FIELD_TYPE = 5;
}

// AggregatedBalance data contains the balance of the set of requested accounts combined with corresponding
// party ID, market ID and account type details
message AggregatedBalance {
  // Timestamp in Unix nanoseconds of the block in which the balance exists.
  int64 timestamp = 1;
  // Balance of the set of requested accounts at the time above.
  string balance = 2;
  // If grouping by party, the party ID.
  optional string party_id = 4;
  // If grouping by asset, the asset ID.
  optional string asset_id = 5;
  // If grouping by market, the market ID
  optional string market_id = 6;
  // If grouping by account type, the account type.
  optional vega.AccountType account_type = 7;
}

// -- Market Data --

// Request that is sent to get market depth subscription
message ObserveMarketsDepthRequest {
  // Restrict market depth data by the given market IDs.
  repeated string market_ids = 1;
}

// Response that is received for MarketDepth subscription.
message ObserveMarketsDepthResponse {
  // List of market depth data.
  repeated vega.MarketDepth market_depth = 1;
}

// Request that is sent for market depth update subscription
message ObserveMarketsDepthUpdatesRequest {
  // Restrict updates to market depth by the given market IDs.
  repeated string market_ids = 1;
}

// Response that is received for market depth update subscription
message ObserveMarketsDepthUpdatesResponse {
  // List of market depth update data.
  repeated vega.MarketDepthUpdate update = 1;
}

// Request that is sent for market data subscription
message ObserveMarketsDataRequest {
  // Restrict updates to market data by the given market IDs.
  repeated string market_ids = 1;
}

// Response that is received for market data subscription
message ObserveMarketsDataResponse {
  // List of market data.
  repeated vega.MarketData market_data = 1;
}

// Request that is sent when requesting latest market depth data
message GetLatestMarketDepthRequest {
  // Market ID to request market depth for, required field.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Maximum market depth.
  optional uint64 max_depth = 2;
}

// Response that is received when latest market depth data is queried
message GetLatestMarketDepthResponse {
  // Market ID of the depth levels returned.
  string market_id = 1;
  // Zero or more price levels for the buy side of the market depth data.
  repeated vega.PriceLevel buy = 2;
  // Zero or more price levels for the sell side of the market depth data.
  repeated vega.PriceLevel sell = 3;
  // Last trade recorded on Vega.
  vega.Trade last_trade = 4;
  // Sequence number incremented after each update.
  uint64 sequence_number = 5;
}

// Request that is sent when listing the latest market data for every market
message ListLatestMarketDataRequest {}

// Response that is received when listing the latest market data for every market
message ListLatestMarketDataResponse {
  repeated vega.MarketData markets_data = 1;
}

// Request that is sent when listing the latest market data for a given market
message GetLatestMarketDataRequest {
  // Market ID to retrieve market data for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when listing the latest market data for a given market
message GetLatestMarketDataResponse {
  // Market data that was requested.
  vega.MarketData market_data = 1;
}

// Request that is sent for getting Market Data History
message GetMarketDataHistoryByIDRequest {
  reserved 5;

  // Market ID to request data history for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Timestamp in Unix nanoseconds indicating the start of the date range.
  optional int64 start_timestamp = 2;
  // Timestamp in Unix nanoseconds indicating the end of the date range.
  optional int64 end_timestamp = 3;
  // Pagination control.
  optional Pagination pagination = 4;
}

// Response that is received when querying Market Data History
message GetMarketDataHistoryByIDResponse {
  // Page of market data history with the corresponding page information.
  MarketDataConnection market_data = 1;
}

// Market data with the corresponding cursor.
message MarketDataEdge {
  // Data generated by a market when open.
  vega.MarketData node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of market data items and corresponding page information
message MarketDataConnection {
  // Page of market data items and their corresponding cursors.
  repeated MarketDataEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Transfers --

// Direction of a transfer
enum TransferDirection {
  TRANSFER_DIRECTION_UNSPECIFIED = 0;
  TRANSFER_DIRECTION_TRANSFER_FROM = 1;
  TRANSFER_DIRECTION_TRANSFER_TO = 2;
  TRANSFER_DIRECTION_TRANSFER_TO_OR_FROM = 3;
}

// Request that is sent to list transfers
message ListTransfersRequest {
  // Restrict transfer to those where the given public key is a sender or receiver.
  optional string pubkey = 1;
  // Restrict transfers to those in the given direction from the supplied public key.
  // When is_reward is true, and pubkey is set, then direction MUST be TRANSFER_DIRECTION_DIRECTION_FROM.
  TransferDirection direction = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
  // Restrict transfers to those related to reward transfers.
  optional bool is_reward = 4;
  // Epoch to filter from (included). If omitted, the range goes from the oldest epoch to the `to epoch`.
  optional uint64 from_epoch = 5;
  // Epoch to filter to (included). If omitted, the range goes from `from epoch` to the most recent epoch.
  optional uint64 to_epoch = 6;
  // Status to filter on.
  optional vega.events.v1.Transfer.Status status = 7;
  // Dispatch strategy's scope to filter for.
  optional Scope scope = 8;
  // Game ID to filter on
  optional string game_id = 9;
  // Account type to filter on for transfers from account
  optional vega.AccountType from_account_type = 10;
  // Account type to filter on for transfers to account
  optional vega.AccountType to_account_type = 11;

  // Defines the types of a dispatch strategy's scope the API can filter on.
  enum Scope {
    SCOPE_UNSPECIFIED = 0;
    // Matches transfers that have dispatch strategy scope of individual set.
    SCOPE_INDIVIDUAL = 1;
    // Matches transfers that have dispatch strategy scope of team set.
    SCOPE_TEAM = 2;
  }
}

// Response that is received when listing  transfers
message ListTransfersResponse {
  // Page of transfers data and corresponding page information.
  TransferConnection transfers = 1;
}

message TransferNode {
  // Data relating to a transfer that has been made.
  vega.events.v1.Transfer transfer = 1;
  // Fees paid for this transfer.
  repeated vega.events.v1.TransferFees fees = 2;
}

// Transfers data with the corresponding cursor.
message TransferEdge {
  // Data relating to a transfer that has been made.
  TransferNode node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of transfers data items and corresponding page information
message TransferConnection {
  // Page of transfers data and their corresponding cursors.
  repeated TransferEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request that is sent for getting a transfer by ID
message GetTransferRequest {
  // Transfer ID to request data for.
  string transfer_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when querying transfers by ID
message GetTransferResponse {
  // Transfer and its fees requested by ID.
  TransferNode transfer_node = 1;
}

// -- Network Limits --

// Request that is used to query current network limits
message GetNetworkLimitsRequest {}

// Response received when querying the current network limits
message GetNetworkLimitsResponse {
  // List of received network limits.
  vega.NetworkLimits limits = 1;
}

// -- Candles --

// Request that is used to fetch a list of supported intervals for the given market along with the corresponding candle ID
message ListCandleIntervalsRequest {
  // Unique ID for the market to list candle intervals for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Maps an interval for a given market to its corresponding candle ID
message IntervalToCandleId {
  // Interval for the candle.
  string interval = 1;
  // Unique ID of the candle.
  string candle_id = 2;
}

// List of mapped pairs `interval` -> `candle ID` for a given market
message ListCandleIntervalsResponse {
  // List of the mappings.
  repeated IntervalToCandleId interval_to_candle_id = 1;
}

// Represents the high, low, open, and closing prices for an interval of trading,
// referred to commonly as a candlestick or candle
message Candle {
  // Timestamp in Unix nanoseconds for the point in time when the candle was initially created/opened.
  int64 start = 1;
  // Timestamp in Unix nanoseconds for the point in time when the candle was last updated.
  int64 last_update = 2;
  // Highest price for trading during the candle interval.
  string high = 3;
  // Lowest price for trading during the candle interval.
  string low = 4;
  // Open trade price.
  string open = 5;
  // Closing trade price.
  string close = 6;
  // Total trading volume during the candle interval.
  uint64 volume = 7;
  // Total notional value traded during the candle interval. This value is determined by multiplying price, using market decimal places, by size, using position decimal places.
  // The number of decimal places needed to convert this value to a decimal is market decimal places plus position decimal places.
  uint64 notional = 8;
}

// Request that is used to subscribe to a stream of candles
message ObserveCandleDataRequest {
  // Unique ID for the candle.
  string candle_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when subscribing to a stream of candles
message ObserveCandleDataResponse {
  // Candle data.
  Candle candle = 1;
}

// Request that is used when listing candles for a market at an interval
message ListCandleDataRequest {
  reserved 4;
  // Candle ID to retrieve candle data for.
  string candle_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Timestamp in Unix nanoseconds to retrieve candles from.
  int64 from_timestamp = 2;
  // Timestamp in Unix nanoseconds to retrieve candles to.
  int64 to_timestamp = 3;
  // Pagination controls.
  optional Pagination pagination = 5;
}

// Response for list of candles for a market at an interval
message ListCandleDataResponse {
  // Page of candle data and corresponding page information.
  CandleDataConnection candles = 1;
}

// Candle data with the corresponding cursor.
message CandleEdge {
  // Candlestick data, i.e. high, low, open, and closing prices for an interval of trading.
  Candle node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of candles data and corresponding page information
message CandleDataConnection {
  // Page of candle data items and their corresponding cursors.
  repeated CandleEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Votes --

// Request that is used to list governance votes
message ListVotesRequest {
  // Party for which the votes are requested.
  optional string party_id = 1;
  // Proposal ID to list votes for.
  optional string proposal_id = 2;

  // Optional pagination control.
  optional Pagination pagination = 3;
}

// Response that is received when listing Votes
message ListVotesResponse {
  // Page of votes data received and corresponding page information.
  VoteConnection votes = 1;
}

// Votes data with the corresponding cursor.
message VoteEdge {
  // Data associated with a governance vote.
  vega.Vote node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of vote data items and corresponding page information
message VoteConnection {
  // Page of vote data and their corresponding cursors.
  repeated VoteEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request that is sent to subscribe to votes
message ObserveVotesRequest {
  // Restrict vote updates to those made by the given party.
  optional string party_id = 1;
  // Restrict vote updates to those made on the given proposal.
  optional string proposal_id = 2;
}

// Response that is received from votes subscription
message ObserveVotesResponse {
  // Data associated with governance votes that are published to the stream.
  vega.Vote vote = 1;
}

// Request for adding a signature bundle to the signer list of a multisig contract for a particular validator
message ListERC20MultiSigSignerAddedBundlesRequest {
  // Node ID of the validator for which a signature bundle is required.
  string node_id = 1;
  // Ethereum address of the validator that will submit the bundle.
  string submitter = 2;
  // Epoch in which the bundle was generated, i.e. the epoch in which the node was promoted to consensus validator.
  string epoch_seq = 3;
  // Pagination controls.
  Pagination pagination = 4;
  // Filter signature bundles to those related to the contract on the given chain ID.
  optional string chain_id = 5;
}

// Response from adding a signature bundle to the signer list of a multisig contract for a particular validator
message ListERC20MultiSigSignerAddedBundlesResponse {
  // Page of bundles for that validator - it may have been added multiple times if removed in between - and corresponding page information.
  ERC20MultiSigSignerAddedConnection bundles = 1;
}

// Signature data that is to be added with the corresponding cursor.
message ERC20MultiSigSignerAddedEdge {
  // Signature data to be added.
  vega.events.v1.ERC20MultiSigSignerAdded node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Signature bundle data that is to be added with the corresponding cursor.
message ERC20MultiSigSignerAddedBundleEdge {
  // Signature bundle data to be added.
  ERC20MultiSigSignerAddedBundle node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of signature data items to be added and corresponding page information
message ERC20MultiSigSignerAddedConnection {
  // Page of signature bundle data and their corresponding cursors.
  repeated ERC20MultiSigSignerAddedBundleEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Signature bundle data to be added
message ERC20MultiSigSignerAddedBundle {
  // Ethereum address of the signer to be removed.
  string new_signer = 1;
  // Ethereum address of the submitter.
  string submitter = 2;
  // Nonce used in the signing operation.
  string nonce = 4;
  // Unixnano timestamp for when the validator was added.
  int64 timestamp = 5;
  // Bundle of signatures from current validators to sign in the new signer.
  string signatures = 6;
  // Epoch in which the validator was added.
  string epoch_seq = 3;
  // ID of the EVM chain this signature bundle is valid for.
  string chain_id = 7;
}

// Request for removing a signature bundle from the signer list of the multisig contract for a particular validator
message ListERC20MultiSigSignerRemovedBundlesRequest {
  // Node ID of the validator of which a signature bundle is required.
  string node_id = 1;
  // Ethereum address of the validator that will submit the bundle.
  string submitter = 2;
  // Epoch in which the bundle was generated, i.e. the epoch in which the node was demoted from a consensus validator.
  string epoch_seq = 3;
  // Pagination controls.
  Pagination pagination = 4;
  // Filter signature bundles to those related to the contract on the given chain ID.
  optional string chain_id = 5;
}

// Response when removing a signature bundle from the signer list of the multisig contract for a particular validator
message ListERC20MultiSigSignerRemovedBundlesResponse {
  // Page of signer bundle data items for that validator and corresponding page information.
  ERC20MultiSigSignerRemovedConnection bundles = 1;
}

// Signature data to be removed with the corresponding cursor.
message ERC20MultiSigSignerRemovedEdge {
  // Signature data to be removed.
  vega.events.v1.ERC20MultiSigSignerRemoved node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Signature bundle data to be removed, with the corresponding cursor.
message ERC20MultiSigSignerRemovedBundleEdge {
  // Signature bundle data to be added.
  ERC20MultiSigSignerRemovedBundle node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of signature data items to be removed and corresponding page information.
message ERC20MultiSigSignerRemovedConnection {
  // Page of signature bundle data and their corresponding cursors.
  repeated ERC20MultiSigSignerRemovedBundleEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Signature bundle data to be removed
message ERC20MultiSigSignerRemovedBundle {
  // Ethereum address of the signer to be removed.
  string old_signer = 1;
  // Ethereum address of the submitter.
  string submitter = 2;
  // Nonce used in the signing operation.
  string nonce = 4;
  // Unixnano timestamp for when the validator was added.
  int64 timestamp = 5;
  // Bundle of signatures from current validators to sign in the new signer.
  string signatures = 6;
  // Epoch in which the validator was removed.
  string epoch_seq = 7;
  // ID of the EVM chain this signature bundle is valid for.
  string chain_id = 8;
}

// Request for listing the signature bundle to an ERC-20 token in the collateral bridge
message GetERC20ListAssetBundleRequest {
  // Asset ID of the asset bundle requested.
  string asset_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from listing the signature bundle to an ERC-20 token in the collateral bridge
message GetERC20ListAssetBundleResponse {
  // Address of the asset on Ethereum.
  string asset_source = 1;
  // Asset ID for the underlying Vega asset.
  string vega_asset_id = 2;
  // Nonce that uniquely identifies this signature bundle and prevents resubmission.
  string nonce = 3;
  // Signatures bundle as hex encoded data, prefixed with `0x`
  // e.g: `0x + sig1 + sig2 + ... + sixN`.
  string signatures = 4;
}

// Request for the signature bundle to update the token limits i.e. maxLifetimeDeposit and withdrawThreshold for a given ERC20 token that is already allowlisted in the collateral bridge
message GetERC20SetAssetLimitsBundleRequest {
  // Proposal ID of the asset update proposal.
  string proposal_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response for the signature bundle to update the token limits i.e. maxLifetimeDeposit and withdrawThreshold for a given ERC20 token that is already allowlisted in the collateral bridge
message GetERC20SetAssetLimitsBundleResponse {
  // Address of the asset on Ethereum.
  string asset_source = 1;
  // Asset ID for the underlying Vega asset.
  string vega_asset_id = 2;
  // Nonce that uniquely identifies this signature bundle and prevents resubmission.
  string nonce = 3;
  // Lifetime limit deposit for this asset.
  string lifetime_limit = 4;
  // Withdrawal threshold for this asset.
  string threshold = 5;
  // Signatures bundle as hex encoded data, prefixed with `0x`
  // e.g: `0x + sig1 + sig2 + ... + sixN`.
  string signatures = 6;
}

// Request to get all information required to bundle the call to finalise the withdrawal on the erc20 bridge
message GetERC20WithdrawalApprovalRequest {
  // Withdrawal ID to retrieve.
  string withdrawal_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response with all information required to bundle the call to finalise the withdrawal on the erc20 bridge
// function withdraw_asset(address asset_source, uint256 asset_id, uint256 amount, uint256 expiry, uint256 nonce, bytes memory signatures)
message GetERC20WithdrawalApprovalResponse {
  reserved 3;
  // Address of asset on the bridged EVM chain.
  string asset_source = 1;
  // Amount to be withdrawn.
  string amount = 2;
  // Nonce that uniquely identifies this signature bundle and prevents resubmission.
  string nonce = 4;
  // Signatures bundle as hex encoded data, prefixed with `0x`
  // e.g: 0x + sig1 + sig2 + ... + sixN.
  string signatures = 5;
  // Address, prefixed with `0x`, that will receive the withdrawn assets.
  string target_address = 6;
  // Creation timestamps.
  int64 creation = 7;
  // Chain ID of the bridged EVM chain.
  string source_chain_id = 8;
}

// -- Trades --

// Request for the latest trade that occurred on Vega for a given market
message GetLastTradeRequest {
  // Market ID to retrieve the last trade for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response for the latest trade that occurred on Vega for a given market
message GetLastTradeResponse {
  // Information about the trade, if one is found.
  vega.Trade trade = 1;
}

// Request to list trades
message ListTradesRequest {
  // Restrict trades to those that occurred on the given markets.
  repeated string market_ids = 1;
  // Restrict trades to those that were caused by the given orders.
  repeated string order_ids = 2;
  // Restrict trades to those that were caused by orders placed by the given parties.
  repeated string party_ids = 3;
  // Pagination control.
  optional Pagination pagination = 4;
  // Restrict trades to those made during the given date range. If not set, all trades will be returned.
  optional DateRange date_range = 5;
}

// Response from listing trades
message ListTradesResponse {
  // Page of trades data and corresponding page information.
  TradeConnection trades = 1;
}

// Page of trades and corresponding page information
message TradeConnection {
  // Page of trades and their corresponding cursors.
  repeated TradeEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Trade data item with the corresponding cursor..
message TradeEdge {
  // Data associated with a trade that has been executed.
  vega.Trade node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Request to subscribe to a stream of trades
message ObserveTradesRequest {
  // Request fields market ID and party ID are both optional filters:
  // If omitted all trades, for all parties on all markets will be returned on the stream
  // If market ID is given, trades from that market will be returned on the stream
  // If party ID is given, trades from that party will be returned on the stream
  // Both filters can be combined.

  // Restrict the trades streamed to those made on the given markets.
  repeated string market_ids = 1;
  // Restrict the trades streamed to those made by the given parties.
  repeated string party_ids = 2;
}

// Stream of trades
message ObserveTradesResponse {
  // List of 0 or more trades.
  repeated vega.Trade trades = 1;
}

// -- Oracles --

// Request to get a specific oracle spec by its ID
message GetOracleSpecRequest {
  // Oracle spec ID to request data for.
  string oracle_spec_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response for a oracle spec
message GetOracleSpecResponse {
  // External data spec matching the ID.
  vega.OracleSpec oracle_spec = 1;
}

// Request to get all active oracle specs
message ListOracleSpecsRequest {
  // Pagination controls.
  optional Pagination pagination = 2;
}

// Response to get all active oracle specs
message ListOracleSpecsResponse {
  // Page of active oracle specs and corresponding page information.
  OracleSpecsConnection oracle_specs = 1;
}

// Request to get all seen oracle data
message ListOracleDataRequest {
  // Oracle spec ID to list data for.
  optional string oracle_spec_id = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
}

// Response to get all seen oracle data
message ListOracleDataResponse {
  // Page of seen oracle data and corresponding page information.
  OracleDataConnection oracle_data = 1;
}

// Oracle specs data item with the corresponding cursor.
message OracleSpecEdge {
  // External spec data that satisfies the list request.
  vega.OracleSpec node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of oracle specs and corresponding page information
message OracleSpecsConnection {
  // Page of oracle specs data and their corresponding cursors.
  repeated OracleSpecEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Oracle data item with the corresponding cursor.
message OracleDataEdge {
  // Data that was received from an external oracle.
  vega.OracleData node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of oracle data and corresponding page information.
message OracleDataConnection {
  // Page of oracle data and their corresponding cursors.
  repeated OracleDataEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Markets --

// Request for getting a market by ID
message GetMarketRequest {
  // Market ID of the market to retrieve data for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting a market by ID
message GetMarketResponse {
  // Information about the market requested.
  vega.Market market = 1;
}

// Request for listing markets
message ListMarketsRequest {
  // Pagination control.
  optional Pagination pagination = 2;
  // Whether to include settled markets. If not set, settled markets will be included.
  optional bool include_settled = 3;
}

// Response from listing markets
message ListMarketsResponse {
  // Page of markets and corresponding page information.
  MarketConnection markets = 1;
}

// Market information with the corresponding cursor.
message MarketEdge {
  // Information about the market.
  vega.Market node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of markets and corresponding page information.
message MarketConnection {
  // Page of markets and their corresponding cursors.
  repeated MarketEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request for listing successor markets.
message ListSuccessorMarketsRequest {
  // Market ID that is a member of the succession line. This can be the original market
  // or any subsequent child market that succeeded it.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Flag to indicate whether or not to include the full succession line, or only list
  // the children of the given market ID. If true, the full succession line is included.
  bool include_full_history = 2;
  // Pagination control.
  Pagination pagination = 3;
}

// Successor market information includes the market that is a member of the succession line
// and any governance data that is associated with proposals for child markets
// whether enacted or not.
message SuccessorMarket {
  // The market that is a member of the succession line.
  vega.Market market = 1;
  // All proposals for child markets that have the market as a parent.
  repeated vega.GovernanceData proposals = 2;
}

// Successor market record with the corresponding cursor for paginated results
message SuccessorMarketEdge {
  // Successor market record.
  SuccessorMarket node = 1;
  // Cursor identifying the record for pagination control.
  string cursor = 2;
}

// Page of successor market records and corresponding page information.
message SuccessorMarketConnection {
  // Page of successor markets and their cursors.
  repeated SuccessorMarketEdge edges = 1;
  // Page information for pagination control.
  PageInfo page_info = 2;
}

// Response from a list successor markets request.
message ListSuccessorMarketsResponse {
  // List of markets in the succession line.
  SuccessorMarketConnection successor_markets = 1;
}

// -- Parties --

// Request to get party by ID
message GetPartyRequest {
  // Party ID to retrieve party information for.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting party by ID
message GetPartyResponse {
  // Data for the party requested.
  vega.Party party = 1;
}

// Request to list parties by ID
message ListPartiesRequest {
  // Restrict the returned party to only the given party ID. If not set, all parties will be returned.
  string party_id = 1;
  // Pagination control.
  Pagination pagination = 2;
}

// Response from listing parties
message ListPartiesResponse {
  // Page of parties data and corresponding page information.
  PartyConnection parties = 1;
}

// Party data with the corresponding cursor.
message PartyEdge {
  // Data associated with a party.
  vega.Party node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of parties data and corresponding page information.
message PartyConnection {
  // Page of parties and their corresponding cursors.
  repeated PartyEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to list profiles by party ID.
message ListPartiesProfilesRequest {
  // Restrict the returned profiles to only the given party IDs. If not set,
  // all parties' profiles will be returned.
  repeated string parties = 1;
  // Pagination control.
  Pagination pagination = 2;
}

// Response from listing parties' profiles.
message ListPartiesProfilesResponse {
  // Page of profile data and corresponding page information.
  PartiesProfilesConnection profiles = 1;
}

// Party's profile data with the corresponding cursor.
message PartyProfileEdge {
  // Data associated with a party's profile.
  vega.PartyProfile node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of profile data per party and corresponding page information.
message PartiesProfilesConnection {
  // Page of profiles and their corresponding cursors.
  repeated PartyProfileEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Order data with the corresponding cursor.
message OrderEdge {
  // Data associated with an order submitted to a Vega node.
  vega.Order node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Request for listing margin levels
message ListMarginLevelsRequest {
  // Party ID for which to list the margin levels
  string party_id = 1;
  // Market ID for which to list the margin levels
  string market_id = 2;
  // Pagination control
  Pagination pagination = 3;
}

// Response from listing margin levels
message ListMarginLevelsResponse {
  // Page of margin levels data and corresponding page information.
  MarginConnection margin_levels = 1;
}

// Request to subscribe to a stream of MarginLevels data.
// If a party ID is provided, the stream will contain margin levels for that party only.
// Optionally, the list can be additionally filtered by market
message ObserveMarginLevelsRequest {
  // Restrict margin level updates to those relating to the given party.
  string party_id = 1;
  // Restrict margin level updates to those relating to the given market.
  optional string market_id = 2;
}

// Response from subscribing to margin levels data
message ObserveMarginLevelsResponse {
  // Margin levels data that match the subscription request filters.
  vega.MarginLevels margin_levels = 1;
}

// Page of orders data and corresponding page information.
message OrderConnection {
  // Page of orders and their corresponding cursors.
  repeated OrderEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Margin data with the corresponding cursor.
message MarginEdge {
  // Margin levels data that satisfy a list margin levels request.
  vega.MarginLevels node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of margins data and corresponding page information.
message MarginConnection {
  // Page of margins data and their corresponding cursors.
  repeated MarginEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to get reward details for a party
message ListRewardsRequest {
  // Restrict rewards data to those that were received by the given party.
  string party_id = 1;
  // Restrict rewards data to those that were paid with the given asset ID.
  optional string asset_id = 2;
  // Pagination control.
  optional Pagination pagination = 3;
  // Restrict rewards data to those that were paid after and including the given epoch ID.
  optional uint64 from_epoch = 4;
  // Restrict rewards data to those that were paid up to and including the given epoch ID.
  optional uint64 to_epoch = 5;
  // Filter for rewards paid if the party is a member of the given team
  optional string team_id = 6;
  // Filter for rewards paid if the party participated in the given game
  optional string game_id = 7;
  // Whether to return all derived parties from AMMs for the given party.
  optional bool include_derived_parties = 8;
  // Filter the rewards by market ID.
  optional string market_id = 9;
}

// Response for listing reward details for a single party
message ListRewardsResponse {
  // Page of rewards data and corresponding page information.
  RewardsConnection rewards = 1;
}

// Rewards data with the corresponding cursor.
message RewardEdge {
  // Details for a single reward payment.
  vega.Reward node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of rewards data and corresponding page information.
message RewardsConnection {
  // Page of rewards data items and their corresponding cursors.
  repeated RewardEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to get reward details for a party
message ListRewardSummariesRequest {
  // Restrict the reward summary to rewards paid to the given parties.
  optional string party_id = 1;
  // Restrict the reward summary to rewards paid in the given assets.
  optional string asset_id = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
  // Whether to return rewards for all derived parties from AMMs for the given party.
  // If used, party ID is required.
  optional bool include_derived_parties = 8;
}

// Response from listing reward details in for a single party
message ListRewardSummariesResponse {
  // Page of rewards details data and corresponding page information.
  repeated vega.RewardSummary summaries = 1;
}

// Filter to restrict the results returned by the ListEpochRewardSummaries
message RewardSummaryFilter {
  // Restrict reward summaries to those connected to the assets in the given list.
  repeated string asset_ids = 1;
  // Restrict reward summaries to those connected to the markets in the given list.
  repeated string market_ids = 2;
  // Restrict rewards summaries to those that were paid after and including the given epoch ID.
  optional uint64 from_epoch = 3;
  // Restrict rewards summaries to those that were paid up to and including the given epoch ID.
  optional uint64 to_epoch = 4;
}

// Request to get summary of reward per epoch for a given range of epochs
message ListEpochRewardSummariesRequest {
  // Limit the results considered according to the filter supplied.
  RewardSummaryFilter filter = 1;
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 4;
}

// Return message with reward details in for a single party
message ListEpochRewardSummariesResponse {
  // Page of rewards details for a single party and corresponding page information.
  EpochRewardSummaryConnection summaries = 1;
}

// Page of rewards summary data for epoch and corresponding page information
message EpochRewardSummaryConnection {
  // Page of rewards summary data for epochs and their corresponding cursors.
  repeated EpochRewardSummaryEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Rewards summary data for epoch with the corresponding cursor.
message EpochRewardSummaryEdge {
  // Rewards summary data for epoch.
  vega.EpochRewardSummary node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Request sent for subscribing to rewards
message ObserveRewardsRequest {
  // Asset ID to get rewards data for, if provided.
  optional string asset_id = 1;
  // Party ID to get rewards data for, if provided.
  optional string party_id = 2;
}

// Response that is received from subscribing to rewards data
message ObserveRewardsResponse {
  // Rewards data received.
  vega.Reward reward = 1;
}

// -- Deposits --

// Request to get data about a specific deposit by ID
message GetDepositRequest {
  // Deposit ID to return data for.
  string id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received from getting deposit data
message GetDepositResponse {
  // Deposit matching the ID from the request.
  vega.Deposit deposit = 1;
}

// Request to list all deposits for a given party
message ListDepositsRequest {
  // Restrict deposits to those made by the given party ID.
  string party_id = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
  // Date range of the requested data, if provided.
  optional DateRange date_range = 3;
}

// Response from listing deposits
message ListDepositsResponse {
  // Page of deposits data and corresponding page information.
  DepositsConnection deposits = 1;
}

// Deposits data with the corresponding cursor.
message DepositEdge {
  // Data associated with a single deposit made on the Vega network.
  vega.Deposit node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of deposits data received and corresponding page information
message DepositsConnection {
  // Page of deposits data and their corresponding cursors.
  repeated DepositEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Withdrawals --

// Request to get a specific withdrawal by ID
message GetWithdrawalRequest {
  // Withdrawal ID to retrieve data for.
  string id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response for a withdrawal request
message GetWithdrawalResponse {
  // Withdrawal matching the ID from the request.
  vega.Withdrawal withdrawal = 1;
}

// List all withdrawals for a given party
message ListWithdrawalsRequest {
  // Restrict withdrawals to those made by this party ID.
  string party_id = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
  // Date range of the requested data, if provided.
  optional DateRange date_range = 3;
}

// Response from listing withdrawals data
message ListWithdrawalsResponse {
  // Page of withdrawals data and corresponding page information.
  WithdrawalsConnection withdrawals = 1;
}

// Withdrawals data with the corresponding cursor.
message WithdrawalEdge {
  // Data associated with a single withdrawal made from the Vega network.
  vega.Withdrawal node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of withdrawals data and corresponding page information
message WithdrawalsConnection {
  // Page of withdrawals data and their corresponding cursors.
  repeated WithdrawalEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Assets --

// Request for obtaining asset
message GetAssetRequest {
  // Asset ID to get data for.
  string asset_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting an asset
message GetAssetResponse {
  // Asset information that is returned.
  vega.Asset asset = 1;
}

// Request for listing assets data
message ListAssetsRequest {
  // Optional asset ID to list data for.
  optional string asset_id = 1;
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 2;
}

// Response from listing assets
message ListAssetsResponse {
  // Page of assets data and corresponding page information.
  AssetsConnection assets = 1;
}

// Assets data with the corresponding cursor.
message AssetEdge {
  // Asset data returned.
  vega.Asset node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of asset data and corresponding page information
message AssetsConnection {
  // Page of assets data and their corresponding cursors.
  repeated AssetEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Liquidity Provisions --

// Request for listing liquidity provisions
message ListLiquidityProvisionsRequest {
  // Restrict liquidity provisions to those placed on the given market.
  optional string market_id = 1;
  // Restrict liquidity provisions to those placed by the given party.
  optional string party_id = 2;
  // Restrict liquidity provisions to those with the given order reference.
  optional string reference = 3;
  // Whether to include live liquidity provisions. If not set, live orders will not be included.
  optional bool live = 4;
  // Pagination controls.
  optional Pagination pagination = 5;
}

// Request for listing liquidity provisions
message ListAllLiquidityProvisionsRequest {
  // Restrict liquidity provisions to those placed on the given market.
  optional string market_id = 1;
  // Restrict liquidity provisions to those placed by the given party.
  optional string party_id = 2;
  // Restrict liquidity provisions to those with the given order reference.
  optional string reference = 3;
  // Whether to include live liquidity provisions. If not set, live orders will not be included.
  optional bool live = 4;
  // Pagination controls.
  optional Pagination pagination = 5;
}

// Response from listing liquidity provisions
message ListLiquidityProvisionsResponse {
  // Page of liquidity provisions data and corresponding page information.
  LiquidityProvisionsConnection liquidity_provisions = 1;
}

// Response from listing liquidity provisions
message ListAllLiquidityProvisionsResponse {
  // Page of liquidity provisions data and corresponding page information.
  LiquidityProvisionsWithPendingConnection liquidity_provisions = 1;
}

// Liquidity provider commitment. For API purposes this can report a pending liquidity provision,
// the current live provision or both in the event that an update has been accepted on the network, but has yet
// to go live and thus there is still a pending provision that will become active in the next epoch.
message LiquidityProvision {
  // Liquidity provision that is currently live.
  vega.LiquidityProvision current = 1;
  // Liquidity provision that is currently pending and will go live in the next epoch.
  optional vega.LiquidityProvision pending = 2;
}

// Liquidity provision data with the corresponding cursor.
message LiquidityProvisionsEdge {
  // Data corresponding to a liquidity provider's commitment.
  vega.LiquidityProvision node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Liquidity provision data with the corresponding cursor.
message LiquidityProvisionWithPendingEdge {
  // Data corresponding to a liquidity provider's commitment.
  LiquidityProvision node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of liquidity provisions data and corresponding page information
message LiquidityProvisionsConnection {
  // Page of liquidity provisions data and their corresponding cursors.
  repeated LiquidityProvisionsEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Page of liquidity provisions data and corresponding page information
message LiquidityProvisionsWithPendingConnection {
  // Page of liquidity provisions data and their corresponding cursors.
  repeated LiquidityProvisionWithPendingEdge edges = 1;
  // Page information that is used to fetch further pages.
  PageInfo page_info = 2;
}

// Request sent to subscribe to liquidity provisions
message ObserveLiquidityProvisionsRequest {
  // Target market to observe for liquidity provisions.
  optional string market_id = 1;
  // Target party to observe for submitted liquidity provisions.
  optional string party_id = 2;
}

// Response from liquidity provisions subscription
message ObserveLiquidityProvisionsResponse {
  repeated vega.LiquidityProvision liquidity_provisions = 1;
}

// Request for listing active liquidity providers for a given market.
// Either market ID or party ID or both, must be provided.
message ListLiquidityProvidersRequest {
  // Market ID to retrieve liquidity providers for. If omitted, you must provide a party ID.
  optional string market_id = 1;
  // Party ID to retrieve data for. If omitted, you must provide a market ID.
  optional string party_id = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Liquidity provider information.
message LiquidityProvider {
  // Party ID of the liquidity provider.
  string party_id = 1;
  // ID of the market the liquidity provider is active in.
  string market_id = 2;
  // Information used for calculating an LP's fee share, such as the equity like share,
  // average entry valuation and liquidity score for the liquidity provider for the specified market.
  vega.LiquidityProviderFeeShare fee_share = 3;
  // Information about LP's SLA performance.
  vega.LiquidityProviderSLA sla = 4;
}

// Liquidity provider data with the corresponding cursor.
message LiquidityProviderEdge {
  // Liquidity provider information returned by the API.
  LiquidityProvider node = 1;
  // Cursor that can be used to fetch further data.
  string cursor = 2;
}

// Page of liquidity provider data and corresponding page information.
message LiquidityProviderConnection {
  // Page of liquidity provider data.
  repeated LiquidityProviderEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Response for listing liquidity providers.
message ListLiquidityProvidersResponse {
  // Page of liquidity providers and corresponding page information.
  LiquidityProviderConnection liquidity_providers = 1;
}

// Paid liquidity fees request.
message ListPaidLiquidityFeesRequest {
  // Restrict fee data to those fees generated in the given market.
  optional string market_id = 1;
  // Restrict fee statistics to those paid in the given asset.
  optional string asset_id = 2;
  // Epoch to get paid liquidity fee statistics for. If omitted, the last complete epoch is used.
  optional uint64 epoch_seq = 3;
  // Restrict fee data to those fees paid to the given parties.
  repeated string party_ids = 4;
  // Pagination controls.
  optional Pagination pagination = 5;
  // Whether to return all derived parties from AMMs for the given party. If used, party ID is required.
  optional bool include_derived_parties = 6;
  // Restrict paid liquidity fees to those from a given epoch.
  optional uint64 epoch_from = 7;
  // Restrict paid liquidity fees to those up to a given epoch.
  optional uint64 epoch_to = 8;
}

// Paid liquidity fees response.
message ListPaidLiquidityFeesResponse {
  // Page of paid liquidity fees and corresponding page information.
  PaidLiquidityFeesConnection paid_liquidity_fees = 1;
}

// Paid liquidity fees data with the corresponding cursor.
message PaidLiquidityFeesEdge {
  // Paid liquidity fees data returned by the API.
  vega.events.v1.PaidLiquidityFeesStats node = 1;
  // Cursor that can be used to fetch further data.
  string cursor = 2;
}

// Paid liquidity fees data and corresponding page information.
message PaidLiquidityFeesConnection {
  // Page of paid liquidity fees data.
  repeated PaidLiquidityFeesEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Governance Data --

// Request to get governance data
message GetGovernanceDataRequest {
  // Proposal ID to get governance data for, if provided.
  optional string proposal_id = 1;
  // Reference to get proposal data for, if provided.
  optional string reference = 2;
}

// Response from getting governance data
message GetGovernanceDataResponse {
  // Governance data content, i.e. proposal and votes for and against.
  vega.GovernanceData data = 1;
}

// Request to list governance data
message ListGovernanceDataRequest {
  // Filter for the types of governance proposals to view
  enum Type {
    TYPE_UNSPECIFIED = 0;
    // List all proposals
    TYPE_ALL = 1;
    // List new market proposals
    TYPE_NEW_MARKET = 2;
    // List update market proposals
    TYPE_UPDATE_MARKET = 3;
    // List change Vega network parameter proposals
    TYPE_NETWORK_PARAMETERS = 4;
    // New asset proposals
    TYPE_NEW_ASSET = 5;
    // Proposals for creating a new free form proposal
    TYPE_NEW_FREE_FORM = 6;
    // Update asset proposals
    TYPE_UPDATE_ASSET = 7;
    // Propose a new spot market
    TYPE_NEW_SPOT_MARKET = 8;
    // Update an existing spot market
    TYPE_UPDATE_SPOT_MARKET = 9;
    // Propose a new transfer
    TYPE_NEW_TRANSFER = 10;
    // Proposal to cancel a transfer
    TYPE_CANCEL_TRANSFER = 11;
    // Proposal for updating the state of a market
    TYPE_UPDATE_MARKET_STATE = 12;
    // Proposal to update the referral program
    TYPE_UPDATE_REFERRAL_PROGRAM = 13;
    // Proposal to update the volume discount program
    TYPE_UPDATE_VOLUME_DISCOUNT_PROGRAM = 14;
  }
  // Restrict proposals to those with the given state.
  optional vega.Proposal.State proposal_state = 1;
  // Restrict proposals to those with the given type.
  optional Type proposal_type = 2;
  // Restrict proposals to those proposed by the given party ID.
  optional string proposer_party_id = 3;
  // Restrict proposals to those with the given reference.
  optional string proposal_reference = 4;
  // Pagination controls.
  optional Pagination pagination = 5;
}

// Response from listing governance data
message ListGovernanceDataResponse {
  // Page of governance data and corresponding page information.
  GovernanceDataConnection connection = 1;
}

// Governance data with the corresponding cursor.
message GovernanceDataEdge {
  // Governance data content, i.e. proposal and votes for and against.
  vega.GovernanceData node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of governance data and corresponding page information
message GovernanceDataConnection {
  // Page of governance data and their corresponding cursors.
  repeated GovernanceDataEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request for governance subscription
message ObserveGovernanceRequest {
  // Restrict proposal updates to those proposed by the given party ID.
  optional string party_id = 1;
}

// Response from governance subscription
message ObserveGovernanceResponse {
  // Governance data, i.e. proposal and votes for and against.
  vega.GovernanceData data = 1;
}

// Request for listing delegations
message ListDelegationsRequest {
  // Restrict delegations to those made by the given party ID.
  optional string party_id = 1;
  // Restrict delegations to those made to the given node ID.
  optional string node_id = 2;
  // Return delegations made in the given epoch. If not set, delegations for the current epoch will be returned.
  optional string epoch_id = 3;
  // Pagination controls.
  optional Pagination pagination = 4;
}

// Response from listing delegations
message ListDelegationsResponse {
  // Page of delegations data and corresponding page information.
  DelegationsConnection delegations = 1;
}

// Delegation data with the corresponding cursor.
message DelegationEdge {
  // How much a party is delegating to a node and when.
  vega.Delegation node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of delegations data and corresponding page information
message DelegationsConnection {
  // Page of delegations data and their corresponding cursors.
  repeated DelegationEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to subscribe to all event related to delegations, with the given filters
message ObserveDelegationsRequest {
  // Party ID to get delegations for, if provided.
  optional string party_id = 1;
  // Node ID to get delegations for, if provided.
  optional string node_id = 2;
}

// Response with all events related to delegations, with the given filters
message ObserveDelegationsResponse {
  // How much a party is delegating to a node and when.
  vega.Delegation delegation = 1;
}

// -- Nodes --

// Represents a basic node without any epoch specific details like delegations, staking, rewards etc.
message NodeBasic {
  // Unique ID identifying the node.
  string id = 1;
  // Node operator's public key.
  string pub_key = 2;
  // Tendermint public key of the node.
  string tm_pub_key = 3;
  // Ethereum public key of the node.
  string ethereum_address = 4;
  // URL that provides more information about the node.
  string info_url = 5;
  // Country code for the location of the node.
  string location = 6;
  // Node status.
  vega.NodeStatus status = 13;
  // Node name.
  string name = 17;
  // Avatar URL.
  string avatar_url = 18;
}

// Request to get network data
message GetNetworkDataRequest {}

// Response from getting network data
message GetNetworkDataResponse {
  // Summary of information with respect to nodes on the Vega network.
  vega.NodeData node_data = 1;
}

// Request to get node data
message GetNodeRequest {
  // Node ID to get data for.
  string id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting node
message GetNodeResponse {
  // Data specific to a single node on the Vega network.
  vega.Node node = 1;
}

// Request to list nodes
message ListNodesRequest {
  // Return the node list for the given epoch. If not set, the node list for the current epoch will be returned.
  optional uint64 epoch_seq = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
}

// Response from listing nodes
message ListNodesResponse {
  // Page of node data and corresponding page information.
  NodesConnection nodes = 1;
}

// Node data with the corresponding cursor.
message NodeEdge {
  // Data specific to a single node on the Vega network.
  vega.Node node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of node data and corresponding page information
message NodesConnection {
  // Page of node data and their corresponding cursors.
  repeated NodeEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to specify the ID of the resource to retrieve aggregated signatures for
message ListNodeSignaturesRequest {
  // Resource ID to list signatures for.
  string id = 1 [(google.api.field_behavior) = REQUIRED];
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 2;
}

// Response to specify the ID of the resource to retrieve aggregated signatures for
message ListNodeSignaturesResponse {
  // Page of nodes signatures and corresponding page information.
  NodeSignaturesConnection signatures = 1;
}

// Nodes signature edge with the corresponding cursor.
message NodeSignatureEdge {
  // Node signature data.
  vega.commands.v1.NodeSignature node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of node signatures and corresponding page information.
message NodeSignaturesConnection {
  // Page of node signatures and their corresponding cursors.
  repeated NodeSignatureEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Epochs --

// Request to fetch epoch data
// Provide either the epoch ID or the block height to get the epoch for. If both are provided, the epoch ID will be used.
// If both are omitted, the current epoch will be returned.
message GetEpochRequest {
  // Epoch ID. If provided, returns the epoch with the given ID.
  optional uint64 id = 1;
  // Block height. If provided, returns the epoch that the given block is in.
  optional uint64 block = 2;
}

// Response from getting epoch
message GetEpochResponse {
  // Data specific to a single epoch on the Vega network. This includes the epoch number,
  // start and end times, and the nodes that participated in the epoch.
  vega.Epoch epoch = 1;
}

// -- Estimates --

// Request to fetch the estimated fee if an order were to trade immediately
message EstimateFeeRequest {
  // Market ID, used to specify the fee factors.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Price at which the potential order is expected to trade.
  string price = 2 [(google.api.field_behavior) = REQUIRED];
  // Size at which the potential order is expected to trade.
  uint64 size = 3 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received from EstimateFeeRequest, contains the estimated fees for a given order
message EstimateFeeResponse {
  // Summary of the estimated fees for this order if it were to trade now.
  vega.Fee fee = 2;
}

// Request to fetch the estimated MarginLevels if an order were to trade immediately
message EstimateMarginRequest {
  option deprecated = true;
  // Market ID for the order.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Party ID of the order.
  string party_id = 2 [(google.api.field_behavior) = REQUIRED];
  // Order side - indicator for Seller or Buyer side.
  vega.Side side = 3 [(google.api.field_behavior) = REQUIRED];
  // Type of the order.
  vega.Order.Type type = 4 [(google.api.field_behavior) = REQUIRED];
  // Size of order.
  uint64 size = 5 [(google.api.field_behavior) = REQUIRED];
  // Price of the asset.
  string price = 6 [(google.api.field_behavior) = REQUIRED];
}

// Response to an estimate margin request, containing the estimated margin levels for a given order
message EstimateMarginResponse {
  option deprecated = true;
  // Summary of the estimated margins for this order if it were to trade now.
  vega.MarginLevels margin_levels = 2;
}

// Message requesting for the list of all network parameters
message ListNetworkParametersRequest {
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 1;
}

// Response containing all of the Vega network parameters
message ListNetworkParametersResponse {
  // Page of network parameters and corresponding page information.
  NetworkParameterConnection network_parameters = 1;
}

// Request for a single network parameter
message GetNetworkParameterRequest {
  // Key identifying the network parameter.
  string key = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when getting a network parameter
message GetNetworkParameterResponse {
  // Network parameter key and value.
  vega.NetworkParameter network_parameter = 1;
}

// Network parameter with the corresponding cursor.
message NetworkParameterEdge {
  // Name and associated value of a network parameter.
  vega.NetworkParameter node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of network parameters and corresponding page information
message NetworkParameterConnection {
  // Page of network parameters data and their corresponding cursors.
  repeated NetworkParameterEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Checkpoints --

// Actual data regarding a checkpoint
message Checkpoint {
  // Hash of the checkpoint.
  string hash = 1;
  // Block hash at which the checkpoint is made.
  string block_hash = 2;
  // Block number at which the checkpoint is made.
  uint64 at_block = 3;
}

// Request to get all checkpoints. Currently no fields, probably will be expanded to allow filtering data
message ListCheckpointsRequest {
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 1;
}

// Response message containing all checkpoints requested
message ListCheckpointsResponse {
  // Page of checkpoints data and corresponding page information.
  CheckpointsConnection checkpoints = 1;
}

// Checkpoint data with the corresponding cursor.
message CheckpointEdge {
  // Data relating to a single checkpoint generated by the Vega network.
  Checkpoint node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of checkpoints data and corresponding page information
message CheckpointsConnection {
  // Page of checkpoints data and their corresponding cursors.
  repeated CheckpointEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to get stake
message GetStakeRequest {
  // Party ID for which the stake information is requested.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 2;
}

// Response that is received from requesting stake information
message GetStakeResponse {
  // Current stake available information.
  string current_stake_available = 1;
  // Paged list of stake data with corresponding page information.
  StakesConnection stake_linkings = 2;
}

// Stake linking data with the corresponding cursor.
message StakeLinkingEdge {
  // Stake linking representing the intent from a party to deposit.
  vega.events.v1.StakeLinking node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of stake data and corresponding page information.
message StakesConnection {
  // Page of stake data and their corresponding cursors.
  repeated StakeLinkingEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to get risk factor
message GetRiskFactorsRequest {
  // Market ID to get the risk factor for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received from getting a risk factor
message GetRiskFactorsResponse {
  // Risk factor emitted by the risk model for a given market.
  vega.RiskFactor risk_factor = 1;
}

// -- EventBus --

// Request to subscribe to a stream of one or more event types from the Vega event bus
message ObserveEventBusRequest {
  // One or more types of event, required field.
  repeated vega.events.v1.BusEventType type = 1;
  // Market ID to filter for, optional field. If empty, no markets will be excluded from the stream.
  string market_id = 2;
  // Party ID to filter for, optional field. If empty, no parties will be excluded from the stream.
  string party_id = 3;
  // Batch size,
  // If not specified, any events received will be sent immediately. If the client is not ready
  // for the next data-set, data may be dropped a number of times, and eventually the stream is closed.
  // if specified, the first batch will be sent when ready. To receive the next set of events, the client
  // must write an `ObserveEventBatch` message on the stream to flush the buffer.
  // If no message is received in 5 seconds, the stream is closed.
  // Default: 0, send any and all events when they are available.
  int64 batch_size = 4;
}

// Response to a subscribed stream of events from the Vega event bus
message ObserveEventBusResponse {
  // List of events that occurred on the Vega event bus.
  repeated vega.events.v1.BusEvent events = 1;
}

// -- Transfer Responses --

// Request to subscribe to ledger movements
message ObserveLedgerMovementsRequest {}

// Response from ledger movements subscription
message ObserveLedgerMovementsResponse {
  // Ledger movements data with list of ledger entries and post-transfer balances.
  vega.LedgerMovement ledger_movement = 1;
}

// -- Key rotations --

// Request to list all key rotations
message ListKeyRotationsRequest {
  // Node ID to get key rotations for, if provided.
  optional string node_id = 1;
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 2;
}

// Response message containing Vega key rotations
message ListKeyRotationsResponse {
  // Page of key rotations data and corresponding page information.
  KeyRotationConnection rotations = 1;
}

// Key rotation data with the corresponding cursor.
message KeyRotationEdge {
  // Data relating to a key rotation that was performed by a node on the Vega network.
  vega.events.v1.KeyRotation node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of key rotations data and corresponding page information
message KeyRotationConnection {
  // Page of key rotation data and their corresponding cursors.
  repeated KeyRotationEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// -- Ethereum key rotations --

// Request to list ethereum key rotations for nodes, optionally filtered by node
message ListEthereumKeyRotationsRequest {
  // Node ID to get the rotation for, if provided.
  optional string node_id = 1;
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 2;
}

// Response message containing Ethereum key rotations
message ListEthereumKeyRotationsResponse {
  // Page of Ethereum key rotations data and corresponding page information.
  EthereumKeyRotationsConnection key_rotations = 1;
}

// Page of Ethereum key rotations data and corresponding page information
message EthereumKeyRotationsConnection {
  // Page of Ethereum key rotations data and their corresponding cursors.
  repeated EthereumKeyRotationEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Ethereum key rotation data with the corresponding cursor.
message EthereumKeyRotationEdge {
  // Data relating to an Ethereum key rotation performed by a node on the Vega network.
  vega.events.v1.EthereumKeyRotation node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// -- Vega Time --

// Request to get the current time of the Vega network
message GetVegaTimeRequest {}

// Response for the current consensus coordinated time on the Vega network, referred to as "VegaTime"
message GetVegaTimeResponse {
  // Timestamp representation of current VegaTime as represented in Unix nanoseconds, for example
  // `1580473859111222333` corresponds to `2020-01-31T12:30:59.111222333Z`.
  int64 timestamp = 1;
}

// Date range for queries that can return historical data
// Timestamps should be provided as unix time in Unix nanoseconds and are inclusive.
message DateRange {
  // Timestamp in Unix nanoseconds indicating the start of the date range.
  optional int64 start_timestamp = 1;
  // Timestamp in Unix nanoseconds indicating the end of the date range.
  optional int64 end_timestamp = 2;
}

// Request to get protocol upgrade status
message GetProtocolUpgradeStatusRequest {}

// Response from getting protocol upgrade status
message GetProtocolUpgradeStatusResponse {
  // Indicator if the upgrade is ready or not.
  bool ready = 1;
}

// Request type for ListProtocolUpgradeProposals; fetches a paginated list of protocol upgrade proposals
message ListProtocolUpgradeProposalsRequest {
  // Restrict protocol upgrade proposals to those with the given status.
  optional vega.events.v1.ProtocolUpgradeProposalStatus status = 1;
  // Restrict protocol upgrade proposals to those approved by the given node ID.
  optional string approved_by = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Response type from a ListProtocolUpgradeProposals RPC call; a paginated list of protocol upgrade proposals
message ListProtocolUpgradeProposalsResponse {
  // Page of protocol upgrade proposals and corresponding page information.
  ProtocolUpgradeProposalConnection protocol_upgrade_proposals = 1;
}

// Page of protocol upgrade proposals and corresponding page information
message ProtocolUpgradeProposalConnection {
  // Page of protocol upgrade proposals data and their corresponding cursors.
  repeated ProtocolUpgradeProposalEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Protocol upgrade proposal data with the corresponding cursor.
message ProtocolUpgradeProposalEdge {
  // Protocol upgrade proposal data.
  vega.events.v1.ProtocolUpgradeEvent node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Request type for ListCoreSnapshots; fetches a paginated list of the core snapshots.
message ListCoreSnapshotsRequest {
  // Optional pagination information to limit the data that is returned.
  optional Pagination pagination = 1;
}

// Response from a ListCoreSnapshots RPC call; a paginated list of the core snapshots.
message ListCoreSnapshotsResponse {
  // Page of core snapshot data and corresponding page information.
  CoreSnapshotConnection core_snapshots = 1;
}

// Page of core snapshot data and corresponding page information.
message CoreSnapshotConnection {
  // Page of core snapshot data and their corresponding cursors.
  repeated CoreSnapshotEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Core snapshot data with the corresponding cursor.
message CoreSnapshotEdge {
  // Core snapshot data.
  vega.events.v1.CoreSnapshotData node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// -- Network History --
// Network History allows the data node to reach out to peer nodes to fetch the most recent history, as well as
// older history if desired, such that it can quickly get itself up to the latest block height of the network and start
// to consume events for the latest block from the Vega core.
// See https://github.com/vegaprotocol/vega/tree/develop/datanode/networkhistory/README.md for a full description of Network History

// Describes a network history segment
message HistorySegment {
  // Starting height of the history segment.
  int64 from_height = 1;
  // Ending height of the history segment.
  int64 to_height = 2;
  // History segment ID.
  string history_segment_id = 3;
  // Previous history segment ID.
  string previous_history_segment_id = 4;
  // Database schema version of the history segment.
  int64 database_version = 5;
  // Chain ID of the history segment.
  string chain_id = 6;
}

// Request to get the most recent history segment
message GetMostRecentNetworkHistorySegmentRequest {}

// Response from getting most recent history segment
message GetMostRecentNetworkHistorySegmentResponse {
  // Data relating to a history segment created by a Vega data node.
  HistorySegment segment = 1;
  // Key seed for the swarm section.
  string swarm_key_seed = 2;
}

// Request to list all the nodes history segments
message ListAllNetworkHistorySegmentsRequest {}

// Response with a list of all the nodes history segments
message ListAllNetworkHistorySegmentsResponse {
  // Page of history segments data and corresponding page information.
  repeated HistorySegment segments = 1;
}

// Request to get the addresses of active network history peers
message GetActiveNetworkHistoryPeerAddressesRequest {}

// Response containing the addresses of active network history peers
message GetActiveNetworkHistoryPeerAddressesResponse {
  // List of IP addresses for the active peers.
  repeated string ip_addresses = 1;
}

// Request to get the status of network history
message GetNetworkHistoryStatusRequest {}

// Response containing the status of network history
message GetNetworkHistoryStatusResponse {
  // IPFS address of the data node currently connected to.
  string ipfs_address = 1;
  // Swarm key used by the IPFS swarm.
  string swarm_key = 2;
  // Swarm key seed used by the IPFS swarm.
  string swarm_key_seed = 3;
  // List of peers connected to the IPFS swarm.
  repeated string connected_peers = 5;
}

// Request to get the nodes network history bootstrap peers
message GetNetworkHistoryBootstrapPeersRequest {}

// Response containing the nodes network history bootstrap peers
message GetNetworkHistoryBootstrapPeersResponse {
  // List of peers that can be used to bootstrap a Vega data node.
  repeated string bootstrap_peers = 1;
}

enum Table {
  TABLE_UNSPECIFIED = 0;
  TABLE_BALANCES = 1;
  TABLE_CHECKPOINTS = 2;
  TABLE_DELEGATIONS = 3;
  TABLE_LEDGER = 4;
  TABLE_ORDERS = 5;
  TABLE_TRADES = 6;
  TABLE_MARKET_DATA = 7;
  TABLE_MARGIN_LEVELS = 8;
  TABLE_POSITIONS = 9;
  TABLE_LIQUIDITY_PROVISIONS = 10;
  TABLE_MARKETS = 11;
  TABLE_DEPOSITS = 12;
  TABLE_WITHDRAWALS = 13;
  TABLE_BLOCKS = 14;
  TABLE_REWARDS = 15;
}

// Request to export network history data in CSV format
message ExportNetworkHistoryRequest {
  // Block to begin exporting from. Must be the first block of a history segment,
  // which by default are 1000 blocks each; in that case - 1, 1001, 2001 etc. are valid values.
  // This can be checked by first calling the API to list all network history segments.
  int64 from_block = 1;
  // Last block to export up to and including. Must be the last block of a history segment
  // which by default are 1000 blocks each; in that case - 1000, 2000, 3000 etc. are valid values.
  // This can be checked by first calling the API to list all network history segments.
  int64 to_block = 2;
  // Table to export data from.
  Table table = 3;
}

// Request to list all entities that were created by the given transaction hash
message ListEntitiesRequest {
  // Transaction hash to match against
  string transaction_hash = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from listing entities that were created for a given transaction hash
message ListEntitiesResponse {
  repeated vega.Account accounts = 1;
  repeated vega.Order orders = 2;
  repeated vega.Position positions = 3;
  repeated vega.LedgerEntry ledger_entries = 4;
  repeated AccountBalance balance_changes = 5;
  repeated vega.events.v1.Transfer transfers = 6;
  repeated vega.Vote votes = 7;
  repeated ERC20MultiSigSignerAddedBundle erc20_multi_sig_signer_added_bundles = 8;
  repeated ERC20MultiSigSignerRemovedBundle erc20_multi_sig_signer_removed_bundles = 9;
  repeated vega.Trade trades = 10;
  repeated vega.OracleSpec oracle_specs = 11;
  repeated vega.OracleData oracle_data = 12;
  repeated vega.Market markets = 13;
  repeated vega.Party parties = 14;
  repeated vega.MarginLevels margin_levels = 15;
  repeated vega.Reward rewards = 16;
  repeated vega.Deposit deposits = 17;
  repeated vega.Withdrawal withdrawals = 18;
  repeated vega.Asset assets = 19;
  repeated vega.LiquidityProvision liquidity_provisions = 20;
  repeated vega.Proposal proposals = 21;
  repeated vega.Delegation delegations = 22;
  repeated NodeBasic nodes = 23;
  repeated vega.commands.v1.NodeSignature node_signatures = 24;
  repeated vega.NetworkParameter network_parameters = 25;
  repeated vega.events.v1.KeyRotation key_rotations = 26;
  repeated vega.events.v1.EthereumKeyRotation ethereum_key_rotations = 27;
  repeated vega.events.v1.ProtocolUpgradeEvent protocol_upgrade_proposals = 28;
}

// Request to get a party's activity streaks across epochs
message GetPartyActivityStreakRequest {
  // Party ID to get the activity streak for.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Epoch to get the activity streak for. If not set, the last complete epoch is used.
  optional uint64 epoch = 2;
}

// Response when getting a party's activity streaks across epochs
message GetPartyActivityStreakResponse {
  // Party's activity streak in a given epoch.
  vega.events.v1.PartyActivityStreak activity_streak = 1;
}

// A funding payment for a party on a perpetual market
message FundingPayment {
  // Party that received the funding payment.
  string party_id = 1;
  // Market that produced the funding payment.
  string market_id = 2;
  // Funding period sequence this payment was calculated from.
  uint64 funding_period_seq = 3;
  // Timestamp, in Unix nanoseconds, at which this funding payment occurred.
  int64 timestamp = 4;
  // Funding payment amount, where a positive value indicates an earned payment received and a negative value a loss.
  string amount = 5;
}

// Request to list a a party's funding payments
message ListFundingPaymentsRequest {
  // Party ID to get funding payment for.
  string party_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Restrict funding payments returned to those generated by the given market.
  optional string market_id = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Funding payment data with the corresponding cursor.
message FundingPaymentEdge {
  // Funding payment data.
  FundingPayment node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of funding payment data and corresponding page information.
message FundingPaymentConnection {
  // Page of funding payment data and their corresponding cursors.
  repeated FundingPaymentEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Response from listing funding payments
message ListFundingPaymentsResponse {
  // Page of funding period data and corresponding page information.
  FundingPaymentConnection funding_payments = 1;
}

// Request to list a perpetual market's funding periods
message ListFundingPeriodsRequest {
  // Market ID to get funding periods for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Restrict the funding periods to those within the given date range.
  optional DateRange date_range = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Funding period data with the corresponding cursor.
message FundingPeriodEdge {
  // Funding period data.
  vega.events.v1.FundingPeriod node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of funding period data and corresponding page information.
message FundingPeriodConnection {
  // Page of funding period data and their corresponding cursors.
  repeated FundingPeriodEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Response from listing funding periods
message ListFundingPeriodsResponse {
  // Page of funding period data and corresponding page information.
  FundingPeriodConnection funding_periods = 1;
}

message ListFundingPeriodDataPointsRequest {
  // Market ID to get funding period data points for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Restrict the data points to those within the given date range.
  optional DateRange date_range = 2;
  // Restrict the data points to those with the given source type.
  optional vega.events.v1.FundingPeriodDataPoint.Source source = 3;
  // Restrict the data points to those that contributed to the given funding period sequence.
  optional uint64 seq = 4;
  // Pagination controls.
  optional Pagination pagination = 5;
}

// Funding period data point with the corresponding cursor.
message FundingPeriodDataPointEdge {
  // Funding period data point.
  vega.events.v1.FundingPeriodDataPoint node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of funding period data points and corresponding page information.
message FundingPeriodDataPointConnection {
  // Page of funding period data points and their corresponding cursors.
  repeated FundingPeriodDataPointEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Response from listing funding period data points.
message ListFundingPeriodDataPointsResponse {
  // Page of funding period data points and corresponding page information.
  FundingPeriodDataPointConnection funding_period_data_points = 1;
}

// Request to ping the data node
message PingRequest {}

// Ping response from the data node
message PingResponse {}

// Basic description of an order.
message OrderInfo {
  // Side for the order, e.g. buy or sell.
  vega.Side side = 1 [(google.api.field_behavior) = REQUIRED];
  // Price for the order. The price is an unsigned integer. For example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string price = 2 [(google.api.field_behavior) = REQUIRED];
  // Size remaining.
  uint64 remaining = 3 [(google.api.field_behavior) = REQUIRED];
  // Boolean that indicates if it is a market order.
  bool is_market_order = 4 [(google.api.field_behavior) = REQUIRED];
}

// Request for the estimated margin level, margin account balance change, and liquidation price for the specified position.
message EstimatePositionRequest {
  // Market ID to estimate position for.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Open volume. This field is a signed integer scaled to the market's position decimal places.
  // A negative number denotes a short position.
  int64 open_volume = 2 [(google.api.field_behavior) = REQUIRED];
  // Average entry price corresponding to the open volume. The price is an unsigned integer. For example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string average_entry_price = 3 [(google.api.field_behavior) = REQUIRED];
  // Open and/or hypothetical orders.
  repeated OrderInfo orders = 4;
  // Margin account balance. Needs to scaled by asset decimal places.
  string margin_account_balance = 5 [(google.api.field_behavior) = REQUIRED];
  // General account balance. Needs to scaled by asset decimal places.
  string general_account_balance = 6 [(google.api.field_behavior) = REQUIRED];
  // Order margin account balance. Needs to be scaled by asset decimal places.
  string order_margin_account_balance = 7 [(google.api.field_behavior) = REQUIRED];
  // Margin mode for the party, cross margin or isolated margin.
  vega.MarginMode margin_mode = 8 [(google.api.field_behavior) = REQUIRED];
  // Margin factor to be used along with isolated margin mode
  optional string margin_factor = 9;
  // Whether the estimated position margin increase should be included in available collateral for liquidation price calculation in isolated margin mode.
  optional bool include_required_position_margin_in_available_collateral = 10;
  // Whether the liquidation price estimates should be scaled to market decimal places or by asset decimal places. If not set, asset decimal places are used.
  optional bool scale_liquidation_price_to_market_decimals = 11;
}

// Response for the estimated margin level, margin account balance change, and liquidation price for the specified position.
message EstimatePositionResponse {
  // Margin level range estimate for the specified position.
  MarginEstimate margin = 1;
  // Estimated margin account balance increase.
  CollateralIncreaseEstimate collateral_increase_estimate = 2;
  // Liquidation price range estimate for the specified position. Only populated if available collateral was specified in the request.
  LiquidationEstimate liquidation = 3;
}

// Estimates the additional funds needed to support the specified position
message CollateralIncreaseEstimate {
  // Estimate assuming slippage cap is applied
  string worst_case = 1;
  // Estimate assuming no slippage
  string best_case = 2;
}

// Margin level estimate for both worst and best case possible.
message MarginEstimate {
  // Margin level estimate assuming slippage cap is applied.
  vega.MarginLevels worst_case = 1;
  // Margin level estimate assuming no slippage.
  vega.MarginLevels best_case = 2;
}

// Liquidation estimate for both worst and best case possible.
message LiquidationEstimate {
  // Liquidation price estimate assuming slippage cap is applied.
  LiquidationPrice worst_case = 1;
  // Liquidation price estimate assuming no slippage.
  LiquidationPrice best_case = 2;
}

// Liquidation price estimate for either only the current open volume and position given some or all buy orders get filled, or position given some or all sell orders get filled.
message LiquidationPrice {
  // Liquidation price for current open volume ignoring any active orders.
  string open_volume_only = 1;
  // Liquidation price assuming buy orders start getting filled.
  string including_buy_orders = 2;
  // Liquidation price assuming sell orders start getting filled.
  string including_sell_orders = 3;
}

// Request to get the current referral program
message GetCurrentReferralProgramRequest {}

// Response containing the current referral program
message GetCurrentReferralProgramResponse {
  // Referral program currently activated on the network.
  ReferralProgram current_referral_program = 1;
}

// Referral program details.
message ReferralProgram {
  // Incremental version of the program. It is incremented after each program
  // update.
  uint64 version = 1;
  // Unique ID generated from the proposal that created this program.
  string id = 2;
  // Defined tiers in increasing order. First element will give Tier 1, second
  // element will give Tier 2, and so on.
  repeated vega.BenefitTier benefit_tiers = 3;
  // Timestamp in Unix nanoseconds, after which when the current epoch ends, the
  // program will end and benefits will be disabled.
  int64 end_of_program_timestamp = 4;
  // Number of epochs over which the referral set's running volume is evaluated.
  uint64 window_length = 5;
  // Defined benefit tiers ordered by increasing reward multiplier. Determines the level of
  // benefit a party can expect based on their staking.
  repeated vega.StakingTier staking_tiers = 6;
  // Timestamp, in Unix nanoseconds, when the program ended.
  optional int64 ended_at = 7;
}

// Data relating to a referral set.
message ReferralSet {
  // Unique ID of the created set.
  string id = 1;
  // Party that created the set.
  string referrer = 2;
  // Timestamp, in Unix nanoseconds, when the set was created.
  int64 created_at = 3;
  // Timestamp, in Unix nanoseconds, when the set was updated.
  int64 updated_at = 4;
  // Current number of members in the referral set.
  uint64 total_members = 5;
}

// Referral set data with the corresponding cursor.
message ReferralSetEdge {
  // Referral set data.
  ReferralSet node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of referral set data and corresponding page information.
message ReferralSetConnection {
  // Page of referral set data and their corresponding cursors.
  repeated ReferralSetEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to retrieve information about a referral set or sets
message ListReferralSetsRequest {
  // Referral set ID to retrieve information for
  optional string referral_set_id = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
  // Referrer to filter by. If referrer set ID is provided, this field is ignored.
  optional string referrer = 3;
  // Referee to filter by. If referrer set ID or referrer is provided, this field is ignored.
  optional string referee = 4;
}

// Response containing information about a referral set or sets
message ListReferralSetsResponse {
  // Page of referral set data and corresponding page information.
  ReferralSetConnection referral_sets = 1;
}

// Data relating to referees that have joined a referral set
message ReferralSetReferee {
  // Unique ID of the referral set the referee joined.
  string referral_set_id = 1;
  // Party that joined the set.
  string referee = 2;
  // Timestamp, in Unix nanoseconds, when the party joined the set.
  int64 joined_at = 3;
  // Epoch at which the party joined the set.
  uint64 at_epoch = 4;
  // Total notional volume of the referee's aggressive trades over the aggregation period.
  string total_referee_notional_taker_volume = 5;
  // Total rewards generated by the referee over the aggregation period.
  string total_referee_generated_rewards = 6;
}

// Data about the Referral set's referees with the corresponding cursor.
message ReferralSetRefereeEdge {
  // Referral set referee data.
  ReferralSetReferee node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of data about the referral set's referees and corresponding page information.
message ReferralSetRefereeConnection {
  // Page of referral set referee data and their corresponding cursors.
  repeated ReferralSetRefereeEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to retrieve information about a referral set's referees
message ListReferralSetRefereesRequest {
  // Referral set ID to retrieve information for
  optional string referral_set_id = 1;
  // Pagination controls.
  optional Pagination pagination = 2;
  // Referrer to filter by. If referrer set ID is provided, this field is ignored.
  optional string referrer = 3;
  // Referee to filter by. If referrer set ID or referrer is provided, this field is ignored.
  optional string referee = 4;
  // Epochs to aggregate party volume and rewards over. If omitted, 30 epochs will be used.
  optional uint32 aggregation_epochs = 5;
}

// Response containing information about a referral set's referees
message ListReferralSetRefereesResponse {
  // Page of referral set referee data and corresponding page information.
  ReferralSetRefereeConnection referral_set_referees = 1;
}

// Request to get a referral set's stats
message GetReferralSetStatsRequest {
  // Restrict referral set statistics to those for the given referral set.
  optional string referral_set_id = 1;
  // Epoch to get referral set statistics for. If not set, the last complete epoch is used.
  optional uint64 at_epoch = 2;
  // Restrict referral set statistics to those for the given referee.
  optional string referee = 3;
  // Pagination controls.
  optional Pagination pagination = 4;
}

// Response containing the volume discount statistics for the given epoch.
message GetReferralSetStatsResponse {
  // Referral set statistics for the epoch.
  ReferralSetStatsConnection stats = 1;
}

// Page of volume discount stats data and corresponding page information.
message ReferralSetStatsConnection {
  // Page of volume discount statistics data and their corresponding cursors.
  repeated ReferralSetStatsEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Referral set stats data with the corresponding cursor.
message ReferralSetStatsEdge {
  // Referral set stats data.
  ReferralSetStats node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Referral set statistics for a given epoch for a party.
message ReferralSetStats {
  // Epoch at which the set's statistics were updated.
  uint64 at_epoch = 1;
  // Running volume for the set based on the window length of the current
  // referral program.
  string referral_set_running_notional_taker_volume = 2;
  // Party ID.
  string party_id = 3;
  // Discount factor applied to the party.
  string discount_factor = 4;
  // Reward factor applied to the party.
  string reward_factor = 5;
  // Current referee notional taker volume.
  string epoch_notional_taker_volume = 6;
  // Multiplier applied to the referral reward factor when calculating referral rewards due to the referrer.
  string rewards_multiplier = 7;
  // Proportion of the referee's taker fees to be rewarded to the referrer.
  string rewards_factor_multiplier = 8;
  // Indicates if the referral set was eligible to be part of the referral program.
  bool was_eligible = 9;
  // Referrer's taker volume
  string referrer_taker_volume = 10;
}

// Team record containing the team information.
message Team {
  // ID of the created team.
  string team_id = 1;
  // Party ID that created the team.
  string referrer = 2;
  // Name of the team.
  string name = 3;
  // Link to the team's homepage.
  optional string team_url = 4;
  // Link to an image of the team's avatar.
  optional string avatar_url = 5;
  // Timestamp in Unix nanoseconds when the team was created.
  int64 created_at = 6;
  // Whether or not the team is closed to new party members. When closed, only parties specified in the allow list can
  // join the team.
  bool closed = 7;
  // Epoch at which the team was created.
  uint64 created_at_epoch = 8;
  // List of public keys that are allowed to join the team.
  // Only applicable to closed teams.
  repeated string allow_list = 9;
  // Current number of members in the team.
  uint64 total_members = 10;
}

// Team data item with the corresponding cursor.
message TeamEdge {
  // Team data.
  Team node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of team data and corresponding page information.
message TeamConnection {
  // Page of team data and their corresponding cursors.
  repeated TeamEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request to list all teams
message ListTeamsRequest {
  // Restrict teams to those with the given team ID.
  optional string team_id = 1;
  // Restrict teams to those where the given party is a referrer or a referee.
  optional string party_id = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Response for the list teams request containing the team information.
message ListTeamsResponse {
  // Page of team data and corresponding page information.
  TeamConnection teams = 1;
}

// Request to list all teams' statistics.
message ListTeamsStatisticsRequest {
  // Restrict team statistics to those with the given team ID.
  optional string team_id = 1;
  // Defines the number of past epochs to aggregate data from. By default, it takes
  // the last 10 epochs.
  optional uint64 aggregation_epochs = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Response for the list teams' statistics request containing the statistics.
message ListTeamsStatisticsResponse {
  // Page of teams' statistics data and corresponding page information.
  TeamsStatisticsConnection statistics = 1;
}

// Page of teams' statistics and corresponding page information.
message TeamsStatisticsConnection {
  // Page of team data and their corresponding cursors.
  repeated TeamStatisticsEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Team data item with the corresponding cursor.
message TeamStatisticsEdge {
  // Team's statistics data.
  TeamStatistics node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Team's statistics record containing the team information.
message TeamStatistics {
  // Team ID the statistics are related to.
  string team_id = 1;
  // Total of volume accumulated over the requested epoch period, expressed in
  // quantum value.
  string total_quantum_volume = 2;
  // Total of rewards accumulated over the requested epoch period, expressed in
  // quantum value.
  string total_quantum_rewards = 3;
  // List of rewards over the requested epoch period, expressed in quantum
  // value for each epoch.
  repeated QuantumRewardsPerEpoch quantum_rewards = 4;
  // Total of games played.
  uint64 total_games_played = 5;
  // List of games played over the requested epoch period.
  repeated string games_played = 6;
  // List of volumes over the requested epoch period, expressed in quantum
  // value for each epoch.
  repeated QuantumVolumesPerEpoch quantum_volumes = 7;
}

message QuantumRewardsPerEpoch {
  // Epoch for which this information is valid.
  uint64 epoch = 1;
  // Total rewards accumulated over the epoch period, expressed in quantum value.
  string total_quantum_rewards = 2;
}

message QuantumVolumesPerEpoch {
  // Epoch for which this information is valid.
  uint64 epoch = 1;
  // Total volumes accumulated over the epoch period, expressed in quantum value.
  string total_quantum_volumes = 2;
}

// Request to list all team members' statistics.
message ListTeamMembersStatisticsRequest {
  // Restrict team statistics to those with the given team ID.
  string team_id = 1;
  // Restrict team members' statistics to those with the given party ID.
  optional string party_id = 2;
  // Defines the number of past epochs to aggregate data from. By default, it takes
  // the last 10 epochs.
  optional uint64 aggregation_epochs = 3;
  // Pagination controls.
  optional Pagination pagination = 4;
}

// Response for the list team members' statistics request containing the statistics.
message ListTeamMembersStatisticsResponse {
  // Page of team members' statistics data and corresponding page information.
  TeamMembersStatisticsConnection statistics = 1;
}

// Page of team members' statistics and corresponding page information.
message TeamMembersStatisticsConnection {
  // Page of team member data and their corresponding cursors.
  repeated TeamMemberStatisticsEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Team member data item with the corresponding cursor.
message TeamMemberStatisticsEdge {
  // Team member's statistics data.
  TeamMemberStatistics node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Team member's statistics record containing the team member's information.
message TeamMemberStatistics {
  // Party ID the statistics are related to.
  string party_id = 1;
  // Total of volume accumulated over the requested epoch period, expressed in
  // quantum value.
  string total_quantum_volume = 2;
  // Total of rewards accumulated over the requested epoch period, expressed in
  // quantum value.
  string total_quantum_rewards = 3;
  // List of rewards over the requested epoch period, expressed in quantum
  // value for each epoch.
  repeated QuantumRewardsPerEpoch quantum_rewards = 4;
  // Total number of games played.
  uint64 total_games_played = 5;
  // List of games played over the requested epoch period.
  repeated string games_played = 6;
  // List of volumes over the requested epoch period, expressed in quantum
  // value for each epoch.
  repeated QuantumVolumesPerEpoch quantum_volumes = 7;
}

// Request that is sent when listing the referees for a given team.
message ListTeamRefereesRequest {
  // Team ID to list referees for.
  string team_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Pagination controls.
  optional Pagination pagination = 2;
}

// A team's referee info
message TeamReferee {
  // ID of the team the referee joined.
  string team_id = 1;
  // Party that joined the team.
  string referee = 2;
  // Timestamp in Unix nanoseconds when the party joined the team.
  int64 joined_at = 3;
  // Epoch at which the party joined the team.
  uint64 joined_at_epoch = 4;
}

// Team referee data item with the corresponding cursor.
message TeamRefereeEdge {
  // Team referee data.
  TeamReferee node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of team referee data and corresponding page information.
message TeamRefereeConnection {
  // Page of team referee data and their corresponding cursors.
  repeated TeamRefereeEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Response that is sent when listing the referees for a given team.
message ListTeamRefereesResponse {
  // Page of team referee data and corresponding page information.
  TeamRefereeConnection team_referees = 1;
}

// A referee's team change information
message TeamRefereeHistory {
  // ID of the team the referee joined.
  string team_id = 1;
  // Timestamp in Unix nanoseconds when the party joined the team.
  int64 joined_at = 2;
  // Epoch at which the party joined the team.
  uint64 joined_at_epoch = 3;
}

// Team referee history data item with the corresponding cursor.
message TeamRefereeHistoryEdge {
  // Team referee data.
  TeamRefereeHistory node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Page of history data about a referee's team membership and corresponding page information.
message TeamRefereeHistoryConnection {
  // Page of team referee history data and their corresponding cursors.
  repeated TeamRefereeHistoryEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Request that is sent when listing the referee history for a given team.
message ListTeamRefereeHistoryRequest {
  // Party ID to list referee history for.
  string referee = 1 [(google.api.field_behavior) = REQUIRED];
  // Pagination controls.
  optional Pagination pagination = 2;
}

// Response that is sent when listing the referee history for a given team.
message ListTeamRefereeHistoryResponse {
  // Page of team referee history data and corresponding page information.
  TeamRefereeHistoryConnection team_referee_history = 1;
}

// Request that is sent to retrieve fees statistics.
message GetFeesStatsRequest {
  // Restrict fee statistics to those related to the given market.
  optional string market_id = 1;
  // Restrict fee statistics to those related to the given asset.
  optional string asset_id = 2;
  // Epoch to get referral fee statistics for. If not set, the last complete epoch is used.
  optional uint64 epoch_seq = 3;
  // Restrict fee statistics to those for the given party.
  optional string party_id = 4;
  // Restrict fee statistics to epoch range starting with epoch from.
  optional uint64 epoch_from = 5;
  // Restrict fee statistics to epoch range ending with epoch to.
  optional uint64 epoch_to = 6;
}

// Response that is sent when requesting fees statistics.
message GetFeesStatsResponse {
  // Fees statistics for the given request.
  vega.events.v1.FeesStats fees_stats = 1;
}

// Request that is sent to retrieve fees statistics for a given party.
message GetFeesStatsForPartyRequest {
  // Restrict fees statistics to those for the given party.
  string party_id = 1;
  // Restrict fees statistics to those related to the given asset.
  optional string asset_id = 2;
  // Epoch to filter from (included). If omitted, the range goes from the oldest epoch to the `to epoch`.
  optional uint64 from_epoch = 3;
  // Epoch to filter to (included). If omitted, the range goes from `from epoch` to the most recent epoch.
  optional uint64 to_epoch = 4;
}

// Response that is sent when requesting fees statistics for a given party.
message GetFeesStatsForPartyResponse {
  // Fees statistics for the given request.
  repeated FeesStatsForParty fees_stats_for_party = 1;
}

// Request to get the current referral program
message GetCurrentVolumeDiscountProgramRequest {}

// Response containing the current referral program
message GetCurrentVolumeDiscountProgramResponse {
  // Volume discount program currently activated on the network.
  VolumeDiscountProgram current_volume_discount_program = 1;
}

// Request to get the volume discount statistics for a given epoch.
message GetVolumeDiscountStatsRequest {
  // Epoch to get volume discount statistics for. If not set, last epoch is used.
  optional uint64 at_epoch = 1;
  // Restrict volume discount statistics to those for the given party.
  optional string party_id = 2;
  // Pagination controls.
  optional Pagination pagination = 3;
}

// Response containing the volume discount statistics for the given epoch.
message GetVolumeDiscountStatsResponse {
  // Volume discount statistics for an epoch.
  VolumeDiscountStatsConnection stats = 1;
}

// Page of volume discount stats data and corresponding page information.
message VolumeDiscountStatsConnection {
  // Page of volume discount statistics data and their corresponding cursors.
  repeated VolumeDiscountStatsEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Volume discount stats data with the corresponding cursor.
message VolumeDiscountStatsEdge {
  // Volume discount stats data.
  VolumeDiscountStats node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Volume discount statistics for a given epoch for all parties.
message VolumeDiscountStats {
  // Epoch at which the statistics apply.
  uint64 at_epoch = 1;
  // Party ID for which the statistics apply.
  string party_id = 2;
  // Discount factor applied given the party's running volume.
  string discount_factor = 3;
  // The party's running volume.
  string running_volume = 4;
}

// Volume discount program details.
message VolumeDiscountProgram {
  // Incremental version of the program. It is incremented after each program
  // update.
  uint64 version = 1;
  // Unique ID generated from the proposal that created this program.
  string id = 2;
  // Defined benefit tiers ordered by increasing discounts. Determines the level of
  // benefit a party can expect based on performance criteria.
  repeated vega.VolumeBenefitTier benefit_tiers = 3;
  // Timestamp in Unix nanoseconds, after which when the current epoch
  // ends, the program will end and benefits will be disabled.
  int64 end_of_program_timestamp = 4;
  // Number of epochs over which a volume discount statistics' running volume is evaluated.
  uint64 window_length = 5;
  // Timestamp in Unix nanoseconds, at which the program ended.
  optional int64 ended_at = 6;
}

message FeesStatsForParty {
  // Settlement asset of the market.
  string asset_id = 1;
  // Total referral rewards received by referrer of the referral set.
  string total_rewards_received = 2;
  // Total referral discounts applied to referee fees.
  string referees_discount_applied = 3;
  // Total volume discounts applied to referee fees.
  string volume_discount_applied = 4;
  // Total maker fees received by the maker side.
  string total_maker_fees_received = 5;
}

// Request to subscribe to a stream of users' transaction results
message ObserveTransactionResultsRequest {
  // Request fields party ID, hash and status are all optional filters:
  // If omitted all transaction results, for all parties with all hashes and states will be returned on the stream
  // If party ID is given, transaction results from that party will be returned on the stream
  // If hash is given, transaction result with that hash will be returned on the stream
  // If status is given, transaction result with that status (true/false - success failure) will be returned on the stream
  // All filters can be combined.

  // Restrict the transaction results streamed to those made by the given parties.
  repeated string party_ids = 1;
  // Restrict the transaction results streamed to those with given hashes.
  repeated string hashes = 2;
  // Restrict the transaction results streamed to those with given status true/false (success/failure).
  optional bool status = 3;
}

// Stream of transaction results
message ObserveTransactionResultsResponse {
  // List of 0 or more transaction results.
  repeated vega.events.v1.TransactionResult transaction_results = 1;
}

// Request an estimation of transfer fee and discount
message EstimateTransferFeeRequest {
  // Sender's ID.
  string from_account = 1;
  // Type of account sent from.
  vega.AccountType from_account_type = 2;
  // Receiver's ID.
  string to_account = 3;
  // Amount to be transferred.
  string amount = 4;
  // Asset ID for the asset associated with the transaction.
  string asset_id = 5;
  // AMM public key, if assets are being transferred from an AMM key to the AMM owner's public key.
  // The `from_account` must be the owner of this AMM key.
  optional string from_amm_key = 6;
}

// Results of estimation of transfer fee and the fee discount
message EstimateTransferFeeResponse {
  // Estimated fee for the transfer.
  string fee = 1;
  // Discount applied to the fee.
  string discount = 2;
}

// Get total transfer fee discount available
message GetTotalTransferFeeDiscountRequest {
  // ID of party eligible for the discount.
  string party_id = 1;
  // ID of asset associated with the discount.
  string asset_id = 5;
}

// Returns total transfer fee discount available
message GetTotalTransferFeeDiscountResponse {
  // Total per party per asset discount available.
  string total_discount = 2;
}

// Request to retrieve games data.
message ListGamesRequest {
  // Game ID to filter for.
  optional string game_id = 1;
  // Oldest epoch to retrieve game data from, inclusive. The maximum range of epochs that can be fetched at once is 30.
  // If not provided, defaults to the 'to' epoch minus 29, or the first epoch available if not enough epochs have passed.
  // If the 'to' epoch is not specified, it will be set to the chosen 'from' epoch + 29.
  optional uint64 epoch_from = 2;
  // Most recent epoch to retrieve game data to, inclusive. If not provided, defaults to the latest epoch. The maximum range of epochs that can be fetched at once is 30.
  // If no 'from' epoch is provided, or the 'from' epoch is out of range, i.e., the 'to' epoch - 'from' epoch > 29,
  // the 'from' epoch will be set to the 'to' epoch - 29.
  optional uint64 epoch_to = 3;
  // Entity scope to filter games for, i.e. team games or individual games only
  optional vega.EntityScope entity_scope = 4;
  // Pagination controls.
  optional Pagination pagination = 5;
  // Team ID to filter for. This filter will only be applied if entity scope is not specified
  // in the request, or the entity scope is set to teams.
  optional string team_id = 6;
  // Party ID to filter for. This filter will apply regardless of the entity scope.
  // If the entity scope filter is teams, then the party ID filter will apply to team members.
  optional string party_id = 7;
}

// Response containing games data.
message ListGamesResponse {
  // Page of games data and corresponding page information.
  GamesConnection games = 1;
}

// Page of games data and corresponding page information.
message GamesConnection {
  // Page of games data and their corresponding cursors.
  repeated GameEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Game information and corresponding cursor.
message GameEdge {
  // Game data.
  Game node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Data relating to a game.
message Game {
  // Unique ID of the game
  string id = 1;
  // Epoch at which the last game metrics were captured.
  uint64 epoch = 2;
  // The number of participants in the game.
  uint64 participants = 3;
  // Entities participating in a game and their corresponding metrics.
  oneof entities {
    // Team entities that are participating in the game
    TeamGameEntities team = 4;
    // Individual entities that are participating in the game
    IndividualGameEntities individual = 5;
  }
  // ID of the asset rewarded for involvement in the game.
  string reward_asset_id = 6;
}

// List of teams that are participating in a game
message TeamGameEntities {
  // List of teams, the participant members of a team, and the metrics associated with each participant.
  repeated TeamGameEntity team = 1;
}

// List of individuals that are participating in a game
message IndividualGameEntities {
  // List of individual party IDs, and the metrics associated with each participant.
  repeated IndividualGameEntity individual = 1;
}

// Data relating to a team participating in a game.
message TeamGameEntity {
  // Team participation breakdown
  TeamGameParticipation team = 1;
  // Rank of the team in the game
  uint64 rank = 2;
  // Volume traded by the team
  string volume = 3;
  // Reward metric applied to the team
  vega.DispatchMetric reward_metric = 4;
  // Reward earned by the team
  string reward_earned = 5;
  // Total rewards earned by the individual for the team
  string total_rewards_earned = 6;
  // Rewards earned by the team in quantum value
  string reward_earned_quantum = 7;
  // Total rewards earned by the team in quantum value
  string total_rewards_earned_quantum = 8;
}

// Breakdown of a team's participation in a game.
message TeamGameParticipation {
  // ID of the team participating
  string team_id = 1;
  // Individual team member metrics for their participation in the game
  repeated IndividualGameEntity members_participating = 2;
}

// Data relating to an individual participating in a game.
// This can be used for both team members who are participating in a team game,
// or individuals participating in an individual entity game.
message IndividualGameEntity {
  // Party ID of the individual participating
  string individual = 1;
  // Rank of the individual either in the game or within their team.
  uint64 rank = 2;
  // Volume traded by the individual
  string volume = 3;
  // Reward metric applied to the individual
  vega.DispatchMetric reward_metric = 4;
  // Reward earned by the individual during the epoch
  string reward_earned = 5;
  // Total rewards earned by the individual for the game
  string total_rewards_earned = 6;
  // Rewards earned by the individual in quantum value
  string reward_earned_quantum = 7;
  // Total rewards earned by the individual in quantum value
  string total_rewards_earned_quantum = 8;
}

// Request to retrieve party margin modes.
message ListPartyMarginModesRequest {
  // Market ID to filter for.
  optional string market_id = 1;
  // Party ID to filter for.
  optional string party_id = 2;
  // Pagination controls.
  optional Pagination pagination = 5;
}

// Response containing party margin modes.
message ListPartyMarginModesResponse {
  // Page of party margin modes data and corresponding page information.
  PartyMarginModesConnection party_margin_modes = 1;
}

// Page of party margin modes data and corresponding page information.
message PartyMarginModesConnection {
  // Page of party margin modes data and their corresponding cursors.
  repeated PartyMarginModeEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

// Party margin mode information and corresponding cursor.
message PartyMarginModeEdge {
  // Party margin mode data.
  PartyMarginMode node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

// Margin mode selected for the given party and market.
message PartyMarginMode {
  // Unique ID of the market.
  string market_id = 1;
  // Unique ID of the party.
  string party_id = 2;
  // Selected margin mode.
  vega.MarginMode margin_mode = 3;
  // Margin factor for the market. Isolated mode only.
  optional string margin_factor = 4;
  // Minimum theoretical margin factor for the market. Isolated mode only.
  optional string min_theoretical_margin_factor = 5;
  // Maximum theoretical leverage for the market. Isolated mode only.
  optional string max_theoretical_leverage = 6;
  // Epoch at which the update happened.
  uint64 at_epoch = 7;
}

// Time weighted notional position for a party and asset at a given epoch. It is used as a metric to calculate whether
// the party is eligible for receiving a reward.
message TimeWeightedNotionalPosition {
  // Asset ID for the settlement asset associated with the position.
  string asset_id = 1;
  // Party ID for the party associated with the position.
  string party_id = 2;
  // Game ID for the game associated with the position.
  string game_id = 3;
  // Epoch at which the time weighted notional position is calculated.
  uint64 at_epoch = 4;
  // Time weighted notional position for the party and asset.
  string time_weighted_notional_position = 5;
  // Vega time of the block in which the last position update occurred.
  int64 last_updated = 6;
}

// Request to retrieve the time weighted notional position for a party and asset.
// If no epoch is given, the time weighted notional position at the end of the most recently completed epoch will be returned.
// If an epoch is given, the time weighted notional position achieved by the end of the given epoch will be returned.
message GetTimeWeightedNotionalPositionRequest {
  // Asset ID to filter for.
  string asset_id = 1;
  // Party ID to filter for.
  string party_id = 2;
  // Game ID to filter for.
  string game_id = 3;
  // Epoch to filter for.
  optional uint64 at_epoch = 4;
}

// Response containing the time weighted notional position for a party and asset.
message GetTimeWeightedNotionalPositionResponse {
  // Time weighted notional position for the party and asset.
  TimeWeightedNotionalPosition time_weighted_notional_position = 1;
}

message ListAMMsRequest {
  // AMM ID to filter for. If party ID or market ID is provided, the ID filter is ignored.
  optional string id = 1;
  // Party ID to filter for.
  optional string party_id = 2;
  // Market ID to filter for. If party ID is provided, the market filter is ignored
  optional string market_id = 3;
  // Party's underlying AMM sub-account to filter for. A party's AMM sub-account will remain the
  // same regardless of the AMM.
  optional string amm_party_id = 4;
  // Filter for AMMs with the given status. This filter will be ignored if any of the other
  // filters have been set.
  optional vega.events.v1.AMM.Status status = 5;
  // Pagination controls.
  optional Pagination pagination = 6;
}

message ListAMMsResponse {
  // Page of AMM data and corresponding page information.
  AMMConnection amms = 1;
}

message AMMConnection {
  // Page of AMM data and the corresponding cursors.
  repeated AMMEdge edges = 1;
  // Page information that is used for fetching further pages.
  PageInfo page_info = 2;
}

message AMMEdge {
  // AMM pool data.
  vega.events.v1.AMM node = 1;
  // Cursor that can be used to fetch further pages.
  string cursor = 2;
}

message EstimateAMMBoundsRequest {
  // Base price of the AMM pool, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string base_price = 1;
  // Upper price of the AMM pool, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  optional string upper_price = 2;
  // Lower price of the AMM pool, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  optional string lower_price = 3;
  // Leverage at the upper price of the AMM pool.
  optional string leverage_at_upper_price = 4;
  // Leverage at the lower price of the AMM pool.
  optional string leverage_at_lower_price = 5;
  // Amount of the asset that the party is willing to commit to the AMM pool.
  string commitment_amount = 6;
  // Market ID to estimate the AMM for.
  string market_id = 7;
}

message EstimateAMMBoundsResponse {
  // Theoretical volume at the top of the upper bound.
  string position_size_at_upper = 1;
  // Theoretical volume at the top of the lower bound.
  string position_size_at_lower = 2;
  // Loss of commitment at the upper bound.
  string loss_on_commitment_at_upper = 3;
  // Loss of commitment at the lower bound.
  string loss_on_commitment_at_lower = 4;
  // Estimated price above upper bound at which the commitment will be lost.
  string liquidation_price_at_upper = 5;
  // Estimated price below the lower bound at which the commitment will be lost.
  string liquidation_price_at_lower = 6;
}
