{
  "swagger": "2.0",
  "info": {
    "title": "proto/api/trading.proto",
    "version": "version not set"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/assets": {
      "get": {
        "summary": "Get a list of all assets on Vega.",
        "operationId": "Assets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiAssetsResponse"
            }
          }
        },
        "tags": [
          "trading_data"
        ]
      }
    },
    "/assets/{ID}": {
      "get": {
        "summary": "Get an asset by its identifier.",
        "operationId": "AssetByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiAssetByIDResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "ID",
            "description": "@exclude todo: Missing validator for required.\nAsset identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/assets/{asset}/infrastructureFeeAccount": {
      "get": {
        "summary": "Get the list of infrastructure fees accounts filter eventually by assets",
        "operationId": "FeeInfrastructureAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiFeeInfrastructureAccountsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "asset",
            "description": "Asset identifier. Required field.\nSet to an empty string to return all accounts.\nSet to an asset ID to return a single infrastructure fee account for a given asset.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/governance/proposals/prepare": {
      "post": {
        "summary": "Prepare a governance proposal",
        "operationId": "PrepareProposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPrepareProposalResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiPrepareProposalRequest"
            }
          }
        ],
        "tags": [
          "trading"
        ]
      }
    },
    "/markets": {
      "get": {
        "summary": "Get a list of Markets",
        "operationId": "Markets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarketsResponse"
            }
          }
        },
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets-data": {
      "get": {
        "summary": "Get a list of Market Data",
        "operationId": "MarketsData",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarketsDataResponse"
            }
          }
        },
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets-data/{marketID}": {
      "get": {
        "summary": "Get Market Data by MarketID",
        "operationId": "MarketDataByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarketDataByIDResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}": {
      "get": {
        "summary": "Get a Market by ID",
        "operationId": "MarketByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarketByIDResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/accounts": {
      "get": {
        "summary": "Get a list of Accounts by Market",
        "operationId": "MarketAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarketAccountsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "asset",
            "description": "Asset identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/candles": {
      "get": {
        "summary": "Get a list of Candles by Market",
        "operationId": "Candles",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiCandlesResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sinceTimestamp",
            "description": "Timestamp to retrieve candles since, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`. Required field.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "interval",
            "description": "Time interval for the candles. Required field.\n\n - INTERVAL_UNSPECIFIED: Default value, always invalid.\n - INTERVAL_I1M: 1 minute.\n - INTERVAL_I5M: 5 minutes.\n - INTERVAL_I15M: 15 minutes.\n - INTERVAL_I1H: 1 hour.\n - INTERVAL_I6H: 6 hours.\n - INTERVAL_I1D: 1 day.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "INTERVAL_UNSPECIFIED",
              "INTERVAL_I1M",
              "INTERVAL_I5M",
              "INTERVAL_I15M",
              "INTERVAL_I1H",
              "INTERVAL_I6H",
              "INTERVAL_I1D"
            ],
            "default": "INTERVAL_UNSPECIFIED"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/depth": {
      "get": {
        "summary": "Get Market Depth",
        "operationId": "MarketDepth",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarketDepthResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maxDepth",
            "description": "Max depth limits the number of levels returned. Default is 0, which returns all levels.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/orders": {
      "get": {
        "summary": "Get a list of Orders by Market",
        "operationId": "OrdersByMarket",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiOrdersByMarketResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.skip",
            "description": "Skip the number of records specified. Default is 0.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "Limit the number of returned records to the value specified. Default is 50.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.descending",
            "description": "Descending reverses the order of the records returned.\nDefault is true, if false the results will be returned in ascending order.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/orders/{orderID}": {
      "get": {
        "summary": "Get an Order by Market and OrderID",
        "operationId": "OrderByMarketAndID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiOrderByMarketAndIdResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "orderID",
            "description": "Order identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/trades": {
      "get": {
        "summary": "Get a list of Trades by Market",
        "operationId": "TradesByMarket",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiTradesByMarketResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.skip",
            "description": "Skip the number of records specified. Default is 0.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "Limit the number of returned records to the value specified. Default is 50.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.descending",
            "description": "Descending reverses the order of the records returned.\nDefault is true, if false the results will be returned in ascending order.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/markets/{marketID}/trades/latest": {
      "get": {
        "summary": "Get latest Trade",
        "operationId": "LastTrade",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiLastTradeResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "marketID",
            "description": "Market identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/orders/prepare/amend": {
      "post": {
        "summary": "Prepare an amend order request",
        "operationId": "PrepareAmendOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPrepareAmendOrderResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiAmendOrderRequest"
            }
          }
        ],
        "tags": [
          "trading"
        ]
      }
    },
    "/orders/prepare/cancel": {
      "post": {
        "summary": "Prepare a cancel order request",
        "operationId": "PrepareCancelOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPrepareCancelOrderResponse"
            }
          }
        },
        "tags": [
          "trading"
        ]
      }
    },
    "/orders/prepare/submit": {
      "post": {
        "summary": "Prepare a submit order request",
        "operationId": "PrepareSubmitOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPrepareSubmitOrderResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiSubmitOrderRequest"
            }
          }
        ],
        "tags": [
          "trading"
        ]
      }
    },
    "/orders/{orderID}/trades": {
      "get": {
        "summary": "Get a list of Trades by Order",
        "operationId": "TradesByOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiTradesByOrderResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "orderID",
            "description": "Order identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/orders/{orderID}/versions": {
      "get": {
        "summary": "Get all versions of the order by its orderID",
        "operationId": "OrderVersionsByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiOrderVersionsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "orderID",
            "description": "Order identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.skip",
            "description": "Skip the number of records specified. Default is 0.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "Limit the number of returned records to the value specified. Default is 50.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.descending",
            "description": "Descending reverses the order of the records returned.\nDefault is true, if false the results will be returned in ascending order.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/orders/{reference}": {
      "get": {
        "summary": "Get an Order by Pending Order reference (UUID)",
        "operationId": "OrderByReference",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiOrderByReferenceResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "reference",
            "description": "Unique reference. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties": {
      "get": {
        "summary": "Get a list of Parties",
        "operationId": "Parties",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPartiesResponse"
            }
          }
        },
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}": {
      "get": {
        "summary": "Get a Party by ID",
        "operationId": "PartyByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPartyByIDResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}/accounts": {
      "get": {
        "summary": "Get a list of Accounts by Party",
        "operationId": "PartyAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPartyAccountsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "marketID",
            "description": "Market identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "type",
            "description": "Account type. Required field.\n\n - ACCOUNT_TYPE_UNSPECIFIED: Default value.\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market.\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market.\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain margin funds for a party and each party will\nhave multiple margin accounts, one for each market they have traded in.\n\nMargin account funds will alter as margin requirements on positions change.\n - ACCOUNT_TYPE_GENERAL: General accounts contains general funds for a party. A party will\nhave multiple general accounts, one for each asset they want\nto trade with.\n\nGeneral accounts are where funds are initially deposited or withdrawn from.\nIt is also the account where funds are taken to fulfil fees and initial margin requirements.\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega.\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets.\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade.\nThese fees reward traders who provide the best priced liquidity that actually allows trading to take place.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "ACCOUNT_TYPE_UNSPECIFIED",
              "ACCOUNT_TYPE_INSURANCE",
              "ACCOUNT_TYPE_SETTLEMENT",
              "ACCOUNT_TYPE_MARGIN",
              "ACCOUNT_TYPE_GENERAL",
              "ACCOUNT_TYPE_FEES_INFRASTRUCTURE",
              "ACCOUNT_TYPE_FEES_LIQUIDITY",
              "ACCOUNT_TYPE_FEES_MAKER"
            ],
            "default": "ACCOUNT_TYPE_UNSPECIFIED"
          },
          {
            "name": "asset",
            "description": "Asset identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}/markets/{marketID}/margin": {
      "get": {
        "summary": "Get Margin Levels by PartyID",
        "operationId": "MarginLevels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiMarginLevelsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "marketID",
            "description": "Market identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}/orders": {
      "get": {
        "summary": "Get a list of Orders by Party",
        "operationId": "OrdersByParty",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiOrdersByPartyResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.skip",
            "description": "Skip the number of records specified. Default is 0.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "Limit the number of returned records to the value specified. Default is 50.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.descending",
            "description": "Descending reverses the order of the records returned.\nDefault is true, if false the results will be returned in ascending order.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}/positions": {
      "get": {
        "summary": "Get a list of Positions by Party",
        "operationId": "PositionsByParty",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiPositionsByPartyResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "marketID",
            "description": "Market identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}/proposals": {
      "get": {
        "summary": "Get governance data (proposals and votes) for proposals by party authoring them",
        "operationId": "GetProposalsByParty",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiGetProposalsByPartyResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "selectInState.value",
            "description": "Proposal state value.\n\n - STATE_UNSPECIFIED: Default value, always invalid.\n - STATE_FAILED: Proposal enactment has failed - even though proposal has passed, its execusion could not be performed.\n - STATE_OPEN: Proposal is open for voting.\n - STATE_PASSED: Proposal has gained enough support to be executed.\n - STATE_REJECTED: Proposal wasn't accepted (proposal terms failed validation due to wrong configuration or failing to meet network requirements).\n - STATE_DECLINED: Proposal didn't get enough votes (either failing to gain required participation or majority level).\n - STATE_WAITING_FOR_NODE_VOTE: waiting for validators validation of the proposal",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "STATE_UNSPECIFIED",
              "STATE_FAILED",
              "STATE_OPEN",
              "STATE_PASSED",
              "STATE_REJECTED",
              "STATE_DECLINED",
              "STATE_ENACTED",
              "STATE_WAITING_FOR_NODE_VOTE"
            ],
            "default": "STATE_UNSPECIFIED"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{partyID}/trades": {
      "get": {
        "summary": "Get a list of Trades by Party",
        "operationId": "TradesByParty",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiTradesByPartyResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "partyID",
            "description": "Party identifier. Required field.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "marketID",
            "description": "Market identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.skip",
            "description": "Skip the number of records specified. Default is 0.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "Limit the number of returned records to the value specified. Default is 50.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.descending",
            "description": "Descending reverses the order of the records returned.\nDefault is true, if false the results will be returned in ascending order.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "trading_data"
        ]
      }
    },
    "/parties/{withdraw.partyID}/withdrawals": {
      "post": {
        "summary": "Request a withdrawal",
        "operationId": "Withdraw",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiWithdrawResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "withdraw.partyID",
            "description": "Unique party identifier affecting the withdrawal.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiWithdrawRequest"
            }
          }
        ],
        "tags": [
          "trading"
        ]
      }
    },
    "/statistics": {
      "get": {
        "summary": "Get Statistics",
        "operationId": "Statistics",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/vegaStatistics"
            }
          }
        },
        "tags": [
          "trading_data"
        ]
      }
    },
    "/time": {
      "get": {
        "summary": "Get Time",
        "operationId": "GetVegaTime",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiVegaTimeResponse"
            }
          }
        },
        "tags": [
          "trading_data"
        ]
      }
    },
    "/transaction": {
      "post": {
        "summary": "Submit a signed transaction",
        "operationId": "SubmitTransaction",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiSubmitTransactionResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/apiSubmitTransactionRequest"
            }
          }
        ],
        "tags": [
          "trading"
        ]
      }
    }
  },
  "definitions": {
    "OrderStatus": {
      "type": "string",
      "enum": [
        "STATUS_INVALID",
        "STATUS_ACTIVE",
        "STATUS_EXPIRED",
        "STATUS_CANCELLED",
        "STATUS_STOPPED",
        "STATUS_FILLED",
        "STATUS_REJECTED",
        "STATUS_PARTIALLY_FILLED"
      ],
      "default": "STATUS_INVALID",
      "description": "Status values for an order.\nSee resulting status in [What order types are available to trade on Vega?](https://docs.vega.xyz/docs/trading-questions/#what-order-types-are-available-to-trade-on-vega) for more detail.\n\n - STATUS_INVALID: Default value, always invalid.\n - STATUS_ACTIVE: Used for active unfilled or partially filled orders.\n - STATUS_EXPIRED: Used for expired GTT orders.\n - STATUS_CANCELLED: Used for orders cancelled by the party that created the order.\n - STATUS_STOPPED: Used for unfilled FOK or IOC orders, and for orders that were stopped by the network.\n - STATUS_FILLED: Used for closed fully filled orders.\n - STATUS_REJECTED: Used for orders when not enough collateral was available to fill the margin requirements.\n - STATUS_PARTIALLY_FILLED: Used for closed partially filled IOC orders."
    },
    "OrderTimeInForce": {
      "type": "string",
      "enum": [
        "TIF_UNSPECIFIED",
        "TIF_GTC",
        "TIF_GTT",
        "TIF_IOC",
        "TIF_FOK",
        "TIF_GFA",
        "TIF_GFN"
      ],
      "default": "TIF_UNSPECIFIED",
      "description": "Time in Force for an order.\nSee [What order types are available to trade on Vega?](https://docs.vega.xyz/docs/trading-questions/#what-order-types-are-available-to-trade-on-vega) for more detail.\n\n - TIF_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend.\n - TIF_GTC: Good until cancelled.\n - TIF_GTT: Good until specified time.\n - TIF_IOC: Immediate or cancel.\n - TIF_FOK: Fill or kill.\n - TIF_GFA: good for auction\n - TIF_GFN: good for normal"
    },
    "ProposalState": {
      "type": "string",
      "enum": [
        "STATE_UNSPECIFIED",
        "STATE_FAILED",
        "STATE_OPEN",
        "STATE_PASSED",
        "STATE_REJECTED",
        "STATE_DECLINED",
        "STATE_ENACTED",
        "STATE_WAITING_FOR_NODE_VOTE"
      ],
      "default": "STATE_UNSPECIFIED",
      "description": "Proposal state transition:\nOpen -\u003e\n  - Passed -\u003e Enacted.\n  - Passed -\u003e Failed.\n  - Declined\nRejected\nProposal can enter Failed state from any other state.\n\n - STATE_UNSPECIFIED: Default value, always invalid.\n - STATE_FAILED: Proposal enactment has failed - even though proposal has passed, its execusion could not be performed.\n - STATE_OPEN: Proposal is open for voting.\n - STATE_PASSED: Proposal has gained enough support to be executed.\n - STATE_REJECTED: Proposal wasn't accepted (proposal terms failed validation due to wrong configuration or failing to meet network requirements).\n - STATE_DECLINED: Proposal didn't get enough votes (either failing to gain required participation or majority level).\n - STATE_WAITING_FOR_NODE_VOTE: waiting for validators validation of the proposal"
    },
    "VoteValue": {
      "type": "string",
      "enum": [
        "VALUE_UNSPECIFIED",
        "VALUE_NO",
        "VALUE_YES"
      ],
      "default": "VALUE_UNSPECIFIED",
      "description": " - VALUE_UNSPECIFIED: Default value, always invalid.\n - VALUE_NO: A vote against the proposal.\n - VALUE_YES: A vote in favour of the proposal."
    },
    "apiAmendOrderRequest": {
      "type": "object",
      "properties": {
        "amendment": {
          "$ref": "#/definitions/vegaOrderAmendment",
          "description": "An order amendment."
        }
      },
      "description": "Request to amend an existing order."
    },
    "apiAssetByIDResponse": {
      "type": "object",
      "properties": {
        "asset": {
          "$ref": "#/definitions/vegaAsset",
          "description": "An asset record, if found."
        }
      },
      "description": "Response for an asset given an asset identifier."
    },
    "apiAssetsResponse": {
      "type": "object",
      "properties": {
        "assets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaAsset"
          },
          "description": "A list of 0 or more assets."
        }
      },
      "description": "Response for a list of all assets enabled on Vega."
    },
    "apiCandlesResponse": {
      "type": "object",
      "properties": {
        "candles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaCandle"
          },
          "description": "A list of 0 or more candles."
        }
      },
      "description": "Response for a list of candles for a market at an interval."
    },
    "apiFeeInfrastructureAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaAccount"
          },
          "description": "A list of 0 or more infrastructure fee accounts."
        }
      },
      "description": "Response for a list of infrastructure fee accounts."
    },
    "apiGetNetworkParametersProposalsResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaGovernanceData"
          },
          "description": "A list of 0 or more governance data."
        }
      },
      "description": "Response for a list of network parameter proposals."
    },
    "apiGetNewAssetProposalsResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaGovernanceData"
          },
          "description": "A list of 0 or more governance data."
        }
      },
      "description": "Response for a list of new asset proposals."
    },
    "apiGetNewMarketProposalsResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaGovernanceData"
          },
          "description": "A list of 0 or more governance data."
        }
      },
      "description": "Response for a list of new market proposals."
    },
    "apiGetNodeSignaturesAggregateResponse": {
      "type": "object",
      "properties": {
        "signatures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaNodeSignature"
          },
          "description": "A list of 0 or more signatures."
        }
      },
      "description": "Response to specify the identifier of the resource we want to retrieve aggregated signatures for."
    },
    "apiGetProposalByIDResponse": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/vegaGovernanceData",
          "description": "Governance data, if found."
        }
      },
      "description": "Response for a governance proposal given a proposal identifier."
    },
    "apiGetProposalByReferenceResponse": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/vegaGovernanceData",
          "description": "Governance data, if found."
        }
      },
      "description": "Response for a governance proposal given a proposal reference."
    },
    "apiGetProposalsByPartyResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaGovernanceData"
          },
          "description": "A list of 0 or more governance data."
        }
      },
      "description": "Response for a list of proposals for a party."
    },
    "apiGetProposalsResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaGovernanceData"
          },
          "description": "A list of 0 or more governance data."
        }
      },
      "description": "Response for a list of proposals."
    },
    "apiGetUpdateMarketProposalsResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaGovernanceData"
          },
          "description": "A list of 0 or more governance data."
        }
      },
      "description": "Response for a list of update market proposals."
    },
    "apiGetVotesByPartyResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVote"
          },
          "description": "A list of 0 or more votes."
        }
      },
      "description": "Response for a list of votes for a party."
    },
    "apiLastTradeResponse": {
      "type": "object",
      "properties": {
        "trade": {
          "$ref": "#/definitions/vegaTrade",
          "description": "A trade, if found."
        }
      },
      "description": "Response for the latest trade that occurred on Vega for a given market."
    },
    "apiMarginLevelsResponse": {
      "type": "object",
      "properties": {
        "marginLevels": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaMarginLevels"
          },
          "description": "A list of 0 or more margin levels."
        }
      },
      "description": "Response for margin levels for a party."
    },
    "apiMarketAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaAccount"
          },
          "description": "A list of 0 or more accounts."
        }
      },
      "description": "Response for a list of accounts for a market."
    },
    "apiMarketByIDResponse": {
      "type": "object",
      "properties": {
        "market": {
          "$ref": "#/definitions/vegaMarket",
          "description": "A market, if found."
        }
      },
      "description": "Response for a market given a market identifier."
    },
    "apiMarketDataByIDResponse": {
      "type": "object",
      "properties": {
        "marketData": {
          "$ref": "#/definitions/vegaMarketData",
          "description": "Market data, if found."
        }
      },
      "description": "Response for market data for a market."
    },
    "apiMarketDepthResponse": {
      "type": "object",
      "properties": {
        "marketID": {
          "type": "string",
          "description": "Market identifier."
        },
        "buy": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPriceLevel"
          },
          "description": "Zero or more price levels for the buy side of the market depth data."
        },
        "sell": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPriceLevel"
          },
          "description": "Zero or more price levels for the sell side of the market depth data."
        },
        "lastTrade": {
          "$ref": "#/definitions/vegaTrade",
          "description": "Last trade recorded on Vega at the time of retrieving the `MarketDepthResponse`."
        }
      },
      "description": "Response for the market depth/order book price levels on a market."
    },
    "apiMarketsDataResponse": {
      "type": "object",
      "properties": {
        "marketsData": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaMarketData"
          },
          "description": "A list of 0 or more market data."
        }
      },
      "description": "Response for market data."
    },
    "apiMarketsResponse": {
      "type": "object",
      "properties": {
        "markets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaMarket"
          },
          "description": "A list of 0 or more markets."
        }
      },
      "description": "Response for a list of markets on Vega."
    },
    "apiOptionalProposalState": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/ProposalState",
          "description": "Proposal state value."
        }
      },
      "description": "Optional proposal state."
    },
    "apiOrderByMarketAndIdResponse": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/vegaOrder",
          "description": "An order, if found."
        }
      },
      "description": "Response for an order on a market given an order identifier."
    },
    "apiOrderByReferenceResponse": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/vegaOrder",
          "description": "An order, if found."
        }
      },
      "description": "Response for an order given an order reference."
    },
    "apiOrderVersionsResponse": {
      "type": "object",
      "properties": {
        "orders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaOrder"
          },
          "description": "A list of 0 or more orders (list will contain the same order but with different versions, if it has been amended)."
        }
      },
      "description": "Response to a request for a list of all versions of an order."
    },
    "apiOrdersByMarketResponse": {
      "type": "object",
      "properties": {
        "orders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaOrder"
          },
          "description": "A list of 0 or more orders."
        }
      },
      "description": "Response for a list of orders for a market."
    },
    "apiOrdersByPartyResponse": {
      "type": "object",
      "properties": {
        "orders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaOrder"
          },
          "description": "A list of 0 or more orders."
        }
      },
      "description": "Response for a list of orders for a party."
    },
    "apiOrdersStream": {
      "type": "object",
      "properties": {
        "orders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaOrder"
          },
          "description": "A list of 0 or more orders."
        }
      },
      "description": "A stream of orders."
    },
    "apiPagination": {
      "type": "object",
      "properties": {
        "skip": {
          "type": "string",
          "format": "uint64",
          "description": "Skip the number of records specified. Default is 0."
        },
        "limit": {
          "type": "string",
          "format": "uint64",
          "description": "Limit the number of returned records to the value specified. Default is 50."
        },
        "descending": {
          "type": "boolean",
          "format": "boolean",
          "description": "Descending reverses the order of the records returned.\nDefault is true, if false the results will be returned in ascending order."
        }
      },
      "description": "Pagination controls."
    },
    "apiPartiesResponse": {
      "type": "object",
      "properties": {
        "parties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaParty"
          },
          "description": "A list of 0 or more parties."
        }
      },
      "description": "Response to a request for a list of parties."
    },
    "apiPartyAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaAccount"
          },
          "description": "A list of 0 or more accounts."
        }
      },
      "description": "Response for a list of accounts for a party."
    },
    "apiPartyByIDResponse": {
      "type": "object",
      "properties": {
        "party": {
          "$ref": "#/definitions/vegaParty",
          "description": "A party, if found."
        }
      },
      "description": "Response for a party given a party identifier."
    },
    "apiPositionsByPartyResponse": {
      "type": "object",
      "properties": {
        "positions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPosition"
          },
          "description": "A list of 0 or more positions."
        }
      },
      "description": "Response for a list of positions for a party."
    },
    "apiPrepareAmendOrderResponse": {
      "type": "object",
      "properties": {
        "blob": {
          "type": "string",
          "format": "byte",
          "description": "blob is an encoded representation of the order amendment ready to sign using the Vega Wallet and then submit as a transaction."
        }
      },
      "description": "Response for preparing an order amendment."
    },
    "apiPrepareCancelOrderResponse": {
      "type": "object",
      "properties": {
        "blob": {
          "type": "string",
          "format": "byte",
          "description": "blob is an encoded representation of the order cancellation ready to sign using the Vega Wallet and then submit as a transaction."
        }
      },
      "description": "Response for preparing an order cancellation."
    },
    "apiPrepareProposalRequest": {
      "type": "object",
      "properties": {
        "partyID": {
          "type": "string",
          "description": "Party identifier. Required field."
        },
        "reference": {
          "type": "string",
          "description": "Unique reference."
        },
        "proposal": {
          "$ref": "#/definitions/vegaProposalTerms",
          "description": "Proposal terms. Required field."
        }
      },
      "description": "Request to prepare a governance proposal."
    },
    "apiPrepareProposalResponse": {
      "type": "object",
      "properties": {
        "blob": {
          "type": "string",
          "format": "byte",
          "description": "blob is an encoded representation of the proposal ready to sign using the Vega Wallet and then submit as a transaction."
        },
        "pendingProposal": {
          "$ref": "#/definitions/vegaProposal",
          "description": "A copy of the prepared proposal."
        }
      },
      "description": "Response to prepare a governance proposal."
    },
    "apiPrepareSubmitOrderResponse": {
      "type": "object",
      "properties": {
        "blob": {
          "type": "string",
          "format": "byte",
          "description": "blob is an encoded representation of the order submission ready to sign using the Vega Wallet and then submit as a transaction."
        },
        "submitID": {
          "type": "string",
          "description": "Submission identifier (order reference)."
        }
      },
      "description": "Response for preparing an order submission."
    },
    "apiPrepareVoteResponse": {
      "type": "object",
      "properties": {
        "blob": {
          "type": "string",
          "format": "byte",
          "description": "blob is an encoded representation of the vote ready to sign using the Vega Wallet and then submit as a transaction."
        },
        "vote": {
          "$ref": "#/definitions/vegaVote",
          "description": "A copy of the prepared vote."
        }
      },
      "description": "Response to prepare a governance vote."
    },
    "apiPropagateChainEventResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "format": "boolean",
          "description": "Success will be true if the event was accepted by the node.\nImportant - success does not mean that the event is confirmed by consensus."
        }
      },
      "description": "Response for a new event sent by the blockchain queue to be propagated on Vega."
    },
    "apiSubmitOrderRequest": {
      "type": "object",
      "properties": {
        "submission": {
          "$ref": "#/definitions/vegaOrderSubmission",
          "description": "An order submission."
        }
      },
      "description": "Request to submit a new order."
    },
    "apiSubmitTransactionRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/vegaSignedBundle",
          "description": "A bundle of signed payload and signature, to form a transaction that will be submitted to the Vega blockchain."
        }
      },
      "description": "Request for submitting a transaction on Vega."
    },
    "apiSubmitTransactionResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "format": "boolean",
          "description": "Success will be true if the transaction was accepted by the node.\nImportant - success does not mean that the transaction is confirmed by consensus."
        }
      },
      "description": "Response for submitting a transaction on Vega."
    },
    "apiTradesByMarketResponse": {
      "type": "object",
      "properties": {
        "trades": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaTrade"
          },
          "description": "A list of 0 or more trades."
        }
      },
      "description": "Response for a list of trades on a market."
    },
    "apiTradesByOrderResponse": {
      "type": "object",
      "properties": {
        "trades": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaTrade"
          },
          "description": "A list of 0 or more trades."
        }
      },
      "description": "Response for a list of trades related to an order."
    },
    "apiTradesByPartyResponse": {
      "type": "object",
      "properties": {
        "trades": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaTrade"
          },
          "description": "A list of 0 or more trades."
        }
      },
      "description": "Response for a list of trades relating to a party."
    },
    "apiTradesStream": {
      "type": "object",
      "properties": {
        "trades": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaTrade"
          },
          "description": "A list of 0 or more trades."
        }
      },
      "description": "A stream of trades."
    },
    "apiVegaTimeResponse": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp representation of current VegaTime.\nNanoseconds since the epoch, for example `1580473859111222333` corresponds to `2020-01-31T12:30:59.111222333Z`"
        }
      },
      "description": "Response for the current consensus coordinated time on the Vega network, referred to as \"VegaTime\"."
    },
    "apiWithdrawRequest": {
      "type": "object",
      "properties": {
        "withdraw": {
          "$ref": "#/definitions/vegaWithdraw",
          "description": "Withdrawal details."
        }
      },
      "description": "Request for withdrawing assets on Vega."
    },
    "apiWithdrawResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "format": "boolean",
          "description": "Success will be true if the withdrawal request was accepted by the node.\nImportant - success does not mean that the withdrawal is confirmed by consensus."
        }
      },
      "description": "Response for withdrawing assets on Vega."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "runtimeStreamError": {
      "type": "object",
      "properties": {
        "grpc_code": {
          "type": "integer",
          "format": "int32"
        },
        "http_code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "http_status": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "vegaAccount": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique account identifier (used internally by Vega)."
        },
        "owner": {
          "type": "string",
          "description": "The party that the account belongs to. Special values include `network`, which represents the Vega network and is\nmost commonly seen during liquidation of distressed trading positions."
        },
        "balance": {
          "type": "string",
          "format": "uint64",
          "description": "Balance of the asset, the balance is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places. Balances cannot be negative."
        },
        "asset": {
          "type": "string",
          "description": "Asset identifier for the account."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier for the account. If [`AccountType`](#vega.AccountType).`ACCOUNT_TYPE_GENERAL` this will be empty."
        },
        "type": {
          "$ref": "#/definitions/vegaAccountType",
          "description": "The account type related to this account."
        }
      },
      "description": "Represents an account for an asset on Vega for a particular owner or party."
    },
    "vegaAccountType": {
      "type": "string",
      "enum": [
        "ACCOUNT_TYPE_UNSPECIFIED",
        "ACCOUNT_TYPE_INSURANCE",
        "ACCOUNT_TYPE_SETTLEMENT",
        "ACCOUNT_TYPE_MARGIN",
        "ACCOUNT_TYPE_GENERAL",
        "ACCOUNT_TYPE_FEES_INFRASTRUCTURE",
        "ACCOUNT_TYPE_FEES_LIQUIDITY",
        "ACCOUNT_TYPE_FEES_MAKER"
      ],
      "default": "ACCOUNT_TYPE_UNSPECIFIED",
      "description": "Various collateral/account types as used by Vega.\n\n - ACCOUNT_TYPE_UNSPECIFIED: Default value.\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market.\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market.\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain margin funds for a party and each party will\nhave multiple margin accounts, one for each market they have traded in.\n\nMargin account funds will alter as margin requirements on positions change.\n - ACCOUNT_TYPE_GENERAL: General accounts contains general funds for a party. A party will\nhave multiple general accounts, one for each asset they want\nto trade with.\n\nGeneral accounts are where funds are initially deposited or withdrawn from.\nIt is also the account where funds are taken to fulfil fees and initial margin requirements.\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega.\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets.\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade.\nThese fees reward traders who provide the best priced liquidity that actually allows trading to take place."
    },
    "vegaAddValidator": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/vegaIdentifier",
          "title": "The identifier of this validator"
        }
      },
      "title": "A message to notify a new validator being added to the vega network"
    },
    "vegaAsset": {
      "type": "object",
      "properties": {
        "ID": {
          "type": "string",
          "title": "The vega internal ID of the asset"
        },
        "name": {
          "type": "string",
          "title": "The name of the asset (e.g: Great British Pound)"
        },
        "symbol": {
          "type": "string",
          "title": "The symbol of the asset (e.g: GBP)"
        },
        "totalSupply": {
          "type": "string",
          "title": "The total circulating supply for the asset"
        },
        "decimals": {
          "type": "string",
          "format": "uint64",
          "title": "The number of decimal / precision handled by this asset"
        },
        "source": {
          "$ref": "#/definitions/vegaAssetSource",
          "title": "The definition of the external source for this asset"
        }
      },
      "title": "The vega representation of an external asset"
    },
    "vegaAssetSource": {
      "type": "object",
      "properties": {
        "builtinAsset": {
          "$ref": "#/definitions/vegaBuiltinAsset"
        },
        "erc20": {
          "$ref": "#/definitions/vegaERC20"
        }
      }
    },
    "vegaAuctionDuration": {
      "type": "object",
      "properties": {
        "duration": {
          "type": "string",
          "format": "int64"
        },
        "volume": {
          "type": "string",
          "format": "uint64"
        }
      },
      "title": "AuctionDuration can be used to configure 3 auction periods:\n1) duration \u003e 0, volume == 0: The auction will last for at least N seconds\n2) Duration == 0, volume \u003e 0: Auction period will end once we can close with given traded volume\n3) Duration \u003e 0 \u0026 volume \u003e 0: Auction period will take at least N seconds, but can end sooner if we can trade a certain volume"
    },
    "vegaBTCDeposit": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "The vega network internally ID of the asset"
        },
        "sourceBTCAddress": {
          "type": "string",
          "title": "The BTC wallet inititing the Deposit"
        },
        "targetPartyId": {
          "type": "string",
          "title": "The Vega public key of the target Vega user"
        }
      },
      "title": "A Bitcoin deposit into vega"
    },
    "vegaBTCEvent": {
      "type": "object",
      "properties": {
        "index": {
          "type": "string",
          "format": "uint64",
          "title": "The index of the transaction"
        },
        "block": {
          "type": "string",
          "format": "uint64",
          "title": "The block in which the transaction happenned"
        },
        "deposit": {
          "$ref": "#/definitions/vegaBTCDeposit"
        },
        "withdrawal": {
          "$ref": "#/definitions/vegaBTCWithdrawal"
        }
      },
      "title": "An event from Bitcoin"
    },
    "vegaBTCWithdrawal": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "The vega network internally ID of the asset"
        },
        "sourcePartyId": {
          "type": "string",
          "title": "The party inititing the withdrawal"
        },
        "targetBTCAddress": {
          "type": "string",
          "title": "Target BTC wallet address"
        },
        "referenceNonce": {
          "type": "string",
          "title": "The nonce reference of the transaction"
        }
      },
      "title": "A Bitcoin withdrawl from vega"
    },
    "vegaBitcoinAddress": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "title": "A Bitcoin address"
        }
      },
      "title": "Wrapper for a Bitcoin address (wallet)"
    },
    "vegaBuiltinAsset": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "The name of the asset (e.g: Great British Pound)"
        },
        "symbol": {
          "type": "string",
          "title": "The symbol of the asset (e.g: GBP)"
        },
        "totalSupply": {
          "type": "string",
          "title": "The total circulating supply for the asset"
        },
        "decimals": {
          "type": "string",
          "format": "uint64",
          "title": "The number of decimal / precision handled by this asset"
        },
        "maxFaucetAmountMint": {
          "type": "string",
          "title": "This is the maximum amount that can be requested by a party through the builtin asset faucet at a time"
        }
      },
      "title": "A vega internal asset"
    },
    "vegaBuiltinAssetDeposit": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "A vega network internal asset ID"
        },
        "partyID": {
          "type": "string",
          "title": "A vega party ID (pubkey)"
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "title": "The amount to be deposited"
        }
      },
      "title": "A deposit for an vega builtin asset"
    },
    "vegaBuiltinAssetEvent": {
      "type": "object",
      "properties": {
        "deposit": {
          "$ref": "#/definitions/vegaBuiltinAssetDeposit"
        },
        "withdrawal": {
          "$ref": "#/definitions/vegaBuiltinAssetWithdrawal"
        }
      },
      "title": "An event related to a vega builtin asset"
    },
    "vegaBuiltinAssetWithdrawal": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "A vega network internal asset ID"
        },
        "partyID": {
          "type": "string",
          "title": "A vega network party ID (pubkey)"
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "title": "The amount to be withdrawan"
        }
      },
      "title": "A Withdrawal for a vega builtin asset"
    },
    "vegaCandle": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for the point in time when the candle was initially created/opened, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        },
        "datetime": {
          "type": "string",
          "description": "An ISO-8601 datetime with nanosecond precision for when the candle was last updated."
        },
        "high": {
          "type": "string",
          "format": "uint64",
          "description": "Highest price for trading during the candle interval."
        },
        "low": {
          "type": "string",
          "format": "uint64",
          "description": "Lowest price for trading during the candle interval."
        },
        "open": {
          "type": "string",
          "format": "uint64",
          "description": "Open trade price."
        },
        "close": {
          "type": "string",
          "format": "uint64",
          "description": "Closing trade price."
        },
        "volume": {
          "type": "string",
          "format": "uint64",
          "description": "Total trading volume during the candle interval."
        },
        "interval": {
          "$ref": "#/definitions/vegaInterval",
          "description": "Time interval for the candle. See [`Interval`](#vega.Interval)."
        }
      },
      "description": "Represents the high, low, open, and closing prices for an interval of trading,\nreferred to commonly as a candlestick or candle."
    },
    "vegaChainEvent": {
      "type": "object",
      "properties": {
        "txID": {
          "type": "string",
          "title": "The ID of the transaction in which the things happened\nusually a hash"
        },
        "nonce": {
          "type": "string",
          "format": "uint64",
          "title": "Arbitrary one-time integer used to prevent replay attacks"
        },
        "builtin": {
          "$ref": "#/definitions/vegaBuiltinAssetEvent"
        },
        "erc20": {
          "$ref": "#/definitions/vegaERC20Event"
        },
        "btc": {
          "$ref": "#/definitions/vegaBTCEvent"
        },
        "validator": {
          "$ref": "#/definitions/vegaValidatorEvent"
        }
      },
      "title": "An event being forwarded to the vega network\nproviding information on things happening on other networks"
    },
    "vegaChainStatus": {
      "type": "string",
      "enum": [
        "CHAIN_STATUS_UNSPECIFIED",
        "CHAIN_STATUS_DISCONNECTED",
        "CHAIN_STATUS_REPLAYING",
        "CHAIN_STATUS_CONNECTED"
      ],
      "default": "CHAIN_STATUS_UNSPECIFIED",
      "description": "The Vega blockchain status as reported by the node the caller is connected to.\n\n - CHAIN_STATUS_UNSPECIFIED: Default value, always invalid.\n - CHAIN_STATUS_DISCONNECTED: Blockchain is disconnected.\n - CHAIN_STATUS_REPLAYING: Blockchain is replaying historic transactions.\n - CHAIN_STATUS_CONNECTED: Blockchain is connected and receiving transactions."
    },
    "vegaContinuousTrading": {
      "type": "object",
      "properties": {
        "tickSize": {
          "type": "string"
        }
      }
    },
    "vegaDiscreteTrading": {
      "type": "object",
      "properties": {
        "durationNs": {
          "type": "string",
          "format": "int64",
          "title": "Duration in nanoseconds, maximum 1 month (2592000000000000 ns)"
        },
        "tickSize": {
          "type": "string"
        }
      }
    },
    "vegaERC20": {
      "type": "object",
      "properties": {
        "contractAddress": {
          "type": "string",
          "title": "The address of the contract for the token, on the ethereum network"
        }
      },
      "title": "An ERC20 token based asset, living on the ethereum network"
    },
    "vegaERC20AssetDelist": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "The vega network internally ID of the asset"
        }
      },
      "title": "An asset blacklisting for a erc20 token"
    },
    "vegaERC20AssetList": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "The vega network internally ID of the asset"
        }
      },
      "title": "An asset whitelisting for a erc20 token"
    },
    "vegaERC20Deposit": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "The vega network internally ID of the asset"
        },
        "sourceEthereumAddress": {
          "type": "string",
          "title": "The ethereum wallet that initiated the deposit"
        },
        "targetPartyID": {
          "type": "string",
          "title": "The Vega public key of the target vega user"
        }
      },
      "title": "An asset deposit for an erc20 token"
    },
    "vegaERC20Event": {
      "type": "object",
      "properties": {
        "index": {
          "type": "string",
          "format": "uint64",
          "title": "Index of the transaction"
        },
        "block": {
          "type": "string",
          "format": "uint64",
          "title": "The block in which the transaction was added"
        },
        "assetList": {
          "$ref": "#/definitions/vegaERC20AssetList"
        },
        "assetDelist": {
          "$ref": "#/definitions/vegaERC20AssetDelist"
        },
        "deposit": {
          "$ref": "#/definitions/vegaERC20Deposit"
        },
        "withdrawal": {
          "$ref": "#/definitions/vegaERC20Withdrawal"
        }
      },
      "title": "An event related to an erc20 token"
    },
    "vegaERC20Withdrawal": {
      "type": "object",
      "properties": {
        "vegaAssetID": {
          "type": "string",
          "title": "The vega network internally ID of the asset"
        },
        "sourcePartyId": {
          "type": "string",
          "title": "The party inititing the withdrawal"
        },
        "targetEthereumAddress": {
          "type": "string",
          "title": "The target Ethereum wallet address"
        },
        "referenceNonce": {
          "type": "string",
          "title": "The reference nonce used for the transaction"
        }
      },
      "title": "An asset withdrawal for an erc20 token"
    },
    "vegaEthereumAddress": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "title": "An Ethereum address"
        }
      },
      "title": "Wrapper for an Ethereum address (wallet/contract)"
    },
    "vegaEthereumEvent": {
      "type": "object",
      "properties": {
        "contractID": {
          "type": "string"
        },
        "event": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "uint64"
        }
      }
    },
    "vegaExternalRiskModel": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "socket": {
          "type": "string"
        },
        "config": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vegaFee": {
      "type": "object",
      "properties": {
        "makerFee": {
          "type": "string",
          "format": "uint64",
          "description": "Fee amount paid to the non-aggressive party of the trade."
        },
        "infrastructureFee": {
          "type": "string",
          "format": "uint64",
          "description": "Fee amount paid for maintaining the Vega infrastructure."
        },
        "liquidityFee": {
          "type": "string",
          "format": "uint64",
          "description": "Fee amount paid to market makers."
        }
      },
      "description": "Represents any fees paid by a party, resulting from a trade."
    },
    "vegaFeeFactors": {
      "type": "object",
      "properties": {
        "makerFee": {
          "type": "string"
        },
        "infrastructureFee": {
          "type": "string"
        },
        "liquidityFee": {
          "type": "string"
        }
      }
    },
    "vegaFeeFactorsConfiguration": {
      "type": "object",
      "properties": {
        "infrastructureFee": {
          "type": "string",
          "title": "the infrastructure fee, needs to be a valid float"
        },
        "makerFee": {
          "type": "string",
          "title": "the maker fee, needs to be a valid float"
        },
        "liquidityFee": {
          "type": "string",
          "title": "this is the liquidity fee, it needs to be a valid float"
        }
      },
      "title": "FeeFactors set at the network level"
    },
    "vegaFees": {
      "type": "object",
      "properties": {
        "factors": {
          "$ref": "#/definitions/vegaFeeFactors"
        }
      }
    },
    "vegaFuture": {
      "type": "object",
      "properties": {
        "maturity": {
          "type": "string"
        },
        "asset": {
          "type": "string"
        },
        "ethereumEvent": {
          "$ref": "#/definitions/vegaEthereumEvent"
        }
      }
    },
    "vegaFutureProduct": {
      "type": "object",
      "properties": {
        "maturity": {
          "type": "string",
          "title": "Future product maturity (ISO8601/RFC3339 timestamp)"
        },
        "asset": {
          "type": "string",
          "title": "Product asset name"
        }
      },
      "title": "Future product configuration"
    },
    "vegaGovernanceData": {
      "type": "object",
      "properties": {
        "proposal": {
          "$ref": "#/definitions/vegaProposal",
          "title": "Proposal"
        },
        "yes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVote"
          },
          "description": "All \"yes\" votes in favour of the proposal above."
        },
        "no": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVote"
          },
          "description": "All \"no\" votes against the proposal above."
        },
        "yesParty": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vegaVote"
          },
          "title": "All latest YES votes by party (guaranteed to be unique)"
        },
        "noParty": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vegaVote"
          },
          "title": "All latest NO votes by party (unique)"
        }
      }
    },
    "vegaIdentifier": {
      "type": "object",
      "properties": {
        "ethereumAddress": {
          "$ref": "#/definitions/vegaEthereumAddress"
        },
        "bitcoinAddress": {
          "$ref": "#/definitions/vegaBitcoinAddress"
        }
      },
      "title": "A wrapper type on any possible network address supported by vega"
    },
    "vegaInstrument": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "code": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "baseName": {
          "type": "string"
        },
        "quoteName": {
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/vegaInstrumentMetadata"
        },
        "initialMarkPrice": {
          "type": "string",
          "format": "uint64"
        },
        "future": {
          "$ref": "#/definitions/vegaFuture"
        }
      }
    },
    "vegaInstrumentConfiguration": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Instrument name"
        },
        "code": {
          "type": "string",
          "title": "Instrument code"
        },
        "baseName": {
          "type": "string",
          "title": "Base security used as the reference"
        },
        "quoteName": {
          "type": "string",
          "title": "Quote (secondary) security"
        },
        "future": {
          "$ref": "#/definitions/vegaFutureProduct"
        }
      }
    },
    "vegaInstrumentMetadata": {
      "type": "object",
      "properties": {
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "vegaInterval": {
      "type": "string",
      "enum": [
        "INTERVAL_UNSPECIFIED",
        "INTERVAL_I1M",
        "INTERVAL_I5M",
        "INTERVAL_I15M",
        "INTERVAL_I1H",
        "INTERVAL_I6H",
        "INTERVAL_I1D"
      ],
      "default": "INTERVAL_UNSPECIFIED",
      "description": "Represents a set of time intervals that are used when querying for candle-stick data.\n\n - INTERVAL_UNSPECIFIED: Default value, always invalid.\n - INTERVAL_I1M: 1 minute.\n - INTERVAL_I5M: 5 minutes.\n - INTERVAL_I15M: 15 minutes.\n - INTERVAL_I1H: 1 hour.\n - INTERVAL_I6H: 6 hours.\n - INTERVAL_I1D: 1 day."
    },
    "vegaLedgerEntry": {
      "type": "object",
      "properties": {
        "fromAccount": {
          "type": "string",
          "description": "One or more accounts to transfer from."
        },
        "toAccount": {
          "type": "string",
          "description": "One or more accounts to transfer to."
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "description": "An amount to transfer."
        },
        "reference": {
          "type": "string",
          "description": "A reference for auditing purposes."
        },
        "type": {
          "type": "string",
          "description": "Type of ledger entry."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for the time the ledger entry was created, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        }
      },
      "description": "Represents a ledger entry on Vega."
    },
    "vegaLogNormalModelParams": {
      "type": "object",
      "properties": {
        "mu": {
          "type": "number",
          "format": "double"
        },
        "r": {
          "type": "number",
          "format": "double"
        },
        "sigma": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "vegaLogNormalRiskModel": {
      "type": "object",
      "properties": {
        "riskAversionParameter": {
          "type": "number",
          "format": "double"
        },
        "tau": {
          "type": "number",
          "format": "double"
        },
        "params": {
          "$ref": "#/definitions/vegaLogNormalModelParams"
        }
      }
    },
    "vegaMarginCalculator": {
      "type": "object",
      "properties": {
        "scalingFactors": {
          "$ref": "#/definitions/vegaScalingFactors"
        }
      }
    },
    "vegaMarginLevels": {
      "type": "object",
      "properties": {
        "maintenanceMargin": {
          "type": "string",
          "format": "uint64",
          "description": "Maintenance margin value."
        },
        "searchLevel": {
          "type": "string",
          "format": "uint64",
          "description": "Search level value."
        },
        "initialMargin": {
          "type": "string",
          "format": "uint64",
          "description": "Initial margin value."
        },
        "collateralReleaseLevel": {
          "type": "string",
          "format": "uint64",
          "description": "Collateral release level value."
        },
        "partyID": {
          "type": "string",
          "description": "Party identifier."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier."
        },
        "asset": {
          "type": "string",
          "description": "Asset identifier."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for the time the ledger entry was created, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        }
      },
      "description": "Represents the margin levels for a party on a market at a given time."
    },
    "vegaMarket": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "tradableInstrument": {
          "$ref": "#/definitions/vegaTradableInstrument"
        },
        "decimalPlaces": {
          "type": "string",
          "format": "uint64",
          "title": "the number of decimal places that a price must be shifted by in order to get a correct price denominated in the currency of the Market. ie `realPrice = price / 10^decimalPlaces`"
        },
        "fees": {
          "$ref": "#/definitions/vegaFees",
          "title": "fees configuration"
        },
        "openingAuction": {
          "$ref": "#/definitions/vegaAuctionDuration",
          "title": "Specifies how long the opening auction will run (min duration + optionally minimum traded volume)"
        },
        "continuous": {
          "$ref": "#/definitions/vegaContinuousTrading"
        },
        "discrete": {
          "$ref": "#/definitions/vegaDiscreteTrading"
        }
      }
    },
    "vegaMarketData": {
      "type": "object",
      "properties": {
        "markPrice": {
          "type": "string",
          "format": "uint64",
          "description": "Mark price, as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "bestBidPrice": {
          "type": "string",
          "format": "uint64",
          "description": "Highest price level on an order book for buy orders, as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "bestBidVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Aggregated volume being bid at the best bid price."
        },
        "bestOfferPrice": {
          "type": "string",
          "format": "uint64",
          "description": "Lowest price level on an order book for offer orders."
        },
        "bestOfferVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Aggregated volume being offered at the best offer price, as an integer, for example `123456` is a correctly\n // formatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "midPrice": {
          "type": "string",
          "format": "uint64",
          "description": "Arithmetic average of the best bid price and best offer price, as an integer, for example `123456` is a correctly\n // formatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "market": {
          "type": "string",
          "description": "Market identifier for the data."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp at which this mark price was relevant, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        },
        "openInterest": {
          "type": "string",
          "format": "uint64",
          "description": "The sum of the size of all positions greater than 0 on the market."
        },
        "auctionEnd": {
          "type": "string",
          "format": "int64",
          "description": "Time in seconds until the end of the auction (0 if currently not in auction period)."
        },
        "auctionStart": {
          "type": "string",
          "format": "int64",
          "description": "Time until next auction (used in FBA's) - currently always 0."
        }
      },
      "description": "Represents data generated by a market when open."
    },
    "vegaMarketDepth": {
      "type": "object",
      "properties": {
        "marketID": {
          "type": "string",
          "description": "Market identifier."
        },
        "buy": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPriceLevel"
          },
          "description": "Collection of price levels for the buy side of the book."
        },
        "sell": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPriceLevel"
          },
          "description": "Collection of price levels for the sell side of the book."
        }
      },
      "description": "Represents market depth or order book data for the specified market on Vega."
    },
    "vegaNetworkConfiguration": {
      "type": "object",
      "properties": {
        "minCloseInSeconds": {
          "type": "string",
          "format": "int64",
          "description": "Constrains minimum duration since submission (in seconds) when vote closing time is allowed to be set for a proposal."
        },
        "maxCloseInSeconds": {
          "type": "string",
          "format": "int64",
          "description": "Constrains maximum duration since submission (in seconds) when vote closing time is allowed to be set for a proposal."
        },
        "minEnactInSeconds": {
          "type": "string",
          "format": "int64",
          "description": "Constrains minimum duration since submission (in seconds) when enactment is allowed to be set for a proposal."
        },
        "maxEnactInSeconds": {
          "type": "string",
          "format": "int64",
          "description": "Constrains maximum duration since submission (in seconds) when enactment is allowed to be set for a proposal."
        },
        "requiredParticipation": {
          "type": "number",
          "format": "float",
          "description": "Participation level required for any proposal to pass. Value from `0` to `1`."
        },
        "requiredMajority": {
          "type": "number",
          "format": "float",
          "description": "Majority level required for any proposal to pass. Value from `0.5` to `1`."
        },
        "minProposerBalance": {
          "type": "number",
          "format": "float",
          "description": "Minimum balance required for a party to be able to submit a new proposal. Value greater than `0` to `1`."
        },
        "minVoterBalance": {
          "type": "number",
          "format": "float",
          "description": "Minimum balance required for a party to be able to cast a vote. Value greater than `0` to `1`."
        },
        "marginConfiguration": {
          "$ref": "#/definitions/vegaScalingFactors",
          "description": "Scaling factors for all markets created via governance."
        },
        "feeFactorsConfiguration": {
          "$ref": "#/definitions/vegaFeeFactorsConfiguration",
          "title": "FeeFactors which are not set via proposal"
        }
      }
    },
    "vegaNewAsset": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaAssetSource"
        }
      },
      "title": "To be implemented"
    },
    "vegaNewMarket": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaNewMarketConfiguration"
        }
      }
    },
    "vegaNewMarketConfiguration": {
      "type": "object",
      "properties": {
        "instrument": {
          "$ref": "#/definitions/vegaInstrumentConfiguration",
          "title": "New market instrument configuration"
        },
        "decimalPlaces": {
          "type": "string",
          "format": "uint64",
          "title": "Decimal places used for the new market"
        },
        "metadata": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional new market meta data, tags"
        },
        "openingAuctionDuration": {
          "type": "string",
          "format": "int64",
          "title": "for now, just specify a time for the opening auction to last"
        },
        "simple": {
          "$ref": "#/definitions/vegaSimpleModelParams",
          "title": "Simple risk model parameters, valid only if MODEL_SIMPLE is selected"
        },
        "logNormal": {
          "$ref": "#/definitions/vegaLogNormalRiskModel",
          "title": "Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected"
        },
        "continuous": {
          "$ref": "#/definitions/vegaContinuousTrading"
        },
        "discrete": {
          "$ref": "#/definitions/vegaDiscreteTrading"
        }
      }
    },
    "vegaNodeSignature": {
      "type": "object",
      "properties": {
        "ID": {
          "type": "string",
          "description": "The identifier of the resource being signed."
        },
        "sig": {
          "type": "string",
          "format": "byte",
          "description": "The signature."
        },
        "kind": {
          "$ref": "#/definitions/vegaNodeSignatureKind",
          "description": "The kind of resource being signed."
        }
      },
      "description": "Represents a signature from a validator, to be used by a foreign chain in order to recognise a decision taken by the Vega network."
    },
    "vegaNodeSignatureKind": {
      "type": "string",
      "enum": [
        "NODE_SIGNATURE_KIND_UNSPECIFIED",
        "NODE_SIGNATURE_KIND_ASSET_NEW",
        "NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL"
      ],
      "default": "NODE_SIGNATURE_KIND_UNSPECIFIED",
      "description": "The kind of the signature created by a node, for example, whitelisting a new asset, withdrawal etc.\n\n - NODE_SIGNATURE_KIND_UNSPECIFIED: represents a unspecified / missing value from the input\n - NODE_SIGNATURE_KIND_ASSET_NEW: represents a signature for a new asset whitelisting\n - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: represents a signature for a asset withdrawal"
    },
    "vegaOrder": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the order (set by the system after consensus)."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier for the order."
        },
        "partyID": {
          "type": "string",
          "description": "Party identifier for the order."
        },
        "side": {
          "$ref": "#/definitions/vegaSide",
          "description": "Side for the order, e.g. SIDE_BUY or SIDE_SELL. See [`Side`](#vega.Side)."
        },
        "price": {
          "type": "string",
          "format": "uint64",
          "description": "Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "Size for the order, for example, in a futures market the size equals the number of contracts."
        },
        "remaining": {
          "type": "string",
          "format": "uint64",
          "description": "Size remaining, when this reaches 0 then the order is fully filled and status becomes STATUS_FILLED."
        },
        "timeInForce": {
          "$ref": "#/definitions/OrderTimeInForce",
          "description": "Time in force indicates how long an order will remain active before it is executed or expires.\nSee [`Order.TimeInForce`](#vega.Order.TimeInForce)."
        },
        "type": {
          "$ref": "#/definitions/vegaOrderType",
          "description": "Type for the order. See [`Order.Type`](#vega.Order.Type)."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the order was created at, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        },
        "status": {
          "$ref": "#/definitions/OrderStatus",
          "description": "The current status for the order. See [`Order.Status`](#vega.Order.Status).\nFor detail on `STATUS_REJECTED` please check the [`OrderError`](#vega.OrderError) value given in the `reason` field."
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the order will expire, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`. Valid only for [`Order.TimeInForce`](#vega.Order.TimeInForce)`.TIF_GTT`."
        },
        "reference": {
          "type": "string",
          "title": "Reference given for the order, this is typically used to retrieve an order submitted through consensus. Currently\nset internally by the node to return a unique reference identifier for the order submission.\nTODO(cdm): Section on how order references work on Vega in docs.vega.xyz"
        },
        "reason": {
          "$ref": "#/definitions/vegaOrderError",
          "description": "If the Order `status` is `STATUS_REJECTED` then an [`OrderError`](#vega.OrderError) reason will be specified.\nThe default for this field is `ORDER_ERROR_NONE` which signifies that there were no errors."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the Order was last updated, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "title": "The version for the order, initial value is version 1 and is incremented after each successful amend"
        },
        "batchID": {
          "type": "string",
          "format": "uint64",
          "description": "Batch identifier for the order, used internally for orders submitted during auctions\nto keep track of the auction batch this order falls under (required for fees calculation)."
        }
      },
      "description": "An order can be submitted, amended and cancelled on Vega in an attempt to make trades with other parties."
    },
    "vegaOrderAmendment": {
      "type": "object",
      "properties": {
        "orderID": {
          "type": "string",
          "description": "Order identifier, this is required to find the order and will not be updated. Required field."
        },
        "partyID": {
          "type": "string",
          "description": "Party identifier, this is required to find the order and will not be updated. Required field."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier, this is required to find the order and will not be updated."
        },
        "price": {
          "$ref": "#/definitions/vegaPrice",
          "description": "Amend the price for the order, if the Price value is set, otherwise price will remain unchanged. See [`Price`](#vega.Price)."
        },
        "sizeDelta": {
          "type": "string",
          "format": "int64",
          "description": "Amend the size for the order by the delta specified.\nTo reduce the size from the current value set a negative integer value.\nTo increase the size from the current value, set a positive integer value.\nTo leave the size unchanged set a value of zero."
        },
        "expiresAt": {
          "$ref": "#/definitions/vegaTimestamp",
          "description": "Amend the expiry time for the order, if the Timestamp value is set, otherwise expiry time will remain unchanged.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        },
        "timeInForce": {
          "$ref": "#/definitions/OrderTimeInForce",
          "description": "Amend the time in force for the order, set to TIF_UNSPECIFIED to remain unchanged.\nSee [`TimeInForce`](#api.VegaTimeResponse).`timestamp`."
        }
      },
      "description": "An order amendment is a request to amend or update an existing order on Vega."
    },
    "vegaOrderCancellation": {
      "type": "object",
      "properties": {
        "orderID": {
          "type": "string",
          "description": "Unique identifier for the order (set by the system after consensus). Required field."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier for the order. Required field."
        },
        "partyID": {
          "type": "string",
          "description": "Party identifier for the order. Required field."
        }
      },
      "description": "An order cancellation is a request to cancel an existing order on Vega."
    },
    "vegaOrderError": {
      "type": "string",
      "enum": [
        "ORDER_ERROR_NONE",
        "ORDER_ERROR_INVALID_MARKET_ID",
        "ORDER_ERROR_INVALID_ORDER_ID",
        "ORDER_ERROR_OUT_OF_SEQUENCE",
        "ORDER_ERROR_INVALID_REMAINING_SIZE",
        "ORDER_ERROR_TIME_FAILURE",
        "ORDER_ERROR_REMOVAL_FAILURE",
        "ORDER_ERROR_INVALID_EXPIRATION_DATETIME",
        "ORDER_ERROR_INVALID_ORDER_REFERENCE",
        "ORDER_ERROR_EDIT_NOT_ALLOWED",
        "ORDER_ERROR_AMEND_FAILURE",
        "ORDER_ERROR_NOT_FOUND",
        "ORDER_ERROR_INVALID_PARTY_ID",
        "ORDER_ERROR_MARKET_CLOSED",
        "ORDER_ERROR_MARGIN_CHECK_FAILED",
        "ORDER_ERROR_MISSING_GENERAL_ACCOUNT",
        "ORDER_ERROR_INTERNAL_ERROR",
        "ORDER_ERROR_INVALID_SIZE",
        "ORDER_ERROR_INVALID_PERSISTENCE",
        "ORDER_ERROR_INVALID_TYPE",
        "ORDER_ERROR_SELF_TRADING",
        "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES",
        "ORDER_ERROR_INCORRECT_MARKET_TYPE"
      ],
      "default": "ORDER_ERROR_NONE",
      "description": "If there is an issue with an order during it's life-cycle, it will be marked with `status.ORDER_STATUS_REJECTED`\nand be given an error code in the `reason` field.\n\n - ORDER_ERROR_NONE: Default value, no error reported.\n - ORDER_ERROR_INVALID_MARKET_ID: Order was submitted for a market that does not exist.\n - ORDER_ERROR_INVALID_ORDER_ID: Order was submitted with an invalid identifier.\n - ORDER_ERROR_OUT_OF_SEQUENCE: Order was amended with a sequence number that was not previous version + 1.\n - ORDER_ERROR_INVALID_REMAINING_SIZE: Order was amended with an invalid remaining size (e.g. remaining greater than total size).\n - ORDER_ERROR_TIME_FAILURE: Node was unable to get Vega (blockchain) time.\n - ORDER_ERROR_REMOVAL_FAILURE: Failed to remove an order from the book.\n - ORDER_ERROR_INVALID_EXPIRATION_DATETIME: An order with `TimeInForce.TIF_GTT` was submitted or amended\nwith an expiration that was badly formatted or otherwise invalid.\n - ORDER_ERROR_INVALID_ORDER_REFERENCE: Order was submitted or amended with an invalid reference field.\n - ORDER_ERROR_EDIT_NOT_ALLOWED: Order amend was submitted for an order field that cannot not be amended (e.g. order identifier).\n - ORDER_ERROR_AMEND_FAILURE: Amend failure because amend details do not match original order.\n - ORDER_ERROR_NOT_FOUND: Order not found in an order book or store.\n - ORDER_ERROR_INVALID_PARTY_ID: Order was submitted with an invalid or missing party identifier.\n - ORDER_ERROR_MARKET_CLOSED: Order was submitted for a market that has closed.\n - ORDER_ERROR_MARGIN_CHECK_FAILED: Order was submitted, but the party did not have enough collateral to cover the order.\n - ORDER_ERROR_MISSING_GENERAL_ACCOUNT: Order was submitted, but the party did not have an account for this asset.\n - ORDER_ERROR_INTERNAL_ERROR: Unspecified internal error.\n - ORDER_ERROR_INVALID_SIZE: Order was submitted with an invalid or missing size (e.g. 0).\n - ORDER_ERROR_INVALID_PERSISTENCE: Order was submitted with an invalid persistence for its type.\n - ORDER_ERROR_INVALID_TYPE: Order was submitted with an invalid type field.\n - ORDER_ERROR_SELF_TRADING: Order was stopped as it would have traded with another order submitted from the same party.\n - ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES: Order was submitted, but the party did not have enough collateral to cover the fees for the order.\n - ORDER_ERROR_INCORRECT_MARKET_TYPE: Order was submitted with an incorrect or invalid market type."
    },
    "vegaOrderSubmission": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the order (set by the system after consensus)."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier for the order. Required field."
        },
        "partyID": {
          "type": "string",
          "description": "Party identifier for the order. Required field."
        },
        "price": {
          "type": "string",
          "format": "uint64",
          "description": "Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places.\nRequired field for Limit orders, however it is not required for market orders."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "Size for the order, for example, in a futures market the size equals the number of contracts. Cannot be negative."
        },
        "side": {
          "$ref": "#/definitions/vegaSide",
          "description": "Side for the order, e.g. SIDE_BUY or SIDE_SELL. See [`Side`](#vega.Side). Required field."
        },
        "timeInForce": {
          "$ref": "#/definitions/OrderTimeInForce",
          "description": "Time in force indicates how long an order will remain active before it is executed or expires.\nSee [`Order.TimeInForce`](#vega.Order.TimeInForce). Required field."
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the order will expire, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.\nRequired field only for [`Order.TimeInForce`](#vega.Order.TimeInForce)`.TIF_GTT`."
        },
        "type": {
          "$ref": "#/definitions/vegaOrderType",
          "description": "Type for the order. See [`Order.Type`](#vega.Order.Type). Required field."
        },
        "reference": {
          "type": "string",
          "title": "Reference given for the order, this is typically used to retrieve an order submitted through consensus. Currently\nset internally by the node to return a unique reference identifier for the order submission.\nTODO(cdm): Section on how order references work on Vega in docs.vega.xyz"
        }
      },
      "description": "An order submission is a request to submit or create a new order on Vega."
    },
    "vegaOrderType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_LIMIT",
        "TYPE_MARKET",
        "TYPE_NETWORK"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "Type values for an order.\n\n - TYPE_UNSPECIFIED: Default value, always invalid.\n - TYPE_LIMIT: Used for Limit orders.\n - TYPE_MARKET: Used for Market orders.\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed traders)."
    },
    "vegaParty": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "A unique identifier for the party, typically represented by a public key."
        }
      },
      "description": "A party represents an entity who wishes to trade on or query a Vega network."
    },
    "vegaPosition": {
      "type": "object",
      "properties": {
        "marketID": {
          "type": "string",
          "description": "Market identifier."
        },
        "partyID": {
          "type": "string",
          "description": "Party identifier."
        },
        "openVolume": {
          "type": "string",
          "format": "int64",
          "description": "Open volume for the position. Value is signed +ve for long and -ve for short."
        },
        "realisedPNL": {
          "type": "string",
          "format": "int64",
          "description": "Realised profit and loss for the position. Value is signed +ve for long and -ve for short."
        },
        "unrealisedPNL": {
          "type": "string",
          "format": "int64",
          "description": "Unrealised profit and loss for the position. Value is signed +ve for long and -ve for short."
        },
        "averageEntryPrice": {
          "type": "string",
          "format": "uint64",
          "description": "Average entry price for the position, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        }
      },
      "description": "Represents position data for a party on the specified market on Vega."
    },
    "vegaPrice": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "uint64",
          "description": "Price value, given as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        }
      }
    },
    "vegaPriceLevel": {
      "type": "object",
      "properties": {
        "price": {
          "type": "string",
          "format": "uint64",
          "description": "Price for the price level, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "numberOfOrders": {
          "type": "string",
          "format": "uint64",
          "description": "Number of orders at the price level."
        },
        "volume": {
          "type": "string",
          "format": "uint64",
          "description": "Volume at the price level."
        },
        "cumulativeVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Cumulative volume at the price level."
        }
      },
      "description": "Represents a price level from market depth or order book data."
    },
    "vegaProposal": {
      "type": "object",
      "properties": {
        "ID": {
          "type": "string",
          "description": "Proposal unique identifier."
        },
        "reference": {
          "type": "string",
          "description": "Proposal reference."
        },
        "partyID": {
          "type": "string",
          "description": "Proposal author, identifier of the party submitting the proposal."
        },
        "state": {
          "$ref": "#/definitions/ProposalState",
          "title": "Proposal state (see Proposal.State definition)"
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Proposal timestamp for date and time (in nanoseconds) when proposal was submitted to the network."
        },
        "terms": {
          "$ref": "#/definitions/vegaProposalTerms",
          "description": "Proposal configuration and the actual change that is meant to be executed when proposal is enacted."
        },
        "reason": {
          "$ref": "#/definitions/vegaProposalError",
          "title": "A reason for the current state of the proposal\nthis may be set in case of REJECTED and FAILED status"
        }
      }
    },
    "vegaProposalError": {
      "type": "string",
      "enum": [
        "PROPOSAL_ERROR_UNSPECIFIED",
        "PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON",
        "PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE",
        "PROPOSAL_ERROR_ENACT_TIME_TOO_SOON",
        "PROPOSAL_ERROR_ENACT_TIME_TOO_LATE",
        "PROPOSAL_ERROR_INSUFFICIENT_TOKENS",
        "PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY",
        "PROPOSAL_ERROR_NO_PRODUCT",
        "PROPOSAL_ERROR_UNSUPPORTED_PRODUCT",
        "PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT_TIMESTAMP",
        "PROPOSAL_ERROR_PRODUCT_MATURITY_IS_PASSED",
        "PROPOSAL_ERROR_NO_TRADING_MODE",
        "PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE",
        "PROPOSAL_ERROR_NODE_VALIDATION_FAILED",
        "PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD",
        "PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS",
        "PROPOSAL_ERROR_INVALID_ASSET"
      ],
      "default": "PROPOSAL_ERROR_UNSPECIFIED",
      "description": "- PROPOSAL_ERROR_UNSPECIFIED: default value\n - PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON: the specified close time is too early base on network parameters\n - PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE: the specified close time is too late based on network parameters\n - PROPOSAL_ERROR_ENACT_TIME_TOO_SOON: the specified enact time is too early base on network parameters\n - PROPOSAL_ERROR_ENACT_TIME_TOO_LATE: the specified enact time is too late based on network parameters\n - PROPOSAL_ERROR_INSUFFICIENT_TOKENS: the proposer for this proposal as insufficient token\n - PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY: the instrument quote name and base name were the same\n - PROPOSAL_ERROR_NO_PRODUCT: the proposal has not product\n - PROPOSAL_ERROR_UNSUPPORTED_PRODUCT: the specified product is not supported\n - PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT_TIMESTAMP: invalid future maturity timestamp (expect RFC3339)\n - PROPOSAL_ERROR_PRODUCT_MATURITY_IS_PASSED: the product maturity is past\n - PROPOSAL_ERROR_NO_TRADING_MODE: the proposal has not trading mode\n - PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE: the proposal has an unsupported trading mode\n - PROPOSAL_ERROR_NODE_VALIDATION_FAILED: the proposal failed node validation\n - PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD: a field is missing in a builtin asset source\n - PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS: the contract address is missing in the ERC20 asset source\n - PROPOSAL_ERROR_INVALID_ASSET: the asset id refer to no assets in vega",
      "title": "A list of possible error which could have happenned\nand the cause for an proposal being rejected of failed"
    },
    "vegaProposalTerms": {
      "type": "object",
      "properties": {
        "closingTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp (Unix time in seconds) when voting closes for this proposal.\nConstrained by `minCloseInSeconds` and `maxCloseInSeconds` network parameters."
        },
        "enactmentTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp (Unix time in seconds) when proposal gets enacted (if passed).\nConstrained by `minEnactInSeconds` and `maxEnactInSeconds` network parameters."
        },
        "validationTimestamp": {
          "type": "string",
          "format": "int64"
        },
        "updateMarket": {
          "$ref": "#/definitions/vegaUpdateMarket",
          "description": "Proposal change for modifying an existing market on Vega."
        },
        "newMarket": {
          "$ref": "#/definitions/vegaNewMarket",
          "description": "Proposal change for creating new market on Vega."
        },
        "updateNetwork": {
          "$ref": "#/definitions/vegaUpdateNetwork",
          "description": "Proposal change for updating Vega network parameters."
        },
        "newAsset": {
          "$ref": "#/definitions/vegaNewAsset",
          "description": "Proposal change for creating new assets on Vega."
        }
      }
    },
    "vegaRemoveValidator": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/vegaIdentifier",
          "title": "The identifier of this validator"
        }
      },
      "title": "A message to notify a new validator being removed to the vega network"
    },
    "vegaScalingFactors": {
      "type": "object",
      "properties": {
        "searchLevel": {
          "type": "number",
          "format": "double"
        },
        "initialMargin": {
          "type": "number",
          "format": "double"
        },
        "collateralRelease": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "vegaSide": {
      "type": "string",
      "enum": [
        "SIDE_UNSPECIFIED",
        "SIDE_BUY",
        "SIDE_SELL"
      ],
      "default": "SIDE_UNSPECIFIED",
      "description": "A side relates to the direction of an order, to Buy, or Sell.\n\n - SIDE_UNSPECIFIED: Default value, always invalid.\n - SIDE_BUY: Buy order.\n - SIDE_SELL: Sell order."
    },
    "vegaSignature": {
      "type": "object",
      "properties": {
        "sig": {
          "type": "string",
          "format": "byte",
          "title": "The bytes of the signature"
        },
        "algo": {
          "type": "string",
          "title": "The algorithm used to create the signature"
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "title": "The version of the signature used to create the signature"
        }
      },
      "title": "A signature to be authenticate a transaction\nand to be verified by the vega network"
    },
    "vegaSignedBundle": {
      "type": "object",
      "properties": {
        "tx": {
          "type": "string",
          "format": "byte",
          "description": "Transaction payload (proto marshalled)."
        },
        "sig": {
          "$ref": "#/definitions/vegaSignature",
          "description": "The signature authenticating the transaction."
        }
      },
      "description": "A bundle of a transaction and it's signature."
    },
    "vegaSimpleModelParams": {
      "type": "object",
      "properties": {
        "factorLong": {
          "type": "number",
          "format": "double"
        },
        "factorShort": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "vegaSimpleRiskModel": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/vegaSimpleModelParams"
        }
      }
    },
    "vegaStatistics": {
      "type": "object",
      "properties": {
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "description": "Current block height as reported by the Vega blockchain."
        },
        "backlogLength": {
          "type": "string",
          "format": "uint64",
          "description": "Current backlog length (number of transactions) that are waiting to be included in a block."
        },
        "totalPeers": {
          "type": "string",
          "format": "uint64",
          "description": "Total number of connected peers to this node."
        },
        "genesisTime": {
          "type": "string",
          "description": "Genesis block date and time formatted in ISO-8601 datetime format with nanosecond precision."
        },
        "currentTime": {
          "type": "string",
          "description": "Current system date and time formatted in ISO-8601 datetime format with nanosecond precision."
        },
        "vegaTime": {
          "type": "string",
          "description": "Current Vega date and time formatted in ISO-8601 datetime format with nanosecond precision."
        },
        "status": {
          "$ref": "#/definitions/vegaChainStatus",
          "description": "Status of the connection to the Vega blockchain.\nSee [`ChainStatus`](#vega.ChainStatus)."
        },
        "txPerBlock": {
          "type": "string",
          "format": "uint64",
          "description": "Transactions per block."
        },
        "averageTxBytes": {
          "type": "string",
          "format": "uint64",
          "description": "Average transaction size in bytes."
        },
        "averageOrdersPerBlock": {
          "type": "string",
          "format": "uint64",
          "description": "Average orders per block."
        },
        "tradesPerSecond": {
          "type": "string",
          "format": "uint64",
          "description": "Trades emitted per second."
        },
        "ordersPerSecond": {
          "type": "string",
          "format": "uint64",
          "description": "Orders affected per second."
        },
        "totalMarkets": {
          "type": "string",
          "format": "uint64",
          "description": "Total markets on this Vega network."
        },
        "totalAmendOrder": {
          "type": "string",
          "format": "uint64",
          "description": "Total number of order amendments since genesis (on all markets)."
        },
        "totalCancelOrder": {
          "type": "string",
          "format": "uint64",
          "description": "Total number of order cancellations since genesis (on all markets)."
        },
        "totalCreateOrder": {
          "type": "string",
          "format": "uint64",
          "description": "Total number of order submissions since genesis (on all markets)."
        },
        "totalOrders": {
          "type": "string",
          "format": "uint64",
          "description": "Total number of orders affected since genesis (on all markets)."
        },
        "totalTrades": {
          "type": "string",
          "format": "uint64",
          "description": "Total number of trades emitted since genesis (on all markets)."
        },
        "orderSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to order data."
        },
        "tradeSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to trade data."
        },
        "candleSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to candle-stick data."
        },
        "marketDepthSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to market depth data."
        },
        "positionsSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to positions data."
        },
        "accountSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to account data."
        },
        "marketDataSubscriptions": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of stream subscribers to market data."
        },
        "appVersionHash": {
          "type": "string",
          "description": "The version hash of the Vega node software."
        },
        "appVersion": {
          "type": "string",
          "description": "The version of the Vega node software."
        },
        "chainVersion": {
          "type": "string",
          "description": "The version of the underlying Vega blockchain."
        },
        "blockDuration": {
          "type": "string",
          "format": "uint64",
          "description": "Current block duration, in nanoseconds."
        },
        "uptime": {
          "type": "string",
          "description": "Total uptime for this node formatted in ISO-8601 datetime format with nanosecond precision."
        },
        "chainID": {
          "type": "string",
          "description": "Unique identifier for the underlying Vega blockchain."
        }
      },
      "description": "Vega domain specific statistics as reported by the node the caller is connected to."
    },
    "vegaTimestamp": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp value."
        }
      },
      "description": "A timestamp in nanoseconds since epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
    },
    "vegaTradableInstrument": {
      "type": "object",
      "properties": {
        "instrument": {
          "$ref": "#/definitions/vegaInstrument"
        },
        "marginCalculator": {
          "$ref": "#/definitions/vegaMarginCalculator"
        },
        "logNormalRiskModel": {
          "$ref": "#/definitions/vegaLogNormalRiskModel"
        },
        "externalRiskModel": {
          "$ref": "#/definitions/vegaExternalRiskModel"
        },
        "simpleRiskModel": {
          "$ref": "#/definitions/vegaSimpleRiskModel"
        }
      }
    },
    "vegaTrade": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the trade (generated by Vega)."
        },
        "marketID": {
          "type": "string",
          "description": "Market identifier (the market that the trade occurred on)."
        },
        "price": {
          "type": "string",
          "format": "uint64",
          "description": "Price for the trade, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "Size filled for the trade."
        },
        "buyer": {
          "type": "string",
          "description": "Unique party identifier for the buyer."
        },
        "seller": {
          "type": "string",
          "description": "Unique party identifier for the seller."
        },
        "aggressor": {
          "$ref": "#/definitions/vegaSide",
          "description": "Direction of the aggressive party e.g. SIDE_BUY or SIDE_SELL. See [`Side`](#vega.Side)."
        },
        "buyOrder": {
          "type": "string",
          "description": "Identifier of the order from the buy side."
        },
        "sellOrder": {
          "type": "string",
          "description": "Identifier of the order from the sell side."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the trade occurred, in nanoseconds since the epoch.\nSee [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`."
        },
        "type": {
          "$ref": "#/definitions/vegaTradeType",
          "description": "Type for the trade. See [`Trade.Type`](#vega.Trade.Type)."
        },
        "buyerFee": {
          "$ref": "#/definitions/vegaFee",
          "description": "Fee amount charged to the buyer party for the trade."
        },
        "sellerFee": {
          "$ref": "#/definitions/vegaFee",
          "description": "Fee amount charged to the seller party for the trade."
        },
        "buyerAuctionBatch": {
          "type": "string",
          "format": "uint64",
          "description": "Auction batch number that the buy side order was placed in."
        },
        "sellerAuctionBatch": {
          "type": "string",
          "format": "uint64",
          "description": "Auction batch number that the sell side order was placed in."
        }
      },
      "description": "A trade occurs when an aggressive order crosses one or more passive orders on the order book for a market on Vega."
    },
    "vegaTradeType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_DEFAULT",
        "TYPE_NETWORK_CLOSE_OUT_GOOD",
        "TYPE_NETWORK_CLOSE_OUT_BAD"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "Type values for a trade.\n\n - TYPE_UNSPECIFIED: Default value, always invalid.\n - TYPE_DEFAULT: Normal trading between two parties.\n - TYPE_NETWORK_CLOSE_OUT_GOOD: Trading initiated by the network with another party on the book,\nwhich helps to zero-out the positions of one or more distressed parties.\n - TYPE_NETWORK_CLOSE_OUT_BAD: Trading initiated by the network with another party off the book,\nwith a distressed party in order to zero-out the position of the party.\ntodo(cdm): chat with Jeremy on zoom to sanity check/improve."
    },
    "vegaTransferBalance": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/vegaAccount",
          "title": "The account relating to the transfer"
        },
        "balance": {
          "type": "string",
          "format": "uint64",
          "title": "The balance relating to the transfer"
        }
      },
      "description": "Represents the balance for an account during a transfer."
    },
    "vegaTransferResponse": {
      "type": "object",
      "properties": {
        "transfers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLedgerEntry"
          },
          "description": "One or more ledger entries representing the transfers."
        },
        "balances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaTransferBalance"
          },
          "description": "One or more account balances."
        }
      },
      "description": "Represents the response from a transfer."
    },
    "vegaUpdateMarket": {
      "type": "object"
    },
    "vegaUpdateNetwork": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaNetworkConfiguration"
        }
      }
    },
    "vegaValidatorEvent": {
      "type": "object",
      "properties": {
        "sourceID": {
          "type": "string",
          "title": "The source ID of the event"
        },
        "add": {
          "$ref": "#/definitions/vegaAddValidator"
        },
        "rm": {
          "$ref": "#/definitions/vegaRemoveValidator"
        }
      },
      "title": "An event related to validator management with foreign networks"
    },
    "vegaVote": {
      "type": "object",
      "properties": {
        "partyID": {
          "type": "string",
          "description": "Voter's party identifier."
        },
        "value": {
          "$ref": "#/definitions/VoteValue",
          "description": "Actual vote."
        },
        "proposalID": {
          "type": "string",
          "description": "Identifier of the proposal being voted on."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Vote timestamp for date and time (in nanoseconds) when vote was submitted to the network."
        }
      }
    },
    "vegaWithdraw": {
      "type": "object",
      "properties": {
        "partyID": {
          "type": "string",
          "description": "Unique party identifier affecting the withdrawal."
        },
        "amount": {
          "type": "string",
          "format": "uint64",
          "description": "Total amount to withdraw."
        },
        "asset": {
          "type": "string",
          "description": "Asset identifier."
        }
      },
      "description": "Represents a withdrawal of an asset by a party on Vega."
    }
  },
  "x-stream-definitions": {
    "apiOrdersStream": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/apiOrdersStream"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of apiOrdersStream"
    },
    "apiTradesStream": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/apiTradesStream"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of apiTradesStream"
    },
    "vegaAccount": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaAccount"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaAccount"
    },
    "vegaCandle": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaCandle"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaCandle"
    },
    "vegaGovernanceData": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaGovernanceData"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaGovernanceData"
    },
    "vegaMarginLevels": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaMarginLevels"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaMarginLevels"
    },
    "vegaMarketData": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaMarketData"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaMarketData"
    },
    "vegaMarketDepth": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaMarketDepth"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaMarketDepth"
    },
    "vegaPosition": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaPosition"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaPosition"
    },
    "vegaTransferResponse": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaTransferResponse"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaTransferResponse"
    },
    "vegaVote": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/vegaVote"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of vegaVote"
    }
  }
}
