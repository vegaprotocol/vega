// vega_ext provides extra methods to the types generated by protobuf.

package proto

import (
	"strconv"

	"google.golang.org/protobuf/types/known/wrapperspb"
)

// Float64Fee tries to parse the Fee (string) into a float64.
// If parsing fails 0 is returned.
func (l *LiquidityProvision) Float64Fee() float64 {
	v, err := strconv.ParseFloat(l.Fee, 64)
	if err != nil {
		return 0
	}
	return v
}

// IsPersistent returns true if the order is persistent.
// A persistent order is a Limit type order that might be
// matched in the future.
func (o *Order) IsPersistent() bool {
	return (o.TimeInForce == Order_TIME_IN_FORCE_GTC ||
		o.TimeInForce == Order_TIME_IN_FORCE_GTT ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFN ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFA) &&
		o.Type == Order_TYPE_LIMIT &&
		o.Remaining > 0
}

func (o *Order) AmendSize(newSize int64) *OrderAmendment {
	a := &OrderAmendment{
		OrderID:  o.Id,
		MarketID: o.MarketID,
		PartyID:  o.PartyID,

		SizeDelta:   newSize - int64(o.Size),
		TimeInForce: o.TimeInForce,
	}
	if e := o.ExpiresAt; e > 0 {
		a.ExpiresAt = &Timestamp{
			Value: e,
		}
	}

	if p := o.PeggedOrder; p != nil {
		a.PeggedReference = p.Reference
		a.PeggedOffset = &wrapperspb.Int64Value{
			Value: p.Offset,
		}
	} else {
		if p := o.Price; p > 0 {
			a.Price = &Price{
				Value: p,
			}
		}
	}

	return a
}

func (o *Order) IsExpireable() bool {
	return (o.TimeInForce == Order_TIME_IN_FORCE_GFN ||
		o.TimeInForce == Order_TIME_IN_FORCE_GTT ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFA) &&
		o.ExpiresAt > 0
}

// IsFinished returns true if an order
// is in any state different to ACTIVE and PARKED
// Basically any order which is never gonna
// trade anymore
func (o *Order) IsFinished() bool {
	return o.Status != Order_STATUS_ACTIVE && o.Status != Order_STATUS_PARKED
}
