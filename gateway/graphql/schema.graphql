## VEGA - GraphQL schema

schema {
  query: Query
  subscription: Subscription
}

"Create an order linked to an index rather than a price"
type PeggedOrder {
  "Index to link this order to"
  reference: PeggedReference!
  "Price offset from the peg"
  offset: String!
}

"Subscriptions allow a caller to receive new information as it is available from the VEGA platform."
type Subscription {
  "Subscribe to the candles updates"
  candles(
    "ID of the market we want to listen candles for"
    marketId: ID!
    "Interval of the candles we want to listen for"
    interval: Interval!
  ): Candle!

  "Subscribe to orders updates"
  orders(
    "ID of the market from which we want orders updates"
    marketId: ID
    "ID of the party from which we want orders updates"
    partyId: ID
  ): [Order!]

  "Subscribe to the trades updates"
  trades(
    "ID of the market from which we want trades updates"
    marketId: ID
    "ID of the party from which we want trades updates"
    partyId: ID
  ): [Trade!]

  "Subscribe to the positions updates"
  positions(
    "ID of the party from we want updates for"
    partyId: ID
    "ID of the market from which we want position updates"
    marketId: ID
  ): Position!

  "Subscribe to the market depths update"
  marketDepth(
    "ID of the market we want to receive market depth updates for"
    marketId: ID!
  ): MarketDepth!

  "Subscribe to price level market depth updates"
  marketDepthUpdate(
    "ID of the market we want to receive market depth pricelevel updates for"
    marketId: ID!
  ): MarketDepthUpdate!

  "Subscribe to the accounts updates"
  accounts(
    "ID of the market from which we want accounts updates"
    marketId: ID
    "ID of the party from which we want accounts updates"
    partyId: ID
    "Asset code"
    asset: String
    "Type of the account"
    type: AccountType
  ): Account!

  "Subscribe to the mark price changes"
  marketData(
    "id of the market we want to subscribe to the market data changes"
    marketId: ID
  ): MarketData!

  "Subscribe to the margin changes"
  margins(
    "id of the party we want to subscribe for margin updates"
    partyId: ID!
    "market we want to listen to margin updates (nil if we want updates for all markets)"
    marketId: ID
  ): MarginLevels!

  "Subscribe to proposals. Leave out all arguments to receive all proposals"
  proposals(
    "Optional party id whose proposals are to be streamed"
    partyId: ID
  ): Proposal!

  "Subscribe to votes, either by proposal id or party id"
  votes(
    "Optional proposal id which votes are to be streamed"
    proposalId: ID
    "Optional party id whose votes are to be streamed"
    partyId: ID
  ): ProposalVote!

  "Subscribe to event data from the event bus"
  busEvents(
    "the types to subscribe to has to be an array"
    types: [BusEventType!]!
    "optional filter by market ID"
    marketId: ID
    "optional filter by party ID"
    partyId: ID
    "Specifies the size that the client will receive events in. Using 0 results in a variable batch size being sent. The stream will be closed if the client fails to read a batch within 5 seconds"
    batchSize: Int!
  ): [BusEvent!]

  "Subscribe to delegation data"
  delegations(
    "the party to subscribe for, empty if all"
    party: ID
    "the node to subscribe for, empty if all"
    nodeID: ID
  ): Delegation!

  "Subscribe to reward details data"
  rewards(
    "the asset to subscribe for, empty if all"
    assetId: ID
    "the party to subscribe for, empty if all"
    party: ID
  ): Reward!
}

"Margins for a given a party"
type MarginLevels {
  "market in which the margin is required for this party"
  market: Market!
  "asset for the current margins"
  asset: Asset!
  "id of the party for this margin"
  party: Party!
  "minimal margin for the position to be maintained in the network (unsigned int actually)"
  maintenanceLevel: String!
  "if the margin is between maintenance and search, the network will initiate a collateral search (unsigned int actually)"
  searchLevel: String!
  "this is the minimal margin required for a party to place a new order on the network (unsigned int actually)"
  initialLevel: String!

  """
  If the margin of the party is greater than this level, then collateral will be released from the margin account into
  the general account of the party for the given asset.
  """
  collateralReleaseLevel: String!

  "RFC3339Nano time from at which this margin level was relevant"
  timestamp: String!
}

"Live data of a Market"
type MarketData {
  "market id of the associated mark price"
  market: Market!
  "the mark price (actually an unsigned int)"
  markPrice: String!
  "the highest price level on an order book for buy orders."
  bestBidPrice: String!
  "the aggregated volume being bid at the best bid price."
  bestBidVolume: String!
  "the lowest price level on an order book for offer orders."
  bestOfferPrice: String!
  "the aggregated volume being offered at the best offer price."
  bestOfferVolume: String!
  "the highest price level on an order book for buy orders not including pegged orders."
  bestStaticBidPrice: String!
  "the aggregated volume being offered at the best static bid price, excluding pegged orders"
  bestStaticBidVolume: String!
  "the lowest price level on an order book for offer orders not including pegged orders."
  bestStaticOfferPrice: String!
  "the aggregated volume being offered at the best static offer price, excluding pegged orders."
  bestStaticOfferVolume: String!
  "the arithmetic average of the best bid price and best offer price."
  midPrice: String!
  "the arithmetic average of the best static bid price and best static offer price"
  staticMidPrice: String!
  "RFC3339Nano time at which this market price was relevant"
  timestamp: String!
  "the sum of the size of all positions greater than 0."
  openInterest: String!
  "RFC3339Nano time at which the auction will stop (null if not in auction mode)"
  auctionEnd: String
  "RFC3339Nano time at which the next auction will start (null if none is scheduled)"
  auctionStart: String
  "indicative price if the auction ended now, 0 if not in auction mode"
  indicativePrice: String!
  "indicative volume if the auction ended now, 0 if not in auction mode"
  indicativeVolume: String!
  "what state the market is in (auction, continuous etc)"
  marketTradingMode: MarketTradingMode!
  "what triggered an auction (if an auction was started)"
  trigger: AuctionTrigger!
  "what extended the ongoing auction (if an auction was extended)"
  extensionTrigger: AuctionTrigger!
  "the amount of stake targeted for this market"
  targetStake: String
  "the supplied stake for the market"
  suppliedStake: String
  "The liquidity commitments for a given market"
  commitments: MarketDataCommitments!
  "A list of valid price ranges per associated trigger"
  priceMonitoringBounds: [PriceMonitoringBounds!]
  "the market value proxy"
  marketValueProxy: String!
  "the equity like share of liquidity fee for each liquidity provider"
  liquidityProviderFeeShare: [LiquidityProviderFeeShare!]
}

"timestamps for when the market changes state"
type MarketTimestamps {
  "Time when the market is first proposed"
  proposed: String
  "Time when the market has been voted in and waiting to be created"
  pending: String
  "Time when the market is open and ready to accept trades"
  open: String
  "Time when the market is closed"
  close: String
}

"The equity like share of liquidity fee for each liquidity provider"
type LiquidityProviderFeeShare {
  "The liquidity provider party id"
  party: Party!
  "The share own by this liquidity provider (float)"
  equityLikeShare: String!
  "the average entry valuation of the liquidity provider for the market"
  averageEntryValuation: String!
}

"The MM commitments for this market"
type MarketDataCommitments {
  "a set of liquidity sell orders to meet the liquidity provision obligation, see MM orders spec."
  sells: [LiquidityOrderReference!]
  "a set of liquidity buy orders to meet the liquidity provision obligation, see MM orders spec."
  buys: [LiquidityOrderReference!]
}

type TransactionSubmitted {
  success: Boolean!
}

input AccountFilter {
  assetId: ID
  partyIds: [ID!]
  marketIds: [ID!]
  accountTypes: [AccountType!]
}

"Queries allow a caller to read data and filter data via GraphQL."
type Query {
  "One or more instruments that are trading on the VEGA network"
  markets("ID of the market" id: ID): [Market!]

  marketsPaged(
    id: ID
    pagination: Pagination
  ): MarketConnection!

  "An instrument that is trading on the VEGA network"
  market("Optional ID of a market" id: ID!): Market

  "One or more entities that are trading on the VEGA network"
  parties("Optional ID of a party" id: ID): [Party!]

  partiesPaged(
    id: ID
    pagination: Pagination
  ): PartyConnection!

  "An entity that is trading on the VEGA network"
  party("ID of a party" id: ID!): Party

  "The last block process by the blockchain"
  lastBlockHeight: String!

  "All registered oracle specs"
  oracleSpecs(
    "Pagination"
    pagination: OffsetPagination
  ): [OracleSpec!]

  "An oracle spec for a given oracle spec ID"
  oracleSpec("ID for an oracle spec" oracleSpecID: String!): OracleSpec

  "All oracle data for a given oracle spec ID"
  oracleDataBySpec(
    "ID for an oracle spec"
    oracleSpecID: String!
    "Pagination"
    pagination: OffsetPagination
  ): [OracleData!]

  "All registered oracle specs"
  oracleData(
    "Pagination"
    pagination: OffsetPagination
  ): [OracleData!]

  "An order in the VEGA network found by orderID"
  orderByID(
    "ID for an order"
    orderId: ID!

    "version of the order (omitted or 0 for most recent; 1 for original; 2 for first amendment, etc)"
    version: Int
  ): Order!

  "Order versions (created via amendments if any) found by orderID"
  orderVersions(
    "ID for an order"
    orderId: ID!

    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Order!] @deprecated(reason: "Use orderVersionsPaged instead")

  "Order versions (created via amendments if any) found by orderID"
  orderVersionsPaged(
    "ID for an order"
    orderId: ID
    "Pagination information"
    pagination: Pagination
  ): OrderConnection!

  "An order in the VEGA network found by referenceID"
  orderByReference("Reference for an order" reference: String!): Order!

  "All governance proposals in the VEGA network"
  proposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "A governance proposal located by either its id or reference. If both are set, id is used."
  proposal(
    "Optionally, locate proposal by its id"
    id: ID
    "Optionally, locate proposal by its reference. If id is set, this parameter is ignored."
    reference: String
  ): Proposal!

  "Governance proposals that aim to create new markets"
  newMarketProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that aim to update existing markets"
  updateMarketProposals(
    "Optionally, select proposals for a specific market. Leave out for all"
    marketId: ID
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that aim to update Vega network parameters"
  networkParametersProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that aim to create new assets in Vega"
  newAssetProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that allows creation of free form proposals in Vega"
  newFreeformProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Return a list of aggregated node signature for a given resource ID"
  nodeSignatures(resourceId: ID!): [NodeSignature!]

  "An asset which is used in the vega network"
  asset("Id of the asset" assetId: ID!): Asset

  "The list of all assets in use in the vega network"
  assets: [Asset!]

  "return an estimation of the potential cost for a new order"
  estimateOrder(
    "ID of the market to place the order"
    marketId: ID!
    "ID of the party placing the order"
    partyId: ID!
    "Price of the asset"
    price: String
    "Size of the order"
    size: String!
    "Side of the order (Buy or Sell)"
    side: Side!
    "TimeInForce of the order"
    timeInForce: OrderTimeInForce!
    "expiration of the the order"
    expiration: String
    "type of the order"
    type: OrderType!
  ): OrderEstimate!

  "find a withdrawal using its id"
  withdrawal("id of the withdrawal" id: ID!): Withdrawal

  "find an erc20 withdrawal approval using its withdrawal id"
  erc20WithdrawalApproval(
    "id of the withdrawal"
    withdrawalId: ID!
  ): Erc20WithdrawalApproval

  "find a deposit using its id"
  deposit("id of the Deposit" id: ID!): Deposit

  "return the full list of network parameters"
  networkParameters: [NetworkParameter!]

  "returns information about nodes"
  nodeData: NodeData

  "all known network nodes"
  nodes: [Node!]

  "specific node in network"
  node("required id of node" id: String!): Node

  "query for historic key rotations"
  keyRotations(id: String): [KeyRotation!]

  "get data for a specific epoch, if id omitted it gets the current epoch. If the string is 'next', fetch the next epoch"
  epoch(id: String): Epoch!

  "get a list of all transfers for a pubkey"
  transfers(
    "the pubkey to look for"
    pubkey: String!
    "is the pubkey on the sending part of the transfer"
    isFrom: Boolean
    "is the pubkey in the receiving part of the transfer"
    isTo: Boolean
  ): [Transfer!]

  "get statistics about the vega node"
  statistics: Statistics!

  historicBalances(
    filter: AccountFilter,
    groupBy: [AccountField])
  : [AggregatedBalance!]!

  "Current network limits"
  networkLimits: NetworkLimits

  "get market data history for a specific market. If no dates are given, the latest snapshot will be returned. If only the start date is provided all history from the given date will be provided, and if only the end date is provided, all history from the start upto and including the end date will be provided."
  getMarketDataHistoryByID(
    id: String!
    """
    Optional start date time for the historic data query.
    If both the start and end date is not provided, only the latest snapshot will be returned.
    If only the start date is provided, all market data for the market from the start date forward will be returned.
    """
    start: Int
    """
    Optional end date time for the historic data query.
    If both the start and end date is not provided, only the latest snapshot will be returned.
    If only the end date is provided, all market data for the market up to and including the end date will be returned.
    """
    end: Int
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [MarketData]
}

enum TransferStatus {
  "Indicate a transfer still being processed"
  Pending
  "Indicate of an transfer accepted by the vega network"
  Done
  "Indicate of an transfer rejected by the vega network"
  Rejected
  """
  Indicate of a transfer stopped by the vega network
  e.g: no funds left to cover the transfer
  """
  Stopped
  "Indicate of a transfer cancel by the user"
  Cancelled
}

"A user initiated transfer"
type Transfer {
  "Identified of this transfer"
  id: ID!

  "The public key of the sender in this transfer"
  from: String!

  "The account type from which funds have been sent from"
  fromAccountType: AccountType!

  "The public key of the received of the funds"
  to: String!

  "The account type which has received the funds"
  toAccountType: AccountType!

  "The asset"
  asset: Asset

  "The amount sent"
  amount: String!

  "An optional reference"
  reference: String

  "The status of this transfer"
  status: TransferStatus!

  "The time at which the transfer was submitted"
  timestamp: String!

  kind: TransferKind!
}

union TransferKind = OneOffTransfer | RecurringTransfer

"The specific details for a one off transfer"
type OneOffTransfer {
  "An optional time at which the transfer should be delivered"
  deliverOn: String
}

"The specific details for a recurring transfer"
type RecurringTransfer {
  "The epoch at which this recurring transfer will start"
  startEpoch: Int!
  "An optional epoch at whihc this transfer will stop"
  endEpoch: Int
  "The factor of the initial amount to be distributed"
  factor: String!
  "An optional dispatch strategy for the recurring transfer"
  dispatchStrategy: DispatchStrategy
}

enum DispatchMetric {

  MarketTradingValue

  MakerFeesReceived

  TakerFeesPaid

  LPFeesReceived
}

type DispatchStrategy {
  "What to contribution is measured"
  dispatchMetric: DispatchMetric!

  "The asset to use for measuring contibution to the metric"
  dispatchMetricAssetId: ID!

  "Scope the dispatch to this markets only under the metric asset"
  marketIdsInScope: [ID!]
}

enum NodeStatus {
  "The node is non-validating"
  NonValidator

  "The node is validating"
  Validator
}

# Describes in both human readable and block time when an epoch spans.
type EpochTimestamps {
  "RFC3339 timestamp - Vega time of epoch start, null if not started"
  start: String
  "RFC3339 timestamp - Vega time of epoch expiry"
  expiry: String
  "RFC3339 timestamp - Vega time of epoch end, null if not ended"
  end: String

  # @TODO - blocks support
  # "Height of first block in the epoch, null if not started"
  # firstBlock: String!
  # "Height of last block in the epoch, null if not ended"
  # lastBlock: String
}

type KeyRotation {
  "ID of node where rotation took place"
  nodeId: String!
  "Old public key rotated from"
  oldPubKey: String!
  "New public key rotated to"
  newPubKey: String!
  "Block height of where the rotation took place"
  blockHeight: String!
}

type Epoch {
  "Presumably this is an integer or something. If there's no such thing, disregard"
  id: String!

  "Timestamps for start/end etc"
  timestamps: EpochTimestamps!

  "Validators that participated in this epoch"
  validators: [Node!]!

  delegations(
    # Optional party id to filter on
    partyId: String
    # Optional node id to filter on
    nodeId: String
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Delegation!]!
}

type NodeData {
  "Total staked amount across all nodes"
  stakedTotal: String!

  "Total number of nodes"
  totalNodes: Int!

  "Number of inactive nodes"
  inactiveNodes: Int!

  "Number of nodes validating"
  validatingNodes: Int!

  # @TODO allow to query based on number of epochs uptime(epochs: Int)
  "Total uptime for all epochs across all nodes. Or specify a number of epochs"
  uptime: Float!
}

type EpochParticipation {
  epoch: Epoch

  "RFC3339 timestamp"
  offline: String

  "RFC3339 timestamp"
  online: String

  totalRewards: Float
}

type EpochData {
  "Total number of epochs since node was created"
  total: Int!

  "Total number of offline epochs since node was created"
  offline: Int!

  "Total number of online epochs since node was created"
  online: Int!
}

type Node {
  "The node url eg n01.vega.xyz"
  id: String!

  "Pubkey of the node operator"
  pubkey: String!

  "Public key of Tendermint"
  tmPubkey: String!

  "Ethereum public key of the node"
  ethereumAdddress: String!

  "URL where I can find out more info on the node. Will this be possible?"
  infoUrl: String!

  "Country code for the location of the node"
  location: String!

  "The amount the node has put up themselves"
  stakedByOperator: String!

  "The amount of stake that has been delegated by token holders"
  stakedByDelegates: String!

  "Total amount staked on node"
  stakedTotal: String!

  # "Max amount of (wanted) stake, is this a network param or a node param"
  # @TODO - add this field
  # maxIntendedStake: String!

  "Amount of stake on the next epoch"
  pendingStake: String!

  epochData: EpochData

  # @TODO implement this filter
  # epochs(last: Int, since: String): [EpochParticipation!]!

  status: NodeStatus!

  # All delegation for a node by a given party if specified, or all delegations.
  delegations(partyId: String,
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Delegation!]

  "Reward scores for the current epoch for the validator"
  rewardScore: RewardScore

  "Ranking scores and status for the validator for the current epoch"
  rankingScore: RankingScore!
  # The name of the node
  name: String!

  # An url to an avatar
  avatarUrl: String
}

type RewardScore {
  "The stake based validator score with anti-whaling"
  rawValidatorScore: String!
  "The performance score of the validator"
  performanceScore: String!
  "The multisig score of the validator"
  multisigScore: String!
  "The composite score of the validator"
  validatorScore: String!
  "The normalised score of the validator"
  normalisedScore: String!
  "The status of the validator for this score"
  validatorStatus: String!
}

type RankingScore {
  "The current validation status of the validator"
  status: String!
  "The former validation status of teh validator"
  previousStatus: String!
  "The ranking score of the validator"
  rankingScore: String!
  "The stake based score of the validator (no anti-whaling)"
  stakeScore: String!
  "The performance score of the validator"
  performanceScore: String!
  "The tendermint voting power of the validator (uint32)"
  votingPower: String!
}

type Delegation {
  "Amount delegated"
  amount: String!

  "Party which is delegating"
  party: Party!

  "URL of node you are delegating to"
  node: Node!

  "Epoch of delegation"
  epoch: Int!
}

"Represents an asset in vega"
type Asset {
  "The id of the asset"
  id: ID!

  "The full name of the asset (e.g: Great British Pound)"
  name: String!

  "The symbol of the asset (e.g: GBP)"
  symbol: String!

  "The total supply of the market"
  totalSupply: String!

  "The precision of the asset"
  decimals: Int!

  "The minimum economically meaningful amount in the asset"
  quantum: String!

  "The origin source of the asset (e.g: an erc20 asset)"
  source: AssetSource!

  "The infrastructure fee account for this asset"
  infrastructureFeeAccount: Account!

  "The global reward pool account for this asset"
  globalRewardPoolAccount: Account
}

"One of the possible asset sources"
union AssetSource = BuiltinAsset | ERC20

"An asset originated from an Ethereum ERC20 Token"
type ERC20 {
  "The address of the erc20 contract"
  contractAddress: String!
  """
  The lifetime limits deposit per address
  Note: this is a temporary measure for restricted mainnet
  """
  lifetimeLimit: String!
  """
  The maximum allowed per withdraw
  Note: this is a temporary measure for restricted mainnet
  """
  withdrawThreshold: String!
}

"A vega builtin asset, mostly for testing purpose"
type BuiltinAsset {
  "Maximum amount that can be requested by a party through the built-in asset faucet at a time"
  maxFaucetAmountMint: String!
}

"Represents a signature for the approval of a resource from a validator"
type NodeSignature {
  "The id of the resource being signed for"
  id: ID!

  "The signature, as base64 encoding"
  signature: String

  "The kind of signature this is (e.g: withdrawal, new asset, etc)"
  kind: NodeSignatureKind
}

"Represents the type signature provided by a node"
enum NodeSignatureKind {
  "A signature for proposing a new asset into the network"
  AssetNew

  "A signature for allowing a withdrawal of funds"
  AssetWithdrawal
}

"Statistics about the node"
type Statistics {
  "Current block number"
  blockHeight: String!

  "Current block hash"
  blockHash: String!

  "Number of items in the backlog"
  backlogLength: String!

  "Total number of peers on the vega network"
  totalPeers: String!

  "RFC3339Nano genesis time of the chain"
  genesisTime: String!

  "RFC3339Nano current time (real)"
  currentTime: String!

  "RFC3339Nano uptime of the node"
  upTime: String!

  "RFC3339Nano current time of the chain (decided through consensus)"
  vegaTime: String!

  "Status of the vega application connection with the chain"
  status: String!

  "Number of transaction processed per block"
  txPerBlock: String!

  "Average size of the transactions"
  averageTxBytes: String!

  "Average number of orders added per blocks"
  averageOrdersPerBlock: String!

  "Number of the trades per seconds"
  tradesPerSecond: String!

  "Number of orders per seconds"
  ordersPerSecond: String!

  "Total number of markets"
  totalMarkets: String!

  "Total number of amended orders"
  totalAmendOrder: String!

  "Total number of cancelled orders"
  totalCancelOrder: String!

  "Total number of orders created"
  totalCreateOrder: String!

  "Total number of orders"
  totalOrders: String!

  "Total number of trades"
  totalTrades: String!

  "Version commit hash of the vega node"
  appVersionHash: String!

  "Version of the vega node (semver)"
  appVersion: String!

  "Version of the chain (semver)"
  chainVersion: String!

  "Duration of the last block, in nanoseconds"
  blockDuration: String!

  "Current chain id"
  chainId: String!
}

"A mode where Vega tries to execute orders as soon as they are received"
type ContinuousTrading {
  "Size of an increment in price in terms of the quote currency"
  tickSize: String!
}

"Frequent batch auctions trading mode"
type DiscreteTrading {
  "Duration of the discrete trading batch in nanoseconds. Maximum 1 month."
  duration: Int!
  "Size of an increment in price in terms of the quote currency"
  tickSize: String!
}

"Parameters for the log normal risk model"
type LogNormalModelParams {
  "mu parameter"
  mu: Float!
  "r parameter"
  r: Float!
  "sigma parameter"
  sigma: Float!
}

"Parameters for the simple risk model"
type SimpleRiskModelParams {
  "Risk factor for long"
  factorLong: Float!
  "Risk factor for short"
  factorShort: Float!
}

"A type of risk model for futures trading"
type LogNormalRiskModel {
  "Lambda parameter of the risk model"
  riskAversionParameter: Float!
  "Tau parameter of the risk model"
  tau: Float!
  "Params for the log normal risk model"
  params: LogNormalModelParams!
}

"A type of simple/dummy risk model where we can specify the risk factor long and short in params"
type SimpleRiskModel {
  "Params for the simple risk model"
  params: SimpleRiskModelParams!
}

union RiskModel = LogNormalRiskModel | SimpleRiskModel

"A set of metadata to associate to an instrument"
type InstrumentMetadata {
  "An arbitrary list of tags to associated to associate to the Instrument (string list)"
  tags: [String!]
}

"An Ethereum oracle"
type EthereumEvent {
  "The ID of the ethereum contract to use (string)"
  contractId: String!

  "Name of the Ethereum event to listen to. (string)"
  event: String!
}

union Oracle = EthereumEvent

"A Future product"
type Future {
  "The name of the asset (string)"
  settlementAsset: Asset!

  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!

  "The oracle spec describing the oracle data of interest for settlement price."
  oracleSpecForSettlementPrice: OracleSpec!

  "The oracle spec describing the oracle data of interest for trading termination."
  oracleSpecForTradingTermination: OracleSpec!

  "The binding between the oracle spec and the settlement price"
  oracleSpecBinding: OracleSpecToFutureBinding!
}

"""
OracleSpecToFutureBinding tells on which property oracle data should be
used as settlement price and trading termination.
"""
type OracleSpecToFutureBinding {
  settlementPriceProperty: String!
  tradingTerminationProperty: String!
}

"""
An oracle spec describe the oracle data that a product (or a risk model)
wants to get from the oracle engine.
"""
type OracleSpec {
  "id is a hash generated from the OracleSpec data."
  id: String!
  "RFC3339Nano creation date time"
  createdAt: String!
  "RFC3339Nano last updated timestamp"
  updatedAt: String
  """
  pubKeys is the list of authorized public keys that signed the data for this
  oracle. All the public keys in the oracle data should be contained in these
  public keys.
  """
  pubKeys: [String!]
  """
  filters describes which oracle data are considered of interest or not for
  the product (or the risk model).
  """
  filters: [Filter!]
  "status describes the status of the oracle spec"
  status: OracleSpecStatus!
  "data list all the oracle data broadcast to this spec"
  data: [OracleData!]!
}

"Status describe the status of the oracle spec"
enum OracleSpecStatus {
  "StatusActive describes an active oracle spec."
  StatusActive
  """
  StatusUnused describes an oracle spec that is not listening to data
  anymore.
  """
  StatusUnused
}

"""
Filter describes the conditions under which an oracle data is considered of
interest or not.
"""
type Filter {
  "key is the oracle data property key targeted by the filter."
  key: PropertyKey!
  """
  conditions are the conditions that should be matched by the data to be
  considered of interest.
  """
  conditions: [Condition!]
}

"PropertyKey describes the property key contained in an oracle data."
type PropertyKey {
  "name is the name of the property."
  name: String
  "type is the type of the property."
  type: PropertyKeyType!
}

"""
Type describes the type of properties that are supported by the oracle
engine.
"""
enum PropertyKeyType {
  "Any type."
  TypeEmpty
  "Integer type."
  TypeInteger
  "String type."
  TypeString
  "Boolean type."
  TypeBoolean
  "Any floating point decimal type."
  TypeDecimal
  "Timestamp date type."
  TypeTimestamp
}

"""
Condition describes the condition that must be validated by the
"""
type Condition {
  "comparator is the type of comparison to make on the value."
  operator: ConditionOperator!
  "value is used by the comparator."
  value: String
}

"Comparator describes the type of comparison."
enum ConditionOperator {
  "Verify if the property values are strictly equal or not."
  OperatorEquals
  "Verify if the oracle data value is greater than the Condition value."
  OperatorGreaterThan
  """
  Verify if the oracle data value is greater than or equal to the Condition
  value.
  """
  OperatorGreaterThanOrEqual
  " Verify if the oracle data value is less than the Condition value."
  OperatorLessThan
  """
  Verify if the oracle data value is less or equal to than the Condition
  value.
  """
  OperatorLessThanOrEqual
}

"An oracle data contains the data sent by an oracle"
type OracleData {
  "pubKeys is the list of public keys that signed the data"
  pubKeys: [String!]
  "data contains all the properties send by an oracle"
  data: [Property!]

  """
  lists all the oracle specs that matched this oracle data.
  When the array is empty, it means no oracle spec matched this oracle data.
  """
  matchedSpecIds: [String!]
  """
  RFC3339Nano formatted date and time for when the data was broadcast to the markets
  with a matching oracle spec.
  It has no value when the oracle date did not match any oracle spec.
  """
  broadcastAt:  String!
}

"A property associates a name to a value"
type Property {
  "name of the property"
  name: String!
  "value of the property"
  value: String!
}

union Product = Future

"Describe something that can be traded on Vega"
type Instrument {
  "Uniquely identify an instrument across all instruments available on Vega (string)"
  id: String!

  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)"
  code: String!

  "Full and fairly descriptive name for the instrument"
  name: String!

  "Metadata for this instrument"
  metadata: InstrumentMetadata!

  "A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)"
  product: Product!
}

type MarginCalculator {
  "The scaling factors that will be used for margin calculation"
  scalingFactors: ScalingFactors!
}

type ScalingFactors {
  "the scaling factor that determines the margin level at which Vega has to search for more money"
  searchLevel: Float!

  "the scaling factor that determines the optimal margin level"
  initialMargin: Float!

  "The scaling factor that determines the overflow margin level"
  collateralRelease: Float!
}

"A tradable instrument is a combination of an instrument and a risk model"
type TradableInstrument {
  "An instance of or reference to a fully specified instrument."
  instrument: Instrument!

  "A reference to a risk model that is valid for the instrument"
  riskModel: RiskModel!

  "Margin calculation info, currently only the scaling factors (search, initial, release) for this tradable instrument"
  marginCalculator: MarginCalculator
}

"The factors applied to calculate the fees"
type FeeFactors {
  "The factor applied to calculate MakerFees, a non-negative float"
  makerFee: String!
  "The factor applied to calculate InfrastructureFees, a non-negative float"
  infrastructureFee: String!
  "The factor applied to calculate LiquidityFees, a non-negative float"
  liquidityFee: String!
}

"The fees applicable to a market"
type Fees {
  "The factors used to calculate the different fees"
  factors: FeeFactors!
}

"""
An auction duration is used to configure 3 auction periods:
1. `duration > 0`, `volume == 0`:
The auction will last for at least N seconds.
2. `duration == 0`, `volume > 0`:
The auction will end once we can close with given traded volume.
3. `duration > 0`, `volume > 0`:
The auction will take at least N seconds, but can end sooner if we can trade a certain volume.
"""
type AuctionDuration {
  "Duration of the auction in seconds"
  durationSecs: Int!
  "Target uncrossing trading volume"
  volume: Int!
}

"""
PriceMonitoringParameters holds a list of triggers
"""
type PriceMonitoringParameters {
  "The list of triggers for this price monitoring"
  triggers: [PriceMonitoringTrigger!]
}

"""
PriceMonitoringParameters holds together price projection horizon τ, probability level p, and auction extension duration
"""
type PriceMonitoringTrigger {
  "Price monitoring projection horizon τ in seconds (> 0)."
  horizonSecs: Int!
  "Price monitoring probability level p. (>0 and < 1)"
  probability: Float!
  """
  Price monitoring auction extension duration in seconds should the price
  breach it's theoretical level over the specified horizon at the specified
  probability level (> 0)
  """
  auctionExtensionSecs: Int!
}

"Configuration of a market price monitoring auctions triggers"
type PriceMonitoringSettings {
  "Specified a set of PriceMonitoringParameters to be use for price monitoring purposes"
  parameters: PriceMonitoringParameters
  "How often (in seconds) the price monitoring bounds should be updated"
  updateFrequencySecs: Int!
}

"Range of valid prices and the associated price monitoring trigger"
type PriceMonitoringBounds {
  "Minimum price that isn't currently breaching the specified price monitoring trigger"
  minValidPrice: String!
  "Maximum price that isn't currently breaching the specified price monitoring trigger"
  maxValidPrice: String!
  "Price monitoring trigger associated with the bounds"
  trigger: PriceMonitoringTrigger!
  "Reference price used to calculate the valid price range"
  referencePrice: String!
}

"TargetStakeParameters contains parameters used in target stake calculation"
type TargetStakeParameters {
  "Specifies length of time window expressed in seconds for target stake calculation"
  timeWindow: Int!

  "Specifies scaling factors used in target stake calculation"
  scalingFactor: Float!
}

"Configuration of a market liquidity monitoring parameters"
type LiquidityMonitoringParameters {
  "Specifies parameters related to target stake calculation"
  targetStakeParameters: TargetStakeParameters!
  "Specifies the triggering ratio for entering liquidity auction"
  triggeringRatio: Float!
}

"Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history"
type Market {
  "Market ID"
  id: ID!

  "Market full name"
  name: String!

  "Fees related data"
  fees: Fees!

  "An instance of or reference to a tradable instrument."
  tradableInstrument: TradableInstrument!

  """
  decimalPlaces indicates the number of decimal places that an integer must be shifted by in order to get a correct
  number denominated in the currency of the Market. (uint64)

  Examples:
  Currency     Balance  decimalPlaces  Real Balance
  GBP              100              0       GBP 100
  GBP              100              2       GBP   1.00
  GBP              100              4       GBP   0.01
  GBP                1              4       GBP   0.0001   (  0.01p  )

  GBX (pence)      100              0       GBP   1.00     (100p     )
  GBX (pence)      100              2       GBP   0.01     (  1p     )
  GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
  GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
  """
  decimalPlaces: Int!

  """
  positionDecimalPlaces indicated the number of decimal places that an integer must be shifted in order to get a correct size (uint64).
  i.e. 0 means there are no fractional orders for the market, and order sizes are always whole sizes.
  2 means sizes given as 10^2 * desired size, e.g. a desired size of 1.23 is represented as 123 in this market.
  """
  positionDecimalPlaces: Int!

  """
  Auction duration specifies how long the opening auction will run (minimum
  duration and optionally a minimum traded volume).
  """
  openingAuction: AuctionDuration!

  "Price monitoring settings for the market"
  priceMonitoringSettings: PriceMonitoringSettings!

  "Liquidity monitoring parameters for the market"
  liquidityMonitoringParameters: LiquidityMonitoringParameters!

  "Current mode of execution of the market"
  tradingMode: MarketTradingMode!

  "Current state of the market"
  state: MarketState!

  "The proposal which initiated this market"
  proposal: Proposal

  "Orders on a market"
  orders(
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Order!] @deprecated(reason: "Use the 'ordersPaged' field instead")

  "Orders on a market"
  ordersPaged(
    "Pagination information"
    pagination: Pagination
  ): OrderConnection!

  "Get account for a party or market"
  accounts(
    "Id of the party to get the margin account for"
    partyId: ID
  ): [Account!]

  "Trades on a market"
  trades(
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Trade!] @deprecated(reason: "Use tradesPaged for cursor based pagination instead")

  tradesPaged(pagination: Pagination): TradeConnection!

  "Current depth on the order book for this market"
  depth(
    "Maximum market order book depth (returns whole order book if omitted)"
    maxDepth: Int
  ): MarketDepth!

  "Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params"
  candles(
    "RFC3339Nano encoded time from when to get candles"
    since: String!
    "Interval of the candles"
    interval: Interval!
  ): [Candle]

  "marketData for the given market"
  data: MarketData

  "The list of the liquidity provision commitment for this market"
  liquidityProvisions(
    "An optional party id"
    party: String
  ): [LiquidityProvision!]

  "timestamps for state changes in the market"
  marketTimestamps: MarketTimestamps!

  "risk factors for the market"
  riskFactors: RiskFactor
}

"""
Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
The depth of market measure provides an indication of the liquidity and depth for the instrument.
"""
type MarketDepth {
  "Market id"
  market: Market!

  "Buy side price levels (if available)"
  buy: [PriceLevel!]

  "Sell side price levels (if available)"
  sell: [PriceLevel!]

  "Last trade for the given market (if available)"
  lastTrade: Trade

  "Sequence number for the current snapshot of the market depth"
  sequenceNumber: String!
}

"""
Market Depth Update is a delta to the current market depth which can be used to update the
market depth structure to keep it correct
"""
type MarketDepthUpdate {
  "Market id"
  market: Market!

  "Buy side price levels (if available)"
  buy: [PriceLevel!]

  "Sell side price levels (if available)"
  sell: [PriceLevel!]

  "Sequence number for the current snapshot of the market depth"
  sequenceNumber: String!
}

"Represents a price on either the buy or sell side and all the orders at that price"
type PriceLevel {
  "The price of all the orders at this level (uint64)"
  price: String!

  "The total remaining size of all orders at this level (uint64)"
  volume: String!

  "The number of orders at this price level (uint64)"
  numberOfOrders: String!
}

"Candle stick representation of trading"
type Candle {
  "Unix epoch+nanoseconds for when the candle occurred"
  timestamp: String!

  "RFC3339Nano formatted date and time for the candle"
  datetime: String!

  "High price (uint64)"
  high: String!

  "Low price (uint64)"
  low: String!

  "Open price (uint64)"
  open: String!

  "Close price (uint64)"
  close: String!

  "Volume price (uint64)"
  volume: String!

  "Interval price (string)"
  interval: Interval!
}

"Represents a party on Vega, could be an ethereum wallet address in the future"
type Party {
  "Party identifier"
  id: ID!

  "Orders relating to a party"
  orders(
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Order!] @deprecated(reason: "Use ordersPaged instead")

  "Orders relating to a party"
  ordersPaged(
    "Pagination information"
    pagination: Pagination
  ): OrderConnection!

  "Trades relating to a party (specifically where party is either buyer OR seller)"
  trades(
    "ID of the market we want to get trades for"
    marketId: ID
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Trade!] @deprecated(reason: "Use tradesPaged for cursor based pagination instead")

  tradesPaged(marketId: ID, pagination: Pagination): TradeConnection!

  "Collateral accounts relating to a party"
  accounts(
    "Market ID - specify what market accounts for the party to return"
    marketId: ID
    "Asset (USD, EUR etc)"
    asset: String
    "Filter accounts by type (General account, margin account, etc...)"
    type: AccountType
  ): [Account!]

  "Trading positions relating to a party"
  positions: [Position!]

  "marginLevels"
  margins(
    "market id off the margin to get, nil if all markets"
    marketId: ID
  ): [MarginLevels!]

  proposals(
    "Select only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal]

  votes: [ProposalVote]

  "The list of all withdrawals initiated by the party"
  withdrawals: [Withdrawal!]

  "The list of all deposits for a party by the party"
  deposits: [Deposit!]

  "The list of the liquidity provision commitment from this party"
  liquidityProvisions(
    "An optional market id"
    market: String
    "An optional reference"
    reference: String
  ): [LiquidityProvision!]

  # All delegations for a party to a given node if node is specified, or all delegations if not
  delegations(
    "Optional node"
    nodeId: String
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Delegation!]

  "The staking information for this Party"
  stake: PartyStake!

  "return individual reward information"
  rewards(
    "An optional asset"
    asset: String
    "Pagination skip element"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Reward]

  "return net reward information"
  rewardSummaries(
    "An optional asset"
    asset: String
  ): [RewardSummary]

  "return reward information"
  rewardDetails: [RewardPerAssetDetail] @deprecated(reason: "Use rewardSummaries or rewards instead.")
}

"""
All staking information related to a Party.
Contains the current recognised balance by the network and
all the StakeLink/Unlink seen by the network
"""
type PartyStake {
  "The stake currently available for the party"
  currentStakeAvailable: String!
  "The list of all stake link/unlink for the party"
  linkings: [StakeLinking!]
}

"The type of stake linking"
enum StakeLinkingType {
  "The stake is being linked (deposited) to a vega stake account"
  Link
  "The stake is being unlined (removed) from a vega stake account"
  Unlink
}

"The status of the stake linking"
enum StakeLinkingStatus {
  """
  The stake linking is pending in the vega network, this means that
  the vega network have seen a StakeLinking, but is still to confirm
  it's valid on the ethereum chain, and accepted by all nodes of the network
  """
  Pending
  "The stake linking has been accepted and processed fully (balance updated) by the network"
  Accepted
  "The vega network have rejected this stake linking"
  Rejected
}

"A Stake linking represent the intend from a party to deposit / remove stake on their account"
type StakeLinking {
  id: ID!
  "Type of linking: link|unlink"
  type: StakeLinkingType!
  "The time at which the request happened on ethereum"
  timestamp: String!
  "The party initiating the stake linking"
  party: Party!
  "The amount linked or unlinked"
  amount: String!
  "The status of the linking"
  status: StakeLinkingStatus!
  "The time at which the stake linking was full processed by the vega network, null until defined"
  finalizedAt: String
  "The transaction hash (ethereum) which initiated the link/unlink"
  txHash: String!
}

"""
An individual party at any point in time is considered net long or net short. This refers to their Open Volume,
calculated using FIFO. This volume is signed as either negative for LONG positions and positive for SHORT positions. A
single trade may end up "splitting" with some of its volume matched into closed volume and some of its volume
remaining as open volume. This is why we don't refer to positions being comprised of trades, rather of volume.
"""
type Position {
  "Market relating to this position"
  market: Market!

  "The party holding this position"
  party: Party!

  "Open volume (uint64)"
  openVolume: String!

  "Realised Profit and Loss (int64)"
  realisedPNL: String!

  "Unrealised Profit and Loss (int64)"
  unrealisedPNL: String!

  "Average entry price for this position"
  averageEntryPrice: String!

  "margins of the party for the given position"
  margins: [MarginLevels!]

  "RFC3339Nano time the position was updated"
  updatedAt: String
}

"An order in Vega, if active it will be on the OrderBook for the market"
type Order {
  "Hash of the order data"
  id: ID!

  "The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)"
  price: String!

  "The timeInForce of order (determines how and if it executes, and whether it persists on the book)"
  timeInForce: OrderTimeInForce!

  "Whether the order is to buy or sell"
  side: Side!

  "The market the order is trading on (probably stored internally as a hash of the market details)"
  market: Market

  "Total number of contracts that may be bought or sold (immutable) (uint64)"
  size: String!

  "Number of contracts remaining of the total that have not yet been bought or sold (uint64)"
  remaining: String!

  "The party who place the order (probably stored internally as the party's public key)"
  party: Party!

  "RFC3339Nano formatted date and time for when the order was created (timestamp)"
  createdAt: String!

  "Expiration time of this order (ISO-8601 RFC3339+Nano formatted date)"
  expiresAt: String

  "The status of an order, for example 'Active'"
  status: OrderStatus!

  "The external reference (if available) for the order"
  reference: String!

  "Trades relating to this order"
  trades: [Trade!] @deprecated(reason: "Use tradesPaged instead")

  "Trades relating to this order"
  tradesPaged(pagination: Pagination): TradeConnection!

  "Type the order type (defaults to PARTY)"
  type: OrderType

  "Reason for the order to be rejected"
  rejectionReason: OrderRejectionReason

  "Version of this order, counts the number of amends"
  version: String!

  "RFC3339Nano time the order was altered"
  updatedAt: String

  "PeggedOrder contains the details about a pegged order"
  peggedOrder: PeggedOrder

  "The liquidity provision this order was created from"
  liquidityProvision: LiquidityProvision
}

"An estimate of the fee to be paid by the order"
type OrderEstimate {
  "The estimated fee if the order was to trade"
  fee: TradeFee!

  "The total estimated amount of fee if the order was to trade"
  totalFeeAmount: String!

  "The margin requirement for this order"
  marginLevels: MarginLevels!
}

"A trade on Vega, the result of two orders being 'matched' in the market"
type Trade {
  "The hash of the trade data"
  id: ID!

  "The market the trade occurred on"
  market: Market!

  "The order that bought"
  buyOrder: String!

  "The order that sold"
  sellOrder: String!

  "The party that bought"
  buyer: Party!

  "The party that sold"
  seller: Party!

  "The aggressor indicates whether this trade was related to a BUY or SELL"
  aggressor: Side!

  "The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)"
  price: String!

  "The number of contracts trades, will always be <= the remaining size of both orders immediately before the trade (uint64)"
  size: String!

  "RFC3339Nano time for when the trade occurred"
  createdAt: String!

  "The type of trade"
  type: TradeType!

  "The fee paid by the buyer side of the trade"
  buyerFee: TradeFee!

  "The fee paid by the seller side of the trade"
  sellerFee: TradeFee!

  "The batch in witch the buyer order was submitted (applies only for Auctions modes)"
  buyerAuctionBatch: Int

  "The batch in witch the seller order was submitted (applies only for Auctions modes)"
  sellerAuctionBatch: Int
}

"The fee paid by the party when a trade occurs"
type TradeFee {
  "The maker fee, aggressive party to the other party (the one who had an order in the book)"
  makerFee: String!

  "The infrastructure fee, a fee paid to the node runner to maintain the vega network"
  infrastructureFee: String!

  "The fee paid to the market makers to provide liquidity in the market"
  liquidityFee: String!
}

"Valid trade types"
enum TradeType {
  "Default trade type"
  Default

  "Network close-out - good"
  NetworkCloseOutGood

  "Network close-out - bad"
  NetworkCloseOutBad
}

"An account record"
type Account {
  "Balance as string - current account balance (approx. as balances can be updated several times per second)"
  balance: String!
  "Asset, the 'currency'"
  asset: Asset!
  "Account type (General, Margin, etc)"
  type: AccountType!
  "Market (only relevant to margin accounts)"
  market: Market
}

"All the data related to the approval of a withdrawal from the network"
type Erc20WithdrawalApproval {
  "The source asset in the ethereum network"
  assetSource: String!
  "The amount to be withdrawn"
  amount: String!
  "Timestamp in seconds for expiry of the approval"
  expiry: String!
  "The nonce to be used in the request"
  nonce: String!
  """
  Signature aggregate from the nodes, in the following format:
  0x + sig1 + sig2 + ... + sigN
  """
  signatures: String!
  "The target address which will receive the funds"
  targetAddress: String!
}

"The details of a withdrawal processed by vega"
type Withdrawal {
  "The Vega internal id of the withdrawal"
  id: ID!
  "The PartyID initiating the withdrawal"
  party: Party!
  "The amount to be withdrawn"
  amount: String!
  "The asset to be withdrawn"
  asset: Asset!
  "The current status of the withdrawal"
  status: WithdrawalStatus!
  "A reference the foreign chain can use to refer to when processing the withdrawal"
  ref: String!
  "RFC3339Nano time until the withdrawal will be invalid"
  expiry: String!
  "RFC3339Nano time at which the withdrawal was created"
  createdTimestamp: String!
  "RFC3339Nano time at which the withdrawal was finalized"
  withdrawnTimestamp: String
  "Hash of the transaction on the foreign chain"
  txHash: String
  "Foreign chain specific details about the withdrawal"
  details: WithdrawalDetails
}

union WithdrawalDetails = Erc20WithdrawalDetails

"Specific details for an erc20 withdrawal"
type Erc20WithdrawalDetails {
  "The ethereum address of the receiver of the asset funds"
  receiverAddress: String!
}

"The status of a withdrawal"
enum WithdrawalStatus {
  "The withdrawal is open and being processed by the network"
  Open
  "The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain"
  Rejected
  "The withdrawal was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts"
  Finalized
}

"The details of a deposit processed by vega"
type Deposit {
  "The Vega internal id of the deposit"
  id: ID!
  "The PartyID initiating the deposit"
  party: Party!
  "The amount to be withdrawn"
  amount: String!
  "The asset to be withdrawn"
  asset: Asset!
  "The current status of the deposit"
  status: DepositStatus!
  "RFC3339Nano time at which the deposit was created"
  createdTimestamp: String!
  "RFC3339Nano time at which the deposit was finalized"
  creditedTimestamp: String
  "Hash of the transaction on the foreign chain"
  txHash: String
}

"The status of a deposit"
enum DepositStatus {
  "The deposit is open and being processed by the network"
  Open
  "The deposit have been cancelled by the network, either because it expired, or something went wrong with the foreign chain"
  Cancelled
  "The deposit was finalized, it was first valid, the foreign chain has executed it and the network updated all accounts"
  Finalized
}

"Valid order types, these determine what happens when an order is added to the book"
enum OrderTimeInForce {
  "The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade"
  FOK

  "The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)"
  IOC

  "This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled"
  GTC

  """
  This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
  NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
  """
  GTT

  "This order is only accepted during an auction period"
  GFA

  "This order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"
  GFN
}

"Valid references used for pegged orders."
enum PeggedReference {
  "Peg the order against the mid price of the order book"
  Mid
  "Peg the order against the best bid price of the order book"
  BestBid
  "Peg the order against the best ask price of the order book"
  BestAsk
}

"Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order."
enum OrderStatus {
  """
  The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
  Active does not necessarily mean it's still on the order book.
  """
  Active

  "This order trades any amount and as much as possible and remains on the book until it either trades completely or expires."
  Expired

  "The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining."
  Cancelled

  "This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity."
  Stopped

  "This order is fully filled with remaining equals zero."
  Filled

  "This order was rejected while being processed in the core."
  Rejected

  "This order was partially filled."
  PartiallyFilled

  "This order has been removed from the order book and applies to pegged orders only"
  Parked
}

"Reason for the proposal being rejected by the core node"
enum ProposalRejectionReason {
  "The specified close time is too early based on network parameters"
  CloseTimeTooSoon
  "The specified close time is too late based on network parameters"
  CloseTimeTooLate
  "The specified enactment time is too early based on network parameters"
  EnactTimeTooSoon
  "The specified enactment time is too late based on network parameters"
  EnactTimeTooLate
  "The proposer for this proposal has insufficient token"
  InsufficientTokens
  "The instrument quote name and base name were the same"
  InvalidInstrumentSecurity
  "The proposal has no product specified"
  NoProduct
  "The specified product is not supported"
  UnsupportedProduct
  "Invalid future maturity timestamp (expect RFC3339)"
  InvalidFutureMaturityTimestamp
  "The product maturity is already in the past"
  ProductMaturityIsPassed
  "The proposal has no trading mode"
  NoTradingMode
  "The proposal has an unsupported trading mode"
  UnsupportedTradingMode
  "The proposal failed node validation"
  NodeValidationFailed
  "A builtin asset configuration is missing"
  MissingBuiltinAssetField
  "The ERC20 contract address is missing from an ERC20 asset proposal"
  MissingERC20ContractAddress
  "The specified asset for the market proposal is invalid"
  InvalidAsset
  "proposal terms timestamps are not compatible (Validation < Closing < Enactment)"
  IncompatibleTimestamps
  "Risk parameters are missing from the market proposal"
  NoRiskParameters
  "Invalid key in update network parameter proposal"
  NetworkParameterInvalidKey
  "Invalid value in update network parameter proposal"
  NetworkParameterInvalidValue
  "Validation failed for network parameter proposal"
  NetworkParameterValidationFailed
  "Opening auction duration is less than the network minimum opening auction time"
  OpeningAuctionDurationTooSmall
  "Opening auction duration is more than the network minimum opening auction time"
  OpeningAuctionDurationTooLarge
  "Market proposal is missing a liquidity commitment"
  MarketMissingLiquidityCommitment
  "Market proposal market could not be instantiate in execution"
  CouldNotInstantiateMarket
  "Market proposal market contained invalid product definition"
  InvalidFutureProduct
  "Market proposal is missing commitment amount"
  MissingCommitmentAmount
  "Market proposal have invalid fee amount"
  InvalidFeeAmount
  "Market proposal have one or more invalid shape"
  InvalidShape
  "Market proposal use an invalid risk parameter"
  InvalidRiskParameter
  "Proposal declined because the majority threshold was not reached"
  MajorityThresholdNotReached
  "Proposal declined because the participation threshold was not reached"
  ParticipationThresholdNotReached
  "Asset details are invalid"
  InvalidAssetDetails
}

"Reason for the order being rejected by the core node"
enum OrderRejectionReason {
  "Market id is invalid"
  InvalidMarketId

  "Order id is invalid"
  InvalidOrderId

  "Order is out of sequence"
  OrderOutOfSequence

  "Remaining size in the order is invalid"
  InvalidRemainingSize

  "Time has failed us"
  TimeFailure

  "Unable to remove the order"
  OrderRemovalFailure

  "Expiration time is invalid"
  InvalidExpirationTime

  "Order reference is invalid"
  InvalidOrderReference

  "Edit is not allowed"
  EditNotAllowed

  "Order amend fail"
  OrderAmendFailure

  "Order does not exist"
  OrderNotFound

  "Party id is invalid"
  InvalidPartyId

  "Market is closed"
  MarketClosed

  "Margin check failed"
  MarginCheckFailed

  "Order missing general account"
  MissingGeneralAccount

  "An internal error happened"
  InternalError

  "Invalid size"
  InvalidSize

  "Invalid persistence"
  InvalidPersistence

  "Invalid type"
  InvalidType

  "Self trading"
  SelfTrading

  "Insufficient funds to pay fees"
  InsufficientFundsToPayFees

  "Invalid Time In Force"
  InvalidTimeInForce

  "Attempt to amend order to GTT without ExpiryAt"
  AmendToGTTWithoutExpiryAt

  "Attempt to amend ExpiryAt to a value before CreatedAt"
  ExpiryAtBeforeCreatedAt

  "Attempt to amend to GTC without an ExpiryAt value"
  GTCWithExpiryAtNotValid

  "Amending to FOK or IOC is invalid"
  CannotAmendToFOKOrIOC

  "Amending to GFA or GFN is invalid"
  CannotAmendToGFAOrGFN

  "Amending from GFA or GFN is invalid"
  CannotAmendFromGFAOrGFN

  "Invalid Market Type"
  InvalidMarketType

  "Good for normal order received during an auction"
  GFNOrderDuringAuction

  "Good for auction order received during continuous trading"
  GFAOrderDuringContinuousTrading

  "IOC orders are not allowed during auction"
  IOCOrderDuringAuction

  "FOK orders are not allowed during auction"
  FOKOrderDuringAuction

  "Pegged orders must be LIMIT orders"
  PeggedOrderMustBeLimitOrder

  "Pegged orders can only have TIF GTC or GTT"
  PeggedOrderMustBeGTTOrGTC

  "Pegged order must have a reference price"
  PeggedOrderWithoutReferencePrice

  "Buy pegged order cannot reference best ask price"
  PeggedOrderBuyCannotReferenceBestAskPrice

  "Pegged order offset must be >= 0"
  PeggedOrderOffsetMustBeGreaterOrEqualToZero

  "Sell pegged order cannot reference best bid price"
  PeggedOrderSellCannotReferenceBestBidPrice

  "Pegged order offset must be > zero"
  PeggedOrderOffsetMustBeGreaterThanZero

  "Insufficient balance to submit the order (no deposit made)"
  InsufficientAssetBalance

  "Cannot change pegged order fields on a non pegged order"
  CannotAmendPeggedOrderDetailsOnNonPeggedOrder

  "Unable to reprice a pegged order"
  UnableToRepricePeggedOrder

  "Unable to amend pegged order price"
  UnableToAmendPeggedOrderPrice

  "Non-persistent order exceeds price bounds"
  NonPersistentOrderExceedsPriceBounds
}

enum OrderType {
  "the default order type"
  Market

  "mentioned in ticket, but as yet unused order type"
  Limit

  """
  Used for distressed parties, an order placed by the network to close out distressed parties
  similar to Market order, only no party is attached to the order.
  """
  Network
}

"The current state of a market"
enum MarketState {
  "The Governance proposal valid and accepted"
  Proposed
  "Outcome of governance votes is to reject the market"
  Rejected
  "Governance vote passes/wins"
  Pending
  """
  Market triggers cancellation condition or governance
  votes to close before market becomes Active
  """
  Cancelled
  "Enactment date reached and usual auction exit checks pass"
  Active
  "Price monitoring or liquidity monitoring trigger"
  Suspended
  "Governance vote (to close)"
  Closed
  """
  Defined by the product (i.e. from a product parameter,
  specified in market definition, giving close date/time)
  """
  TradingTerminated
  "Settlement triggered and completed as defined by product"
  Settled
}

"What market trading mode are we in"
enum MarketTradingMode {
  "Continuous trading where orders are processed and potentially matched on arrival"
  Continuous

  "Auction trading where orders are uncrossed at the end of the opening auction period"
  OpeningAuction

  "Auction as normal trading mode for the market, where orders are uncrossed periodically"
  BatchAuction

  "Auction triggered by price/liquidity monitoring"
  MonitoringAuction
}

"Whether the placer of an order is aiming to buy or sell on the market"
enum Side {
  "The Placer of the order is aiming to buy"
  Buy

  "The placer of the order is aiming to sell"
  Sell
}

"The interval for trade candles when subscribing via VEGA graphql, default is I15M"
enum Interval {
  "1 minute interval"
  I1M

  "5 minute interval"
  I5M

  "15 minute interval (default)"
  I15M

  "1 hour interval"
  I1H

  "6 hour interval"
  I6H

  "1 day interval"
  I1D
}

"The various account types we have (used by collateral)"
enum AccountType {
  "Insurance pool account - only for 'system' party"
  Insurance
  "Global insurance pool account for an asset"
  GlobalInsurance
  "Settlement - only for 'system' party"
  Settlement
  "Margin - The leverage account for parties"
  Margin
  "General account - the account containing 'unused' collateral for parties"
  General
  "Infrastructure fee account - the account where all infrastructure fees are collected"
  FeeInfrastructure
  "Liquidity fee account - the account contains fees earned by providing liquidity"
  FeeLiquidity
  "Market maker fee account - holds fees paid to the passive side when a trade matches"
  FeeMaker
  "LockWithdraw - and account use for party in the process of withdrawing funds"
  LockWithdraw
  "Bond - an account use to maintain MM commitments"
  Bond
  "External - an account use to refer to external account"
  External
  "GlobalReward - an global account for the reward pool"
  GlobalReward
  "PendingTransfers - an global account for the pending transfers pool"
  PendingTransfers
  "RewardTakerPaidFees - an account holding rewards for taker paid fees"
  RewardTakerPaidFees
  "RewardMakerReceivedFees - an account holding rewards for maker received fees"
  RewardMakerReceivedFees
  "RewardLpReceivedFees - an account holding rewards for LP received fees"
  RewardLpReceivedFees
  "RewardMarketProposers - an account holding rewards for market proposers"
  RewardMarketProposers
}

type FutureProduct {
  "Product asset ID"
  settlementAsset: Asset!
  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!
  """
  Describes the oracle data that an instrument wants to get from the oracle engine for settlement price.
  """
  oracleSpecForSettlementPrice: OracleSpecConfiguration!
  """
  Describes the oracle data that an instrument wants to get from the oracle engine for trading termination.
  """
  oracleSpecForTradingTermination: OracleSpecConfiguration!
  """
  OracleSpecToFutureBinding tells on which property oracle data should be
  used as settlement price.
  """
  oracleSpecBinding: OracleSpecToFutureBinding!
}

"""
An oracle spec describe the oracle data that an instrument wants to get from the
oracle engine.
"""
type OracleSpecConfiguration {
  """
  pubKeys is the list of authorized public keys that signed the data for this
  oracle. All the public keys in the oracle data should be contained in these
  public keys.
  """
  pubKeys: [String!]
  """
  filters describes which oracle data are considered of interest or not for
  the product (or the risk model).
  """
  filters: [Filter!]
}

type InstrumentConfiguration {
  "Full and fairly descriptive name for the instrument"
  name: String!
  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)"
  code: String!
  "Future product specification"
  futureProduct: FutureProduct
}

type NewMarket {
  "New market instrument configuration"
  instrument: InstrumentConfiguration!
  "Decimal places used for the new market"
  decimalPlaces: Int!
  "New market risk configuration"
  riskParameters: RiskModel!
  "Metadata for this instrument, tags"
  metadata: [String!]
  "The liquidity commitment submitted with the new market"
  commitment: NewMarketCommitment
}

"A commitment of liquidity to be made by the party which proposes a market"
type NewMarketCommitment {
  "Specified as a unit-less number that represents the amount of settlement asset of the market"
  commitmentAmount: String!
  """
  Nominated liquidity fee factor, which is an input to the calculation of
  taker fees on the market, as per setting fees and rewarding liquidity provider
  """
  fee: String!
  "A set of liquidity sell orders to meet the liquidity provision obligation"
  sells: [LiquidityOrder!]
  "A set of liquidity buy orders to meet the liquidity provision obligation"
  buys: [LiquidityOrder!]
  "A reference to be associated to all orders created from this commitment"
  reference: String
}

"""
Incomplete change definition for governance proposal terms
TODO: complete the type
"""
type UpdateMarket {
  marketId: ID!
  updateMarketConfiguration: UpdateMarketConfiguration!
}

type UpdateMarketConfiguration {
  instrument: UpdateInstrumentConfiguration!
  metadata: [String]
  priceMonitoringParameters: PriceMonitoringParameters!
  liquidityMonitoringParameters: LiquidityMonitoringParameters!
  riskParameters: UpdateMarketRiskParameters!
}

type UpdateInstrumentConfiguration {
  code: String!
  product: UpdateFutureProduct!
}

type UpdateFutureProduct {
  quoteName: String!
  oracleSpecForSettlementPrice: OracleSpecConfiguration!
  oracleSpecForTradingTermination: OracleSpecConfiguration!
  oracleSpecBinding: OracleSpecToFutureBinding!
}

union UpdateMarketRiskParameters = UpdateMarketSimpleRiskModel | UpdateMarketLogNormalRiskModel

type UpdateMarketSimpleRiskModel {
  simple: SimpleRiskModelParams
}

type UpdateMarketLogNormalRiskModel {
  logNormal: LogNormalRiskModel
}

"A new asset proposal change"
type NewAsset {
  "The full name of the asset (e.g: Great British Pound)"
  name: String!

  "The symbol of the asset (e.g: GBP)"
  symbol: String!

  "The total supply of the market"
  totalSupply: String!

  "The precision of the asset"
  decimals: Int!

  "The min stake to become an lp for any market using this asset for settlement"
  minLpStake: String!

  "the source of the new Asset"
  source: AssetSource!
}

"""
A new freeform proposal change. It has no properties on purpose. Use proposal
rationale, instead.
"""
type NewFreeform {
  "A placeholder to please graphQL"
  _doNotUse: Boolean
}

"Allows submitting a proposal for changing network parameters"
type UpdateNetworkParameter {
  networkParameter: NetworkParameter!
}

"Representation of a network parameter"
type NetworkParameter {
  "The name of the network parameter"
  key: String!
  "The value of the network parameter"
  value: String!
}

union ProposalChange =
  NewMarket
  | UpdateMarket
  | UpdateNetworkParameter
  | NewAsset
  | NewFreeform
# there are no unions for input types as of today, see: https://github.com/graphql/graphql-spec/issues/488

type ProposalRationale {
  """
  Description to show a short title / something in case the link goes offline.
  This is to be between 0 and 1024 unicode characters.
  This is mandatory for all proposal.
  """
  description: String!
  """
  Cryptographically secure hash (SHA3-512) of the text pointed by the `url` property
  so that viewers can check that the text hasn't been changed over time.
  Optional except for FreeFrom proposal where it's mandatory.
  If set, the `url` property must be set.
  """
  hash: String
  """
  Link to a text file describing the proposal in depth.
  Optional except for FreeFrom proposal where it's mandatory.
  If set, the `url` property must be set.
  """
  url: String
}

"The rationale behind the proposal"
type ProposalTerms {
  """
  RFC3339Nano time and date when voting closes for this proposal.
  Constrained by "minClose" and "maxClose" network parameters.
  """
  closingDatetime: String!
  """
  RFC3339Nano time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
  Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
  """
  enactmentDatetime: String!

  "Actual change being introduced by the proposal - action the proposal triggers if passed and enacted."
  change: ProposalChange!
}

"""
Various states a proposal can transition through:
Open ->
- Passed -> Enacted.
- Rejected.
Proposal can enter Failed state from any other state.
"""
enum ProposalState {
  "Proposal became invalid and cannot be processed"
  Failed
  "Proposal is open for voting"
  Open
  "Proposal has gained enough support to be executed"
  Passed
  "Proposal didn't get enough votes"
  Declined
  "Proposal could not gain enough support to be executed"
  Rejected
  "Proposal has been executed and the changes under this proposal have now been applied"
  Enacted
  "Proposal is waiting for the node to run validation"
  WaitingForNodeVote
}

type Proposal {
  "Proposal ID that is filled by VEGA once proposal reaches the network"
  id: ID
  "A UUID reference to aid tracking proposals on VEGA"
  reference: String!
  "Party that prepared the proposal"
  party: Party!
  "State of the proposal"
  state: ProposalState!
  "RFC3339Nano time and date when the proposal reached Vega network"
  datetime: String!
  "Rationale behind the proposal"
  rationale: ProposalRationale!
  "Terms of the proposal"
  terms: ProposalTerms!
  "Votes cast for this proposal"
  votes: ProposalVotes!
  "Reason for the proposal to be rejected by the core"
  rejectionReason: ProposalRejectionReason
  "Error details of the rejectionReason"
  errorDetails: String
}

type ProposalVotes {
  "Yes votes cast for this proposal"
  yes: ProposalVoteSide!
  "No votes cast for this proposal"
  no: ProposalVoteSide!
}

type ProposalVoteSide {
  "All votes casted for this side"
  votes: [Vote!]
  "Total number of votes casted for this side"
  totalNumber: String!
  "Total weight of governance token from the votes casted for this side"
  totalWeight: String!
  "Total tokens of governance token from the votes casted for this side"
  totalTokens: String!
}

enum VoteValue {
  "No reject a proposal"
  No
  "Yes accept a proposal"
  Yes
}

type Vote {
  "The vote value cast"
  value: VoteValue!

  "The party casting the vote"
  party: Party!

  "RFC3339Nano time and date when the vote reached Vega network"
  datetime: String!

  "The ID of the proposal this vote applies to"
  proposalId: ID!

  "Total number of governance token for the party that casted the vote"
  governanceTokenBalance: String!

  "The weight of this vote based on the total of governance token"
  governanceTokenWeight: String!
}

type ProposalVote {
  "Cast vote"
  vote: Vote!

  "Proposal casting the vote on"
  proposalId: ID!
}

type TimeUpdate {
  "RFC3339Nano time of new block time"
  timestamp: String!
}

type MarketEvent {
  "the market ID"
  marketId: ID!
  "the message - market events are used for logging"
  payload: String!
}

type TransferBalance {
  "Account involved in transfer"
  account: Account!
  "The new balance of the account"
  balance: String!
}

type LedgerEntry {
  "account from which the asset was taken"
  fromAccount: String!
  "account to which the balance was transferred"
  toAccount: String!
  "the amount transferred"
  amount: String!
  "The transfer reference"
  reference: String!
  "Type of ledger entry"
  type: String!
  "RFC3339Nano time at which the transfer was made"
  timestamp: String!
}

type TransferResponse {
  "the ledger entries and balances resulting from a transfer request"
  transfers: [LedgerEntry!]
  "the balances of accounts involved in the transfer"
  balances: [TransferBalance!]
}

type TransferResponses {
  "a group of transfer responses - events from core"
  responses: [TransferResponse!]
}

type PositionResolution {
  "the market ID where position resolution happened"
  marketId: ID!
  "number of distressed parties on market"
  distressed: Int!
  "number of parties closed out"
  closed: Int!
  "the mark price at which parties were distressed/closed out"
  markPrice: String!
}

type LossSocialization {
  "the market ID where loss socialization happened"
  marketId: ID!
  "the party that was part of the loss socialization"
  partyId: ID!
  "the amount lost"
  amount: String!
}

type TradeSettlement {
  "the size of the trade"
  size: Int!
  "the price of the trade"
  price: String!
}

type SettlePosition {
  "the market in which a position was settled"
  marketId: ID!
  "the party who settled a position"
  partyId: ID!
  "the settle price"
  price: String!
  "the trades that were settled to close the overall position"
  tradeSettlements: [TradeSettlement!]
}

type SettleDistressed {
  "the market in which a position was closed out"
  marketId: ID!
  "the party who closed out"
  partyId: ID!
  "the margin taken from distressed party"
  margin: String!
  "the price at which position was closed out"
  price: String!
}

type MarketTick {
  "the market ID"
  marketId: ID!
  "the block time"
  time: String!
}

type AuctionEvent {
  "the market ID"
  marketId: ID!
  "event fired because of auction end"
  leave: Boolean!
  "event related to opening auction"
  openingAuction: Boolean!
  "RFC3339Nano start time of auction"
  auctionStart: String!
  "RFC3339Nano optional end time of auction"
  auctionEnd: String!
  "What triggered the auction"
  trigger: AuctionTrigger!
  "What, if anything, extended the ongoing auction"
  extensionTrigger: AuctionTrigger
}

enum AuctionTrigger {
  "Invalid trigger (or no auction)"
  Unspecified
  "Auction because market is trading FBA"
  Batch
  "Opening auction"
  Opening
  "Price monitoring"
  Price
  "Liquidity monitoring"
  Liquidity
}

enum BusEventType {
  "Vega Time has changed"
  TimeUpdate
  "A balance has been transferred between accounts"
  TransferResponses
  "A position resolution event has occurred"
  PositionResolution
  "An order has been created or updated"
  Order
  "An account has been updated"
  Account
  "A party has been updated"
  Party
  "A trade has been created"
  Trade
  "Margin levels have changed for a position"
  MarginLevels
  "A governance proposal has been created or updated"
  Proposal
  "A vote has been placed on a governance proposal"
  Vote
  "Market data has been updated"
  MarketData
  "Validator nodes signatures for an event"
  NodeSignature
  "A position has been closed without sufficient insurance pool balance to cover it"
  LossSocialization
  "A position has been settled"
  SettlePosition
  "A distressed position has been settled"
  SettleDistressed
  "A new market has been created"
  MarketCreated
  "A market has been updated"
  MarketUpdated
  "An asset has been created or update"
  Asset
  "A market has progressed by one tick"
  MarketTick
  "A market has either entered or exited auction"
  Auction
  "A risk factor adjustment was made"
  RiskFactor
  "A liquidity commitment change occurred"
  LiquidityProvision
  "Collateral has deposited in to this Vega network via the bridge"
  Deposit
  "Collateral has been withdrawn from this Vega network via the bridge"
  Withdrawal
  "An oracle spec has been registered"
  OracleSpec
  "constant for market events - mainly used for logging"
  Market
}

"union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind"
union Event =
  TimeUpdate
  | MarketEvent
  | TransferResponses
  | PositionResolution
  | Order
  | Trade
  | Account
  | Party
  | MarginLevels
  | Proposal
  | Vote
  | MarketData
  | NodeSignature
  | LossSocialization
  | SettlePosition
  | Market
  | Asset
  | MarketTick
  | SettleDistressed
  | AuctionEvent
  | RiskFactor
  | Deposit
  | Withdrawal
  | OracleSpec
  | LiquidityProvision

type BusEvent {
  "the id for this event"
  eventId: ID!
  "the block hash"
  block: String!
  "the type of event we're dealing with"
  type: BusEventType!
  "the payload - the wrapped event"
  event: Event!
}

"A risk factor emitted by the risk model for a given market"
type RiskFactor {
  "market the risk factor was emitted for"
  market: String!
  "short factor"
  short: String!
  "long factor"
  long: String!
}

"A special order type for liquidity providers"
type LiquidityOrder {
  "The value to which this order is tied"
  reference: PeggedReference!
  "The proportion of the commitment allocated to this order"
  proportion: Int!
  "Offset from the pegged reference"
  offset: String!
}

"Status of a liquidity provision order"
enum LiquidityProvisionStatus {
  "An active liquidity provision"
  Active
  "A liquidity provision stopped by the network"
  Stopped
  "A Cancelled Liquidity provision"
  Cancelled
  "A liquidity provision was invalid and got rejected"
  Rejected
  "The liquidity provision is valid and accepted by network, but orders aren't deployed"
  Undeployed
  """
  The liquidity provision is valid and accepted by network, but orders aren't deployed.
  but have never been deployed. I when it's possible to deploy them for the first time
  margin check fails, then they will be cancelled without any penalties.
  """
  Pending
}

type LiquidityOrderReference {
  "The id of the pegged order generated to fulfill this commitment"
  order: Order
  "The liquidity order"
  liquidityOrder: LiquidityOrder!
}

"The command to be sent to the chain for a liquidity provision submission"
type LiquidityProvision {
  "Unique identifier for the order (set by the system after consensus)"
  id: ID
  "The Id of the party making this commitment"
  party: Party!
  "When the liquidity provision was initially created (formatted RFC3339)"
  createdAt: String!
  "RFC3339Nano time of when the liquidity provision was updated"
  updatedAt: String
  "Market identifier for the order"
  market: Market!
  "Specified as a unit-less number that represents the amount of settlement asset of the market."
  commitmentAmount: String!
  "nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers."
  fee: String!
  "a set of liquidity sell orders to meet the liquidity provision obligation, see MM orders spec."
  sells: [LiquidityOrderReference!]!
  "a set of liquidity buy orders to meet the liquidity provision obligation, see MM orders spec."
  buys: [LiquidityOrderReference!]!
  "The version of this LiquidityProvision"
  version: String!
  "The current status of this liquidity provision"
  status: LiquidityProvisionStatus!
  "A reference for the orders created out of this Liquidity provision"
  reference: String
}

"Reward information for a single party"
type Reward {
  "The asset this reward is paid in"
  asset: Asset!
  "The market for which this reward is paid if any"
  marketID: String!
  "The type of reward"
  rewardType: String!
  "Party receiving the reward"
  party: Party!
  "Epoch for which this reward was distributed"
  epoch: Epoch!
  "Amount received for this reward"
  amount: String!
  "Percentage out of the total distributed reward"
  percentageOfTotal: String!
  "Time at which the rewards was received"
  receivedAt: String!
}

type RewardSummary {
  "The asset for which these rewards are associated"
  asset: Asset!
  "Total quantity of rewards awarded in this asset"
  amount: String!
  "List of individual reward payouts, ordered by epoch"
  rewards (
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Reward]
}

"RewardPerAssetDetail is depricated, use RewardSummmary instead "
type RewardPerAssetDetail {
  "Asset in which the reward was paid"
  asset: Asset!
  "Id of asset in which the reward was paid"
  assetId: String! @deprecated(reason: "Use asset{id} instead")
  "A list of rewards received for this asset"
  rewards: [Reward]
  "The total amount of rewards received for this asset."
  totalAmount: String!
}

scalar Timestamp

type AggregatedBalance {
  "RFC3339Nano time from at which this balance was relevant"
  timestamp: Timestamp!
  "Net balance of the accounts specified in the filter at this time"
  balance: String!
  "Account identifier, if query was grouped by account - else null"
  accountId: String
  "Party identifier, if query was grouped by party - else null"
  partyId: String
  "Asset identifier, if query was grouped by asset - else null"
  assetId: String
  "Market identifier, if query was grouped by market - else null"
  marketId: String
  "Account type, if query was grouped by account type - else null"
  accountType: AccountType
}

enum AccountField {
  AccountId
  PartyId
  AssetId
  MarketId
  AccountType
}

"Information about whether proposals are enabled, if we are still bootstrapping etc.."
type NetworkLimits {
  "Are market proposals allowed at this point in time"
  canProposeMarket: Boolean!
  "Are asset proposals allowed at this point in time"
  canProposeAsset: Boolean!
  "True once block count > bootstrapBlockCount"
  bootstrapFinished: Boolean!
  "Are market proposals enabled on this chain"
  proposeMarketEnabled: Boolean!
  "Are asset proposals enabled on this chain"
  proposeAssetEnabled: Boolean!
  "How many blocks before the chain comes out of bootstrap mode"
  bootstrapBlockCount: Int!
  "True once the genesis file is loaded"
  genesisLoaded: Boolean!
  "The date/timestamp in unix nanoseconds at which market proposals will be enabled (0 indicates not set)"
  proposeMarketEnabledFrom: Timestamp!
  "The date/timestamp in unix nanoseconds at which asset proposals will be enabled (0 indicates not set)"
  proposeAssetEnabledFrom: Timestamp!
}

input OffsetPagination {
  "Skip the number of records specified, default is 0"
  skip: Int!
  "Limit the number of returned records to the value specified, default is 50"
  limit: Int!
  """
  Descending reverses the order of the records returned
  default is true, if false the results will be returned in ascending order
  """
  descending: Boolean!
}

"""
Pagination constructs to support cursor based pagination in the API
"""
input Pagination {
  first: Int
  after: String
  last: Int
  before: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type TradeEdge {
  node: Trade!
  cursor: String!
}

type TradeConnection {
  "The total number of trades in this connection"
  totalCount: Int!
  "The trade in this connection"
  edges: [TradeEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Represents a party on Vega, could be an ethereum wallet address in the future using a cursor pagination model"
type PaginatedParty {
  "Party identifier"
  id: ID!

  "Orders relating to a party"
  ordersPaged(
    "Pagination"
    pagination: Pagination
  ): OrderConnection!

  "Trades relating to a party (specifically where party is either buyer OR seller)"
  tradesPaged(
    "ID of the market we want to get trades for"
    marketId: ID
    pagination: Pagination
  ): TradeConnection!

  "Collateral accounts relating to a party"
  accounts(
    "Market ID - specify what market accounts for the party to return"
    marketId: ID
    "Asset (USD, EUR etc)"
    asset: String
    "Filter accounts by type (General account, margin account, etc...)"
    type: AccountType
  ): [Account!]

  "Trading positions relating to a party"
  positions: [Position!]

  "marginLevels"
  margins(
    "market id off the margin to get, nil if all markets"
    marketId: ID
  ): [MarginLevels!]

  proposals(
    "Select only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal]

  votes: [ProposalVote]

  "The list of all withdrawals initiated by the party"
  withdrawals: [Withdrawal!]

  "The list of all deposits for a party by the party"
  deposits: [Deposit!]

  "The list of the liquidity provision commitment from this party"
  liquidityProvisions(
    "An optional market id"
    market: String
    "An optional reference"
    reference: String
  ): [LiquidityProvision!]

  # All delegations for a party to a given node if node is specified, or all delegations if not
  delegations(
    "Optional node"
    nodeId: String
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Delegation!]

  "The staking information for this Party"
  stake: PartyStake!

  "return individual reward information"
  rewards(
    "An optional asset"
    asset: String
    "Pagination skip element"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Reward]

  "return net reward information"
  rewardSummaries("An optional asset" asset: String): [RewardSummary]
}

type PartyEdge {
  node: PaginatedParty!
  cursor: String!
}

type PartyConnection {
  "The total number of parties in this connection"
  totalCount: Int!
  "The parties in this connection"
  edges: [PartyEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history"
type PaginatedMarket {
  "Market ID"
  id: ID!

  "Market full name"
  name: String!

  "Fees related data"
  fees: Fees!

  "An instance of or reference to a tradable instrument."
  tradableInstrument: TradableInstrument!

  """
  decimalPlaces indicates the number of decimal places that an integer must be shifted by in order to get a correct
  number denominated in the currency of the Market. (uint64)

  Examples:
  Currency     Balance  decimalPlaces  Real Balance
  GBP              100              0       GBP 100
  GBP              100              2       GBP   1.00
  GBP              100              4       GBP   0.01
  GBP                1              4       GBP   0.0001   (  0.01p  )

  GBX (pence)      100              0       GBP   1.00     (100p     )
  GBX (pence)      100              2       GBP   0.01     (  1p     )
  GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
  GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
  """
  decimalPlaces: Int!

  """
  positionDecimalPlaces indicated the number of decimal places that an integer must be shifted in order to get a correct size (uint64).
  i.e. 0 means there are no fractional orders for the market, and order sizes are always whole sizes.
  2 means sizes given as 10^2 * desired size, e.g. a desired size of 1.23 is represented as 123 in this market.
  """
  positionDecimalPlaces: Int!

  """
  Auction duration specifies how long the opening auction will run (minimum
  duration and optionally a minimum traded volume).
  """
  openingAuction: AuctionDuration!

  "Price monitoring settings for the market"
  priceMonitoringSettings: PriceMonitoringSettings!

  "Liquidity monitoring parameters for the market"
  liquidityMonitoringParameters: LiquidityMonitoringParameters!

  "Current mode of execution of the market"
  tradingMode: MarketTradingMode!

  "Current state of the market"
  state: MarketState!

  "The proposal which initiated this market"
  proposal: Proposal

  "Orders on a market"
  ordersPaged(
    "Pagination information"
    pagination: Pagination
  ): OrderConnection

  "Get account for a party or market"
  accounts(
    "Id of the party to get the margin account for"
    partyId: ID
  ): [Account!]

  "Trades on a market"
  tradesPaged(
    "Cursor based page information to retrieve"
    pagination: Pagination
  ): TradeConnection!

  "Current depth on the order book for this market"
  depth(
    "Maximum market order book depth (returns whole order book if omitted)"
    maxDepth: Int
  ): MarketDepth!

  "Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params"
  candles(
    "RFC3339Nano encoded time from when to get candles"
    since: String!
    "Interval of the candles"
    interval: Interval!
  ): [Candle]

  "marketData for the given market"
  data: MarketData

  "The list of the liquidity provision commitment for this market"
  liquidityProvisions(
    "An optional party id"
    party: String
  ): [LiquidityProvision!]

  "timestamps for state changes in the market"
  marketTimestamps: MarketTimestamps!

  "risk factors for the market"
  riskFactors: RiskFactor
}

type MarketEdge {
  node: PaginatedMarket!
  cursor: String!
}

type MarketConnection {
  "The total number of markets in this connection"
  totalCount: Int!
  "The markets in this connection"
  edges: [MarketEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"""
An order in Vega, if active it will be on the OrderBook for the market, this version supports cursor based
pagination in sub-queries for trades"""
type PaginatedOrder {
  "Hash of the order data"
  id: ID!

  "The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)"
  price: String!

  "The timeInForce of order (determines how and if it executes, and whether it persists on the book)"
  timeInForce: OrderTimeInForce!

  "Whether the order is to buy or sell"
  side: Side!

  "The market the order is trading on (probably stored internally as a hash of the market details)"
  market: Market

  "Total number of contracts that may be bought or sold (immutable) (uint64)"
  size: String!

  "Number of contracts remaining of the total that have not yet been bought or sold (uint64)"
  remaining: String!

  "The party who place the order (probably stored internally as the party's public key)"
  party: Party!

  "RFC3339Nano formatted date and time for when the order was created (timestamp)"
  createdAt: String!

  "Expiration time of this order (ISO-8601 RFC3339+Nano formatted date)"
  expiresAt: String

  "The status of an order, for example 'Active'"
  status: OrderStatus!

  "The external reference (if available) for the order"
  reference: String!

  "Trades relating to this order"
  tradesPaged(pagination: Pagination): TradeConnection!

  "Type the order type (defaults to PARTY)"
  type: OrderType

  "Reason for the order to be rejected"
  rejectionReason: OrderRejectionReason

  "Version of this order, counts the number of amends"
  version: String!

  "RFC3339Nano time the order was altered"
  updatedAt: String

  "PeggedOrder contains the details about a pegged order"
  peggedOrder: PeggedOrder

  "The liquidity provision this order was created from"
  liquidityProvision: LiquidityProvision
}

type OrderEdge {
  node: PaginatedOrder!
  cursor: String
}

type OrderConnection {
  "The total number of orders in this connection"
  totalCount: Int
  "The orders in this connection"
  edges: [OrderEdge!]
  "The pagination information"
  pageInfo: PageInfo
}
