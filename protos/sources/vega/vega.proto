syntax = "proto3";

package vega;

import "vega/markets.proto";

option go_package = "code.vegaprotocol.io/vega/protos/vega";

message StopOrder {
  enum ExpiryStrategy {
    // Never valid
    EXPIRY_STRATEGY_UNSPECIFIED = 0;
    // Stop order should be cancelled if the expiry time is reached.
    EXPIRY_STRATEGY_CANCELS = 1;
    // Order should be submitted if the expiry time is reached.
    EXPIRY_STRATEGY_SUBMIT = 2;
  }

  enum TriggerDirection {
    // Never valid
    TRIGGER_DIRECTION_UNSPECIFIED = 0;
    // Stop order is triggered once the price rises above a certain level
    TRIGGER_DIRECTION_RISES_ABOVE = 1;
    // Stop order is triggered once the price falls below a certain level
    TRIGGER_DIRECTION_FALLS_BELOW = 2;
  }

  enum Status {
    // Never valid
    STATUS_UNSPECIFIED = 0;
    // Pending to be executed once the trigger is breached
    STATUS_PENDING = 1;
    // Cancelled by the user
    STATUS_CANCELLED = 2;
    // Stopped by the network, e.g: OCO on the other side has been triggered
    STATUS_STOPPED = 3;
    // Stop order has been triggered and generated an order
    STATUS_TRIGGERED = 4;
    // Stop order has expired
    STATUS_EXPIRED = 5;
    // Stop order was rejected at submission
    STATUS_REJECTED = 6;
  }

  enum RejectionReason {
    // Never valid
    REJECTION_REASON_UNSPECIFIED = 0;
    // Trading is not allowed yet
    REJECTION_REASON_TRADING_NOT_ALLOWED = 1;
    // Expiry of the stop order is in the past
    REJECTION_REASON_EXPIRY_IN_THE_PAST = 2;
    // Stop orders submission must be reduce only
    REJECTION_REASON_MUST_BE_REDUCE_ONLY = 3;
    // Party has reached the maximum stop orders allowed for this market
    REJECTION_REASON_MAX_STOP_ORDERS_PER_PARTY_REACHED = 4;
    // Stop orders are not allowed if there is no open position
    REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_WITHOUT_A_POSITION = 5;
    // This stop order does not close the position
    REJECTION_REASON_STOP_ORDER_DOES_NOT_CLOSE_POSITION = 6;
  }

  // ID of this stop order
  // also the ID of the associated order if it is ever triggered
  string id = 1;
  // The ID of the 'other' part of the OCO if 2 stop orders were submitted at once
  optional string oco_link_id = 2;
  // Optional expiry timestamp.
  optional int64 expires_at = 3;
  // Strategy to adopt if the expiry time is reached.
  optional ExpiryStrategy expiry_strategy = 4;
  // Trigger direction for this stop order.
  TriggerDirection trigger_direction = 5;
  // Status of the stop order.
  Status status = 6;
  // Creation time of the stop order.
  int64 created_at = 7;
  // Last update of this stop order.
  optional int64 updated_at = 8;
  // ID of the order created once the trigger is hit.
  string order_id = 9;
  // ID of the party that submitted this stop order.
  string party_id = 10;
  // ID of the market the stop order is submitted to.
  string market_id = 11;
  // An optional reason for why a stop order was rejected
  optional RejectionReason rejection_reason = 12;

  // Trigger that will need to be breached for the order
  // to be submitted to the book.
  oneof trigger {
    // Fixed price at which the order will be submitted.
    string price = 100;
    // Trailing percentage at which the order will be submitted.
    // This should be expressed as a decimal value between 0 and 1, e.g. 0.01 for 1%
    string trailing_percent_offset = 101;
  }
}

// Side relates to the direction of an order, to Buy, or Sell
enum Side {
  // Default value, always invalid
  SIDE_UNSPECIFIED = 0;
  // Buy order
  SIDE_BUY = 1;
  // Sell order
  SIDE_SELL = 2;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum Interval)
}

// Represents a set of time intervals that are used when querying for candle-stick data
enum Interval {
  // Default value, always invalid
  INTERVAL_UNSPECIFIED = 0;
  // Block interval is not a fixed amount of time, rather it is used to indicate grouping of events that occur in a single block. It is usually about a second.
  INTERVAL_BLOCK = -1;
  // 1 minute.
  INTERVAL_I1M = 60;
  // 5 minutes.
  INTERVAL_I5M = 300;
  // 15 minutes.
  INTERVAL_I15M = 900;
  // 1 hour.
  INTERVAL_I1H = 3600;
  // 6 hours.
  INTERVAL_I6H = 21600;
  // 1 day.
  INTERVAL_I1D = 86400;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum Interval)
}

// Represents the status of a position
enum PositionStatus {
  POSITION_STATUS_UNSPECIFIED = 0;
  POSITION_STATUS_ORDERS_CLOSED = 1;
  POSITION_STATUS_CLOSED_OUT = 2;
  POSITION_STATUS_DISTRESSED = 4;
}

// Party represents an entity who wishes to trade on or query a Vega network
message Party {
  // Unique ID for the party, typically represented by a public key.
  string id = 1;
}

// Risk factors are used to calculate the current risk associated with orders trading on a given market
message RiskFactor {
  // Market ID that relates to this risk factor.
  string market = 1;
  // Short Risk factor value.
  string short = 2;
  // Long Risk factor value.
  string long = 3;
}

// Auction triggers indicate what condition triggered an auction (if market is in auction mode)
enum AuctionTrigger {
  // Default value for AuctionTrigger, no auction triggered
  AUCTION_TRIGGER_UNSPECIFIED = 0;
  // Batch auction
  AUCTION_TRIGGER_BATCH = 1;
  // Opening auction
  AUCTION_TRIGGER_OPENING = 2;
  // Price monitoring trigger
  AUCTION_TRIGGER_PRICE = 3;
  // Deprecated
  AUCTION_TRIGGER_LIQUIDITY = 4;
  // Liquidity auction due to not enough committed liquidity
  AUCTION_TRIGGER_LIQUIDITY_TARGET_NOT_MET = 5;
  // Liquidity auction due to not being able to deploy LP orders because there's nothing to peg on one or both sides of the book
  AUCTION_TRIGGER_UNABLE_TO_DEPLOY_LP_ORDERS = 6;
  // Market is suspended and put into auction via governance
  AUCTION_TRIGGER_GOVERNANCE_SUSPENSION = 7;
}

// Pegged reference defines which price point a pegged order is linked to - meaning
// the price for a pegged order is calculated from the value of the reference price point
enum PeggedReference {
  // Default value for PeggedReference, no reference given
  PEGGED_REFERENCE_UNSPECIFIED = 0;
  // Mid price reference
  PEGGED_REFERENCE_MID = 1;
  // Best bid price reference
  PEGGED_REFERENCE_BEST_BID = 2;
  // Best ask price reference
  PEGGED_REFERENCE_BEST_ASK = 3;
}

// Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET
// They can be used for any limit order that is valid during continuous trading
message PeggedOrder {
  // Price point the order is linked to.
  PeggedReference reference = 1;
  // Offset from the price reference.
  string offset = 2;
}

// Details of an iceberg order
message IcebergOrder {
  // Size of the order that will be made visible if the iceberg order is replenished after trading.
  uint64 peak_size = 1;
  // If the visible size of the order falls below this value, it will be replenished back to the peak size using the reserved amount.
  uint64 minimum_visible_size = 2;
  // Size of the order that is reserved and used to restore the iceberg's peak when it is refreshed.
  uint64 reserved_remaining = 3;
}

// Orders can be submitted, amended and cancelled on Vega in an attempt to make trades with other parties
message Order {
  // Time In Force for an order
  enum TimeInForce {
    // Default value for TimeInForce, can be valid for an amend
    TIME_IN_FORCE_UNSPECIFIED = 0;
    // Good until cancelled, the order trades any amount and as much as possible
    // and remains on the book until it either trades completely or is cancelled
    TIME_IN_FORCE_GTC = 1;
    // Good until specified time, this order type trades any amount and as much as possible
    // and remains on the book until it either trades completely, is cancelled, or expires at a set time
    // NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
    TIME_IN_FORCE_GTT = 2;
    // Immediate or cancel, the order trades any amount and as much as possible
    // but does not remain on the book (whether it trades or not)
    TIME_IN_FORCE_IOC = 3;
    // Fill or kill, the order either trades completely i.e. remainingSize == 0 after adding,
    // or not at all, and does not remain on the book if it doesn't trade
    TIME_IN_FORCE_FOK = 4;
    // Good for auction, this order is only accepted during an auction period
    TIME_IN_FORCE_GFA = 5;
    // Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
    TIME_IN_FORCE_GFN = 6;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderTimeInForce)
  }

  // Type values for an order
  enum Type {
    // Default value, always invalid
    TYPE_UNSPECIFIED = 0;
    // Used for Limit orders
    TYPE_LIMIT = 1;
    // Used for Market orders
    TYPE_MARKET = 2;
    // Used for orders where the initiating party is the network (with distressed parties)
    TYPE_NETWORK = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderType)
  }

  // Status values for an order
  enum Status {
    // Default value, always invalid
    STATUS_UNSPECIFIED = 0;
    // Used for active unfilled or partially filled orders
    STATUS_ACTIVE = 1;
    // Used for expired GTT orders
    STATUS_EXPIRED = 2;
    // Used for orders cancelled by the party that created the order
    STATUS_CANCELLED = 3;
    // Used for unfilled FOK or IOC orders, and for orders that were stopped by the network
    STATUS_STOPPED = 4;
    // Used for closed fully filled orders
    STATUS_FILLED = 5;
    // Used for orders when not enough collateral was available to fill the margin requirements
    STATUS_REJECTED = 6;
    // Used for closed partially filled IOC orders
    STATUS_PARTIALLY_FILLED = 7;
    // Order has been removed from the order book and has been parked,
    // this applies to pegged orders and liquidity orders (orders created from a liquidity provision shape)
    STATUS_PARKED = 8;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderStatus)
  }

  // Unique ID generated for the order.
  string id = 1;
  // Market ID for the order.
  string market_id = 2;
  // Party ID for the order.
  string party_id = 3;
  // Side for the order, e.g. SIDE_BUY or SIDE_SELL.
  Side side = 4;
  // Price for the order, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string price = 5;
  // Size for the order, for example, in a futures market the size equals the number of contracts.
  uint64 size = 6;
  // Size remaining, when this reaches 0 then the order is fully filled and status becomes STATUS_FILLED.
  uint64 remaining = 7;
  // Time in force indicates how long an order will remain active before it is executed or expires.
  // - See OrderTimeInForce
  TimeInForce time_in_force = 8;
  // Type for the order.
  Type type = 9;
  // Timestamp for when the order was created at, in nanoseconds.
  int64 created_at = 10;
  // Current status of the order.
  Status status = 11;
  // Timestamp in Unix nanoseconds for when the order will expire.
  int64 expires_at = 12;
  // Reference given for the order.
  string reference = 13;
  // Futher details for why an order with status `STATUS_REJECTED` was rejected.
  optional OrderError reason = 14;
  // Timestamp in Unix nanoseconds for when the order was last updated.
  int64 updated_at = 15;
  // Version for the order, initial value is version 1 and is incremented after each successful amend.
  uint64 version = 16;
  // Batch ID for the order, used internally for orders submitted during auctions
  // to keep track of the auction batch this order falls under. Required for fees calculation.
  uint64 batch_id = 17;
  // Pegged order details, used only if the order represents a pegged order.
  PeggedOrder pegged_order = 18;
  // Set if the order was created as part of a liquidity provision, will be empty if not.
  string liquidity_provision_id = 19;
  // Only valid for Limit orders. Cannot be True at the same time as Reduce-Only.
  bool post_only = 20;
  // Only valid for Non-Persistent orders. Cannot be True at the same time as Post-Only.
  // If set, order will only be executed if the outcome of the trade moves the trader's position closer to 0.
  bool reduce_only = 21;
  // Details of an iceberg order
  optional IcebergOrder iceberg_order = 22;
}

// Used when cancelling an order
message OrderCancellationConfirmation {
  // Order that was cancelled.
  Order order = 1;
}

// Used when confirming an order
message OrderConfirmation {
  // Order that was confirmed.
  Order order = 1;
  // 0 or more trades that were emitted.
  repeated Trade trades = 2;
  // 0 or more passive orders that were affected.
  repeated Order passive_orders_affected = 3;
}

// AuctionIndicativeState is used to emit an event with the indicative price/volume per market during an auction
message AuctionIndicativeState {
  // Market ID for which this state relates to.
  string market_id = 1;
  // Indicative uncrossing price is the price at which all trades would occur if the auction uncrossed now.
  string indicative_price = 2;
  // Indicative uncrossing volume is the volume available at the indicative crossing price if the auction uncrossed now.
  uint64 indicative_volume = 3;
  // Timestamp at which the auction started.
  int64 auction_start = 4;
  // Timestamp at which the auction is meant to stop.
  int64 auction_end = 5;
}

// OrderError codes are returned in the Order.reason field - If there is an issue
// with an order during its life-cycle, it will be marked with `status.ORDER_STATUS_REJECTED`
enum OrderError {
  reserved 38, 39;

  // Default value, no error reported
  ORDER_ERROR_UNSPECIFIED = 0;
  // Order was submitted for a market that does not exist
  ORDER_ERROR_INVALID_MARKET_ID = 1;
  // Order was submitted with an invalid ID
  ORDER_ERROR_INVALID_ORDER_ID = 2;
  // Order was amended with a sequence number that was not previous version + 1
  ORDER_ERROR_OUT_OF_SEQUENCE = 3;
  // Order was amended with an invalid remaining size (e.g. remaining greater than total size)
  ORDER_ERROR_INVALID_REMAINING_SIZE = 4;
  // Node was unable to get Vega (blockchain) time
  ORDER_ERROR_TIME_FAILURE = 5;
  // Failed to remove an order from the book
  ORDER_ERROR_REMOVAL_FAILURE = 6;
  // Order with `TimeInForce.TIME_IN_FORCE_GTT` was submitted or amended
  // with an expiration that was badly formatted or otherwise invalid
  ORDER_ERROR_INVALID_EXPIRATION_DATETIME = 7;
  // Order was submitted or amended with an invalid reference field
  ORDER_ERROR_INVALID_ORDER_REFERENCE = 8;
  // Order amend was submitted for an order field that cannot not be amended (e.g. order ID)
  ORDER_ERROR_EDIT_NOT_ALLOWED = 9;
  // Amend failure because amend details do not match original order
  ORDER_ERROR_AMEND_FAILURE = 10;
  // Order not found in an order book or store
  ORDER_ERROR_NOT_FOUND = 11;
  // Order was submitted with an invalid or missing party ID
  ORDER_ERROR_INVALID_PARTY_ID = 12;
  // Order was submitted for a market that has closed
  ORDER_ERROR_MARKET_CLOSED = 13;
  // Order was submitted, but the party did not have enough collateral to cover the order
  ORDER_ERROR_MARGIN_CHECK_FAILED = 14;
  // Order was submitted, but the party did not have an account for this asset
  ORDER_ERROR_MISSING_GENERAL_ACCOUNT = 15;
  // Unspecified internal error
  ORDER_ERROR_INTERNAL_ERROR = 16;
  // Order was submitted with an invalid or missing size (e.g. 0)
  ORDER_ERROR_INVALID_SIZE = 17;
  // Order was submitted with an invalid persistence for its type
  ORDER_ERROR_INVALID_PERSISTENCE = 18;
  // Order was submitted with an invalid type field
  ORDER_ERROR_INVALID_TYPE = 19;
  // Order was stopped as it would have traded with another order submitted from the same party
  ORDER_ERROR_SELF_TRADING = 20;
  // Order was submitted, but the party did not have enough collateral to cover the fees for the order
  ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES = 21;
  // Order was submitted with an incorrect or invalid market type
  ORDER_ERROR_INCORRECT_MARKET_TYPE = 22;
  // Order was submitted with invalid time in force
  ORDER_ERROR_INVALID_TIME_IN_FORCE = 23;
  // Good For Normal order has reached the market when it is in auction mode
  ORDER_ERROR_CANNOT_SEND_GFN_ORDER_DURING_AN_AUCTION = 24;
  // Good For Auction order has reached the market when it is in continuous trading mode
  ORDER_ERROR_CANNOT_SEND_GFA_ORDER_DURING_CONTINUOUS_TRADING = 25;
  // Attempt to amend order to GTT without ExpiryAt
  ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT = 26;
  // Attempt to amend ExpiryAt to a value before CreatedAt
  ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT = 27;
  // Attempt to amend to GTC without an ExpiryAt value
  ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT = 28;
  // Amending to FOK or IOC is invalid
  ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC = 29;
  // Amending to GFA or GFN is invalid
  ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN = 30;
  // Amending from GFA or GFN is invalid
  ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN = 31;
  // IOC orders are not allowed during auction
  ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION = 32;
  // FOK orders are not allowed during auction
  ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION = 33;
  // Pegged orders must be LIMIT orders
  ORDER_ERROR_MUST_BE_LIMIT_ORDER = 34;
  // Pegged orders can only have TIF GTC or GTT
  ORDER_ERROR_MUST_BE_GTT_OR_GTC = 35;
  // Pegged order must have a reference price
  ORDER_ERROR_WITHOUT_REFERENCE_PRICE = 36;
  // Buy pegged order cannot reference best ask price
  ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE = 37;
  // Pegged order offset must be >= 0
  ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO = 40;
  // Sell pegged order cannot reference best bid price
  ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE = 41;
  // Pegged order offset must be > zero
  ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO = 42;
  // Party has an insufficient balance, or does not have
  // a general account to submit the order (no deposits made
  // for the required asset)
  ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE = 43;
  // Cannot amend details of a non pegged details
  ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER = 44;
  // Could not re-price a pegged order because a market price is unavailable
  ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER = 45;
  // It is not possible to amend the price of an existing pegged order
  ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER = 46;
  // FOK, IOC, or GFN order was rejected because it resulted in trades outside the price bounds
  ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS = 47;
  // Unable to submit pegged order, temporarily too many pegged orders across all markets
  ORDER_ERROR_TOO_MANY_PEGGED_ORDERS = 48;
  // Post order would trade
  ORDER_ERROR_POST_ONLY_ORDER_WOULD_TRADE = 49;
  // Post order would trade
  ORDER_ERROR_REDUCE_ONLY_ORDER_WOULD_NOT_REDUCE_POSITION = 50;

  // Note: If adding an enum value, add a matching entry in:
  //       - proto/errors.go (func Error)
  //       - gateway/graphql/schema.graphql (enum RejectionReason)
  //       - gateway/graphql/helpers_enum.go
}

// A trade occurs when an aggressive order crosses one or more passive orders on the order book for a market on Vega
message Trade {
  // Type values for a trade
  enum Type {
    // Default value, always invalid
    TYPE_UNSPECIFIED = 0;
    // Normal trading between two parties
    TYPE_DEFAULT = 1;
    // Trading initiated by the network with another party on the book,
    // which helps to zero-out the positions of one or more distressed parties
    TYPE_NETWORK_CLOSE_OUT_GOOD = 2;
    // Trading initiated by the network with another party off the book,
    // with a distressed party in order to zero-out the position of the party
    TYPE_NETWORK_CLOSE_OUT_BAD = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum TradeType)
  }

  // Unique ID for the trade.
  string id = 1;
  // Market ID on which the trade occurred.
  string market_id = 2;
  // Price for the trade, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string price = 3;
  // Size filled for the trade.
  uint64 size = 4;
  // Unique party ID for the buyer.
  string buyer = 5;
  // Unique party ID for the seller.
  string seller = 6;
  // Direction of the aggressive party e.g. SIDE_BUY or SIDE_SELL.
  Side aggressor = 7;
  // Identifier of the order from the buy side.
  string buy_order = 8;
  // Identifier of the order from the sell side.
  string sell_order = 9;
  // Timestamp in Unix nanoseconds for when the trade occurred.
  int64 timestamp = 10;
  // Type for the trade.
  Type type = 11;
  // Fee amount charged to the buyer party for the trade.
  Fee buyer_fee = 12;
  // Fee amount charged to the seller party for the trade.
  Fee seller_fee = 13;
  // Auction batch number that the buy side order was placed in.
  uint64 buyer_auction_batch = 14;
  // Auction batch number that the sell side order was placed in.
  uint64 seller_auction_batch = 15;
}

// Represents any fees paid by a party, resulting from a trade
message Fee {
  // Fee amount paid to the non-aggressive party of the trade. This field is an unsigned integer scaled to the asset's decimal places.
  string maker_fee = 1;
  // Fee amount paid for maintaining the Vega infrastructure. This field is an unsigned integer scaled using the asset's decimal places.
  string infrastructure_fee = 2;
  // Fee amount paid to market makers. This field is an unsigned integer scaled to the asset's decimal places.
  string liquidity_fee = 3;
}

message TradeSet {
  // Set of one or more trades.
  repeated Trade trades = 1;
}

// Represents the high, low, open, and closing prices for an interval of trading,
// referred to commonly as a candlestick or candle
message Candle {
  // Timestamp in Unix nanoseconds for the point in time when the candle was initially created/opened.
  int64 timestamp = 1;
  // ISO-8601 datetime with nanosecond precision for when the candle was last updated.
  string datetime = 2;
  // Highest price for trading during the candle interval. This field is an unsigned integer scaled to the market's decimal places.
  string high = 3;
  // Lowest price for trading during the candle interval. This field is an unsigned integer scaled to the market's decimal places.
  string low = 4;
  // Open trade price. This field is an unsigned integer scaled to the market's decimal places.
  string open = 5;
  // Closing trade price. This field is an unsigned integer scaled to the market's decimal places.
  string close = 6;
  // Total trading volume during the candle interval.
  uint64 volume = 7;
  // Time interval for the candle.
  Interval interval = 8;
  // Total notional value traded during the candle interval.
  uint64 notional = 9;
}

// Represents a price level from market depth or order book data
message PriceLevel {
  // Price for the price level, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places. This field
  // is an unsigned integer passed as a string and needs to be scaled using the market's decimal places.
  string price = 1;
  // Number of orders at the price level.
  uint64 number_of_orders = 2;
  // Volume at the price level.
  uint64 volume = 3;
}

// Represents market depth or order book data for the specified market on Vega
message MarketDepth {
  // Market ID for which the depth levels apply.
  string market_id = 1;
  // Collection of price levels for the buy side of the book.
  repeated PriceLevel buy = 2;
  // Collection of price levels for the sell side of the book.
  repeated PriceLevel sell = 3;
  // Sequence number for the market depth data returned.
  uint64 sequence_number = 4;
}

// Represents the changed market depth since the last update
message MarketDepthUpdate {
  // Market ID for which the market depth updates are for.
  string market_id = 1;
  // Collection of updated price levels for the buy side of the book.
  repeated PriceLevel buy = 2;
  // Collection of updated price levels for the sell side of the book.
  repeated PriceLevel sell = 3;
  // Sequence number for the market depth update data returned. It is increasing but not monotonic.
  uint64 sequence_number = 4;
  // Sequence number of the previous market depth update, for checking there are no gaps.
  uint64 previous_sequence_number = 5;
}

// Represents position data for a party on the specified market on Vega
message Position {
  // Market ID in which the position is held.
  string market_id = 1;
  // Party ID holding the position.
  string party_id = 2;
  // Open volume for the position, value is signed +ve for long and -ve for short.
  int64 open_volume = 3;
  // Realised profit and loss for the position, value is signed +ve for long and -ve for short.
  // This field is a signed integer scaled to the market's decimal places.
  string realised_pnl = 4;
  // Unrealised profit and loss for the position, value is signed +ve for long and -ve for short.
  // This field is a signed integer scaled to the market's decimal places.
  string unrealised_pnl = 5;
  // Average entry price for the position, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string average_entry_price = 6;
  // Timestamp for the latest time the position was updated.
  int64 updated_at = 7;
  // Sum of profit that could not be paid due to loss socialisation.
  string loss_socialisation_amount = 8;
  // Position status, indicating whether the party was distressed and had orders cancelled or was closed out.
  PositionStatus position_status = 9;
}

message PositionTrade {
  // Volume for the position trade, value is signed +ve for long and -ve for short.
  int64 volume = 1;
  // Price for the position trade, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string price = 2;
}

// Vega blockchain status as reported by the node the caller is connected to
enum ChainStatus {
  // Default value, always invalid
  CHAIN_STATUS_UNSPECIFIED = 0;
  // Blockchain is disconnected
  CHAIN_STATUS_DISCONNECTED = 1;
  // Blockchain is replaying historic transactions
  CHAIN_STATUS_REPLAYING = 2;
  // Blockchain is connected and receiving transactions
  CHAIN_STATUS_CONNECTED = 3;

  // Note: ChainStatus does not exist in GraphQL
}

// Deposit on to the Vega network
message Deposit {
  // Status of the deposit
  enum Status {
    // Default value, always invalid
    STATUS_UNSPECIFIED = 0;
    // Deposit is being processed by the network
    STATUS_OPEN = 1;
    // Deposit has been cancelled by the network
    STATUS_CANCELLED = 2;
    // Deposit has been finalised and accounts have been updated
    STATUS_FINALIZED = 3;
  }

  // Unique ID for the deposit.
  string id = 1;
  // Status of the deposit.
  Status status = 2;
  // Party ID of the user initiating the deposit.
  string party_id = 3;
  // Vega asset targeted by this deposit.
  string asset = 4;
  // Amount to be deposited. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 5;
  // Hash of the transaction from the foreign chain.
  string tx_hash = 6;
  // Timestamp for when the Vega account was updated with the deposit.
  int64 credited_timestamp = 7;
  // Timestamp for when the deposit was created on the Vega network.
  int64 created_timestamp = 8;
}

// Withdrawal from the Vega network
message Withdrawal {
  reserved 7;

  // Status of the withdrawal
  enum Status {
    // Default value, always invalid
    STATUS_UNSPECIFIED = 0;
    // Withdrawal is open and being processed by the network
    STATUS_OPEN = 1;
    // Withdrawal have been cancelled
    STATUS_REJECTED = 2;
    // Withdrawal went through and is fully finalised, the funds are removed from the
    // Vega network and are unlocked on the foreign chain bridge, for example, on the Ethereum network
    STATUS_FINALIZED = 3;
  }

  // Unique ID for the withdrawal.
  string id = 1;
  // Unique party ID of the user initiating the withdrawal.
  string party_id = 2;
  // Amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 3;
  // Asset to withdraw funds from.
  string asset = 4;
  // Status of the withdrawal.
  Status status = 5;
  // Reference which is used by the foreign chain
  // to refer to this withdrawal.
  string ref = 6;
  // Hash of the foreign chain for this transaction.
  string tx_hash = 8;
  // Timestamp for when the network started to process this withdrawal.
  int64 created_timestamp = 9;
  // Timestamp for when the withdrawal was finalised by the network.
  int64 withdrawn_timestamp = 10;
  // Foreign chain specifics.
  WithdrawExt ext = 11;
}

// Withdrawal external details
message WithdrawExt {
  // Foreign chain specifics.
  oneof ext {
    // ERC20 withdrawal details.
    Erc20WithdrawExt erc20 = 1;
  }
}

// Extension of data required for the withdraw submissions
message Erc20WithdrawExt {
  // Address into which the bridge will release the funds.
  string receiver_address = 1;
}

// Various collateral/account types as used by Vega
enum AccountType {
  reserved 8;
  // Default value
  ACCOUNT_TYPE_UNSPECIFIED = 0;
  // Insurance pool accounts contain insurance pool funds for a market
  ACCOUNT_TYPE_INSURANCE = 1;
  // Settlement accounts exist only during settlement or mark-to-market
  ACCOUNT_TYPE_SETTLEMENT = 2;
  // Margin accounts contain funds set aside for the margin needed to support a party's open positions.
  // Each party will have a margin account for each market they have traded in.
  // Required initial margin is allocated to each market from user's general account.
  // Collateral in the margin account can't be withdrawn or used as margin on another market until
  // it is released back to the general account.
  // Vega protocol uses an internal accounting system to segregate funds held as
  // margin from other funds to ensure they are never lost or 'double spent'
  //
  // Margin account funds will vary as margin requirements on positions change
  ACCOUNT_TYPE_MARGIN = 3;
  // General accounts contain the collateral for a party that is not otherwise allocated. A party will
  // have multiple general accounts, one for each asset they want
  // to trade with
  //
  // General accounts are where funds are initially deposited or withdrawn from,
  // it is also the account where funds are taken to fulfil fees and initial margin requirements
  ACCOUNT_TYPE_GENERAL = 4;
  // Infrastructure accounts contain fees earned by providing infrastructure on Vega
  ACCOUNT_TYPE_FEES_INFRASTRUCTURE = 5;
  // Liquidity accounts contain fees earned by providing liquidity on Vega markets
  ACCOUNT_TYPE_FEES_LIQUIDITY = 6;
  // This account is created to hold fees earned by placing orders that sit on the book
  // and are then matched with an incoming order to create a trade - These fees reward parties
  // who provide the best priced liquidity that actually allows trading to take place
  ACCOUNT_TYPE_FEES_MAKER = 7;
  // This account is created to maintain liquidity providers funds commitments
  ACCOUNT_TYPE_BOND = 9;

  // External account represents an external source (deposit/withdrawal)
  ACCOUNT_TYPE_EXTERNAL = 10;

  // Global insurance account for the asset
  ACCOUNT_TYPE_GLOBAL_INSURANCE = 11;

  // Global reward account for the asset
  ACCOUNT_TYPE_GLOBAL_REWARD = 12;

  // Per asset account used to store pending transfers (if any)
  ACCOUNT_TYPE_PENDING_TRANSFERS = 13;

  // Per asset reward account for fees paid to makers
  ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES = 14;

  // Per asset reward account for fees received by makers
  ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES = 15;

  // Per asset reward account for fees received by liquidity providers
  ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES = 16;

  // Per asset reward account for market proposers when the market goes above some trading threshold
  ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS = 17;

  // Per asset account for holding in-flight unfilled orders' funds
  ACCOUNT_TYPE_HOLDING = 18;

  // Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.
  ACCOUNT_TYPE_LP_LIQUIDITY_FEES = 19;

  // Network controlled liquidity fees bonus distribution account, per market.
  ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION = 20;

  // Network controlled treasury
  ACCOUNT_TYPE_NETWORK_TREASURY = 21;

  // Account holding user's rewards for the vesting period
  ACCOUNT_TYPE_VESTING_REWARDS = 22;

  // Account holding user's rewards after the vesting period
  ACCOUNT_TYPE_VESTED_REWARDS = 23;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum AccountType)
}

// Represents an account for an asset on Vega for a particular owner or party
message Account {
  // Unique account ID, used internally by Vega.
  string id = 1;
  // Party that the account belongs to, special values include `network`, which represents the Vega network and is
  // most commonly seen during liquidation of distressed trading positions.
  string owner = 2;
  // Balance of the asset, the balance is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places
  // and importantly balances cannot be negative.
  string balance = 3;
  // Asset ID for the account.
  string asset = 4;
  // Market ID for the account, if `AccountType.ACCOUNT_TYPE_GENERAL` this will be empty.
  string market_id = 5;
  // Account type related to this account.
  AccountType type = 6;
}

// Asset value information used within a transfer
message FinancialAmount {
  // Unsigned integer amount of asset scaled to the asset's decimal places.
  string amount = 1;
  // Asset ID the amount applies to.
  string asset = 2;
}

// Transfers can occur between parties on Vega, these are the types that indicate why a transfer took place
enum TransferType {
  reserved 3, 17;
  // Default value, always invalid
  TRANSFER_TYPE_UNSPECIFIED = 0;
  // Funds deducted after final settlement loss
  TRANSFER_TYPE_LOSS = 1;
  // Funds added to general account after final settlement gain
  TRANSFER_TYPE_WIN = 2;
  // Funds deducted from margin account after mark to market loss
  TRANSFER_TYPE_MTM_LOSS = 4;
  // Funds added to margin account after mark to market gain
  TRANSFER_TYPE_MTM_WIN = 5;
  // Funds transferred from general account to meet margin requirement
  TRANSFER_TYPE_MARGIN_LOW = 6;
  // Excess margin amount returned to general account
  TRANSFER_TYPE_MARGIN_HIGH = 7;
  // Margin confiscated from margin account to fulfil closeout
  TRANSFER_TYPE_MARGIN_CONFISCATED = 8;
  // Maker fee paid from general account
  TRANSFER_TYPE_MAKER_FEE_PAY = 9;
  // Maker fee received into general account
  TRANSFER_TYPE_MAKER_FEE_RECEIVE = 10;
  // Infrastructure fee paid from general account
  TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY = 11;
  // Infrastructure fee received into general account
  TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE = 12;
  // Liquidity fee paid from general account
  TRANSFER_TYPE_LIQUIDITY_FEE_PAY = 13;
  // Liquidity fee received into general account
  TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE = 14;
  // Bond account funded from general account to meet required bond amount
  TRANSFER_TYPE_BOND_LOW = 15;
  // Bond returned to general account after liquidity commitment was reduced
  TRANSFER_TYPE_BOND_HIGH = 16;
  // Funds withdrawn from general account
  TRANSFER_TYPE_WITHDRAW = 18;
  // Funds deposited to general account
  TRANSFER_TYPE_DEPOSIT = 19;
  // Bond account penalised when liquidity commitment not met
  TRANSFER_TYPE_BOND_SLASHING = 20;
  // Reward payout received
  TRANSFER_TYPE_REWARD_PAYOUT = 21;
  // Internal Vega network instruction for the collateral engine to move funds from a user's general account into the pending transfers pool
  TRANSFER_TYPE_TRANSFER_FUNDS_SEND = 22;
  // Internal Vega network instruction for the collateral engine to move funds from the pending transfers pool account into the destination account
  TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE = 23;
  // Market-related accounts emptied because market has closed
  TRANSFER_TYPE_CLEAR_ACCOUNT = 24;
  // Balances restored after network restart
  TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE = 25;
  // Spot trade delivery
  TRANSFER_TYPE_SPOT = 26;
  // An internal instruction to transfer a quantity corresponding to an active spot order from a general account into a party holding account.
  TRANSFER_TYPE_HOLDING_LOCK = 27;
  // An internal instruction to transfer an excess quantity corresponding to an active spot order from a holding account into a party general account.
  TRANSFER_TYPE_HOLDING_RELEASE = 28;
  // Insurance pool fraction transfer from parent to successor market.
  TRANSFER_TYPE_SUCCESSOR_INSURANCE_FRACTION = 29;
  // Allocates liquidity fee earnings to each liquidity provider's network controlled liquidity fee account.
  TRANSFER_TYPE_LIQUIDITY_FEE_ALLOCATE = 30;
  // Distributes net fee earnings from liquidity provider's fee account to their general account.
  TRANSFER_TYPE_LIQUIDITY_FEE_NET_DISTRIBUTE = 31;
  // Applies SLA penalty by moving funds from party's bond account to market's insurance pool.
  TRANSFER_TYPE_SLA_PENALTY_BOND_APPLY = 32;
  // Applies SLA penalty by moving funds from the liquidity provider's fee account to market insurance pool.
  TRANSFER_TYPE_SLA_PENALTY_LP_FEE_APPLY = 33;
  // Collects penalties from the liquidity provider's fee account before the fee revenue is paid, and transfers it to the market's bonus distribution account.
  TRANSFER_TYPE_LIQUIDITY_FEE_UNPAID_COLLECT = 34;
  // Distributes performance bonus from market bonus to liquidity provider's general account.
  TRANSFER_TYPE_SLA_PERFORMANCE_BONUS_DISTRIBUTE = 35;
  // Funds deducted from margin account after a perpetuals funding loss.
  TRANSFER_TYPE_PERPETUALS_FUNDING_LOSS = 36;
  // Funds added to margin account after a perpetuals funding gain.
  TRANSFER_TYPE_PERPETUALS_FUNDING_WIN = 37;
  // Funds moved from the vesting account to the vested account once the vesting period is reached.
  TRANSFER_TYPE_REWARDS_VESTED = 38;
}

// Represents a financial transfer within Vega
message Transfer {
  // Party ID for the owner of the transfer.
  string owner = 1;
  // Financial amount of an asset to transfer.
  FinancialAmount amount = 2;
  // Type of transfer, gives the reason for the transfer.
  TransferType type = 3;
  // Minimum amount. This field is an unsigned integer scaled to the asset's decimal places.
  string min_amount = 4;
  // Market ID the transfer is for
  string market_id = 5;
}

enum DispatchMetric {
  DISPATCH_METRIC_UNSPECIFIED = 0;
  // Dispatch metric that is using the total maker fees paid in the market
  DISPATCH_METRIC_MAKER_FEES_PAID = 1;
  // Dispatch metric that is using the total maker fees received in the market
  DISPATCH_METRIC_MAKER_FEES_RECEIVED = 2;
  // Dispatch metric that is using the total LP fees received in the market
  DISPATCH_METRIC_LP_FEES_RECEIVED = 3;
  // Dispatch metric that is using total value of the market if above the required threshold and not paid given proposer bonus yet
  DISPATCH_METRIC_MARKET_VALUE = 4;
}

message DispatchStrategy {
  // Asset to use for metric.
  string asset_for_metric = 1;
  // Metric to apply.
  DispatchMetric metric = 2;
  // Optional markets in scope.
  repeated string markets = 3;
}

// Represents a request to transfer from one set of accounts to another
message TransferRequest {
  // One or more accounts to transfer from.
  repeated Account from_account = 1;
  // One or more accounts to transfer to.
  repeated Account to_account = 2;
  // Amount to transfer for the asset. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 3;
  // Minimum amount that needs to be transferred for the transfer request. If this minimum isn't reached, it will error.
  // This field is an unsigned integer scaled to the asset's decimal places.
  string min_amount = 4;
  // Asset ID of the asset being transferred.
  string asset = 5;
  // Type of the request for transfer.
  TransferType type = 7;
}

message AccountDetails {
  // Asset ID of the asset for this account.
  string asset_id = 1;
  // Type of the account.
  AccountType type = 2;
  // Not specified if network account.
  optional string owner = 3;
  // Not specified if account is not related to a market.
  optional string market_id = 4;
}

// Represents a ledger entry on Vega
message LedgerEntry {
  // One or more accounts to transfer from.
  AccountDetails from_account = 1;
  // One or more accounts to transfer to.
  AccountDetails to_account = 2;
  // Amount to transfer. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 3;
  // Transfer type for this entry.
  TransferType type = 4;
  // Timestamp in nanoseconds of when the ledger entry was created.
  int64 timestamp = 5;
  // Sender account balance after the transfer. This field is an unsigned integer scaled to the asset's decimal places.
  string from_account_balance = 6;
  // Receiver account balance after the transfer. This field is an unsigned integer scaled to the asset's decimal places.
  string to_account_balance = 7;
}

// Represents the balance for an account during a transfer
message PostTransferBalance {
  // Account relating to the transfer.
  AccountDetails account = 1;
  // Balance relating to the transfer. This field is an unsigned integer scaled to the asset's decimal places.
  string balance = 2;
}

message LedgerMovement {
  // All the entries for these ledger movements.
  repeated LedgerEntry entries = 1;
  // Resulting balances once the ledger movement are applied.
  repeated PostTransferBalance balances = 2;
}

// Represents the margin levels for a party on a market at a given time
message MarginLevels {
  // Maintenance margin value. This field is an unsigned integer scaled to the asset's decimal places.
  string maintenance_margin = 1;
  // Margin search level value. This field is an unsigned integer scaled to the asset's decimal places.
  string search_level = 2;
  // Initial margin value. This field is an unsigned integer scaled to the asset's decimal places.
  string initial_margin = 3;
  // Collateral release level value. This field is an unsigned integer scaled to the asset's decimal places.
  string collateral_release_level = 4;
  // Party ID for whom the margin levels apply.
  string party_id = 5;
  // Market ID for which the margin levels apply.
  string market_id = 6;
  // Asset ID for which the margin levels apply.
  string asset = 7;
  // Timestamp in Unix nanoseconds for when the ledger entry was created.
  int64 timestamp = 8;
}

// Represents data generated by a market when open
message MarketData {
  // Mark price, as an unsigned integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string mark_price = 1;
  // Highest price level on an order book for buy orders, as an unsigned integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string best_bid_price = 2;
  // Aggregated volume being bid at the best bid price, as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market is configured to 5 decimal places.
  uint64 best_bid_volume = 3;
  // Lowest price level on an order book for offer orders. This field is an unsigned integer scaled to the market's decimal places.
  string best_offer_price = 4;
  // Aggregated volume being offered at the best offer price, as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market is configured to 5 decimal places.
  uint64 best_offer_volume = 5;
  // Highest price on the order book for buy orders not including pegged orders.
  // This field is an unsigned integer scaled to the market's decimal places.
  string best_static_bid_price = 6;
  // Total volume at the best static bid price excluding pegged orders.
  uint64 best_static_bid_volume = 7;
  // Lowest price on the order book for sell orders not including pegged orders.
  // This field is an unsigned integer scaled to the market's decimal places.
  string best_static_offer_price = 8;
  // Total volume at the best static offer price, excluding pegged orders.
  uint64 best_static_offer_volume = 9;
  // Arithmetic average of the best bid price and best offer price, as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  string mid_price = 10;
  // Arithmetic average of the best static bid price and best static offer price.
  // This field is an unsigned integer scaled to the market's decimal places.
  string static_mid_price = 11;
  // Market ID for the data
  string market = 12;
  // Timestamp in Unix nanoseconds at which this mark price was relevant.
  int64 timestamp = 13;
  // Sum of the size of all positions greater than zero on the market.
  uint64 open_interest = 14;
  // Time in seconds until the end of the auction (zero if currently not in auction period).
  int64 auction_end = 15;
  // Time until next auction, or start time of the current auction if market is in auction period.
  int64 auction_start = 16;
  // Indicative price (zero if not in auction). This field is an unsigned scaled to the market's decimal places.
  string indicative_price = 17;
  // Indicative volume (zero if not in auction).
  uint64 indicative_volume = 18;
  // Current trading mode for the market.
  Market.TradingMode market_trading_mode = 19;
  // When a market is in an auction trading mode, this field indicates what triggered the auction.
  AuctionTrigger trigger = 20;
  // When a market auction is extended, this field indicates what caused the extension.
  AuctionTrigger extension_trigger = 21;
  // Targeted stake for the given market. This field is an unsigned integer scaled to the settlement asset's decimal places.
  string target_stake = 22;
  // Available stake for the given market. This field is an unsigned integer scaled to the settlement asset's decimal places.
  string supplied_stake = 23;
  // One or more price monitoring bounds for the current timestamp.
  repeated PriceMonitoringBounds price_monitoring_bounds = 24;
  // Market value proxy.
  string market_value_proxy = 25;
  // Equity like share of liquidity fee for each liquidity provider.
  repeated LiquidityProviderFeeShare liquidity_provider_fee_share = 26;
  // Current state of the market.
  Market.State market_state = 27;
  // Time in Unix nanoseconds when the next mark-to-market calculation will occur.
  int64 next_mark_to_market = 28;
  // Last traded price of the market. This field is an unsigned integer scaled to the market's decimal places.
  string last_traded_price = 29;
  // Market growth at the last market time window.
  string market_growth = 30;
}

// Equity like share of liquidity fee for each liquidity provider
message LiquidityProviderFeeShare {
  // Liquidity provider party ID.
  string party = 1;
  // Share own by this liquidity provider.
  string equity_like_share = 2;
  // Average entry valuation of the liquidity provider for the market.
  string average_entry_valuation = 3;
  // Average liquidity score.
  string average_score = 4;
  // The virtual stake of this liquidity provider.
  string virtual_stake = 5;
}

// Represents a list of valid (at the current timestamp) price ranges per associated trigger
message PriceMonitoringBounds {
  // Minimum price that isn't currently breaching the specified price monitoring trigger.
  // This field is an unsigned integer scaled to the market's decimal places.
  string min_valid_price = 1;
  // Maximum price that isn't currently breaching the specified price monitoring trigger.
  // This field is an unsigned integer scaled to the market's decimal places.
  string max_valid_price = 2;
  // Price monitoring trigger associated with the bounds.
  PriceMonitoringTrigger trigger = 3;
  // Reference price used to calculate the valid price range. This field is an unsigned integer scaled to the market's decimal places.
  string reference_price = 4;
}

// Represents Vega domain specific error information over gRPC/Protobuf
message ErrorDetail {
  // Vega API domain specific unique error code, useful for client side mappings, e.g. 10004.
  int32 code = 1;
  // Message that describes the error in more detail, should describe the problem encountered.
  string message = 2;
  // Any inner error information that could add more context, or be helpful for error reporting.
  string inner = 3;
}

// Represents a network parameter on Vega
message NetworkParameter {
  // Unique key of the network parameter.
  string key = 1;
  // Value for the network parameter.
  string value = 2;
}

// Network limits, defined in the genesis file
message NetworkLimits {
  reserved 3, 6;

  // Are market proposals allowed at this point in time.
  bool can_propose_market = 1;
  // Are asset proposals allowed at this point in time.
  bool can_propose_asset = 2;
  // Are market proposals enabled on this chain.
  bool propose_market_enabled = 4;
  // Are asset proposals enabled on this chain.
  bool propose_asset_enabled = 5;
  // True once the genesis file is loaded.
  bool genesis_loaded = 7;
  // Timestamp in Unix nanoseconds at which market proposals will be enabled (0 indicates not set).
  int64 propose_market_enabled_from = 8;
  // Timestamp in Unix nanoseconds at which asset proposals will be enabled (0 indicates not set).
  int64 propose_asset_enabled_from = 9;
  // Are spot market proposals allowed at this point in time.
  bool can_propose_spot_market = 10;
  // Are perpetual market proposals allowed at this point in time.
  bool can_propose_perpetual_market = 11;
}

// Represents a liquidity order
message LiquidityOrder {
  // Pegged reference point for the order.
  PeggedReference reference = 1;
  // Relative proportion of the commitment to be allocated at a price level.
  uint32 proportion = 2;
  // Offset/amount of units away for the order. This field is an unsigned integer scaled using the market's decimal places.
  string offset = 3;
}

// Pair of a liquidity order and the ID of the generated order
message LiquidityOrderReference {
  // Unique ID of the pegged order generated to fulfil this liquidity order.
  string order_id = 1;
  // Liquidity order from the original submission.
  LiquidityOrder liquidity_order = 2;
}

// Liquidity provider commitment
message LiquidityProvision {
  // Status of a liquidity provision order.
  enum Status {
    // Always invalid
    STATUS_UNSPECIFIED = 0;
    // Liquidity provision is active
    STATUS_ACTIVE = 1;
    // Liquidity provision was stopped by the network
    STATUS_STOPPED = 2;
    // Liquidity provision was cancelled by the liquidity provider
    STATUS_CANCELLED = 3;
    // Liquidity provision was invalid and got rejected
    STATUS_REJECTED = 4;
    // Liquidity provision is valid and accepted by network, but orders aren't deployed
    STATUS_UNDEPLOYED = 5;
    // Liquidity provision is valid and accepted by network
    // but has never been deployed. If when it's possible to deploy the orders for the first time
    // margin check fails, then they will be cancelled without any penalties.
    STATUS_PENDING = 6;
  }

  // Unique ID for the liquidity provision.
  string id = 1;
  // Unique party ID for the creator of the provision.
  string party_id = 2;
  // Timestamp in Unix nanoseconds for when the order was created.
  int64 created_at = 3;
  // Timestamp in Unix nanoseconds for when the order was updated.
  int64 updated_at = 4;
  // Market ID for the order.
  string market_id = 5;
  // Specified as a unitless number that represents the amount of settlement asset of the market.
  // This field is an unsigned integer scaled to the asset's decimal places.
  string commitment_amount = 6;
  // Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers.
  string fee = 7;
  // Set of liquidity sell orders to meet the liquidity provision obligation.
  repeated LiquidityOrderReference sells = 8;
  // Set of liquidity buy orders to meet the liquidity provision obligation.
  repeated LiquidityOrderReference buys = 9;
  // Version of this liquidity provision order.
  uint64 version = 10;
  // Status of this liquidity provision order.
  Status status = 11;
  // Reference shared between this liquidity provision and all its orders.
  string reference = 12;
}

// Liquidity provider commitment
message LiquidityProvisionV2 {
  // Status of a liquidity provision order.
  enum Status {
    // Always invalid
    STATUS_UNSPECIFIED = 0;
    // Liquidity provision is active
    STATUS_ACTIVE = 1;
    // Liquidity provision was stopped by the network
    STATUS_STOPPED = 2;
    // Liquidity provision was cancelled by the liquidity provider
    STATUS_CANCELLED = 3;
    // Liquidity provision was invalid and got rejected
    STATUS_REJECTED = 4;
    // Liquidity provision is valid and accepted by network, but orders aren't deployed
    STATUS_UNDEPLOYED = 5;
    // Liquidity provision is valid and accepted by network
    // but has never been deployed. If when it's possible to deploy the orders for the first time
    // margin check fails, then they will be cancelled without any penalties.
    STATUS_PENDING = 6;
  }

  // Unique ID for the liquidity provision.
  string id = 1;
  // Unique party ID for the creator of the provision.
  string party_id = 2;
  // Timestamp in Unix nanoseconds for when the order was created.
  int64 created_at = 3;
  // Timestamp in Unix nanoseconds for when the order was updated.
  int64 updated_at = 4;
  // Market ID for the order.
  string market_id = 5;
  // Specified as a unitless number that represents the amount of settlement asset of the market.
  // This field is an unsigned integer scaled to the asset's decimal places.
  string commitment_amount = 6;
  // Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers.
  string fee = 7;
  // Set of liquidity sell orders to meet the liquidity provision obligation.
  repeated LiquidityOrderReference sells = 8;
  // Set of liquidity buy orders to meet the liquidity provision obligation.
  repeated LiquidityOrderReference buys = 9;
  // Version of this liquidity provision order.
  uint64 version = 10;
  // Status of this liquidity provision order.
  Status status = 11;
  // Reference shared between this liquidity provision and all its orders.
  string reference = 12;
}

// Ethereum configuration details.
message EthereumConfig {
  // Network ID of this Ethereum network.
  string network_id = 1;
  // Chain ID of this Ethereum network.
  string chain_id = 2;
  //// Contract configuration of the collateral bridge contract for this Ethereum network.
  EthereumContractConfig collateral_bridge_contract = 3;
  // Number of block confirmations to wait to consider an Ethereum transaction trusted.
  // An Ethereum block is trusted when there are at least "n" blocks confirmed by the
  // network, "n" being the number of `confirmations` required. If `confirmations` was set to `3`,
  // and the current block to be forged (or mined) on Ethereum is block 14, block
  // 10 would be considered as trusted, but not block 11.
  uint32 confirmations = 4;
  // Contract configuration of the stacking bridge contract for this Ethereum network.
  EthereumContractConfig staking_bridge_contract = 5;
  // Contract configuration of the token vesting contract for this Ethereum network.
  EthereumContractConfig token_vesting_contract = 6;
  // Contract configuration of the multisig control contract for this Ethereum network.
  EthereumContractConfig multisig_control_contract = 7;
}

message EthereumContractConfig {
  // Address of the contract for this Ethereum network. The address should start with "0x".
  string address = 1;
  // Block height at which the stacking contract has been deployed for this Ethereum network.
  uint64 deployment_block_height = 6;
}

// Node status type
enum NodeStatus {
  NODE_STATUS_UNSPECIFIED = 0;
  // Node is a validating node
  NODE_STATUS_VALIDATOR = 1;
  // Node is a non-validating node
  NODE_STATUS_NON_VALIDATOR = 2;
}

// Describes in both human readable and block time when an epoch spans
message EpochTimestamps {
  // Timestamp in Unix nanoseconds for when epoch started.
  int64 start_time = 1;
  // Timestamp in Unix nanoseconds for the epoch's expiry.
  int64 expiry_time = 2;
  // Timestamp in Unix nanoseconds for when the epoch ended, empty if not ended.
  int64 end_time = 3;
  // Height of first block in the epoch.
  uint64 first_block = 4;
  // Height of last block in the epoch, empty if not ended.
  uint64 last_block = 5;
}

// What epoch action has occurred
enum EpochAction {
  EPOCH_ACTION_UNSPECIFIED = 0;
  // Epoch update is for a new epoch.
  EPOCH_ACTION_START = 1;
  // Epoch update is for the end of an epoch.
  EPOCH_ACTION_END = 2;
}

message Epoch {
  // Sequence is used as epoch ID.
  uint64 seq = 1;
  // Timestamps for start/end etc.
  EpochTimestamps timestamps = 2;
  // Validators that participated in this epoch.
  repeated Node validators = 3;
  // List of all delegations in epoch.
  repeated Delegation delegations = 4;
}

message EpochParticipation {
  Epoch epoch = 1;
  uint64 offline = 2;
  uint64 online = 3;
  double total_rewards = 4;
}

message EpochData {
  // Total number of epochs since node was created.
  int32 total = 1;
  // Total number of offline epochs since node was created.
  int32 offline = 2;
  // Total number of online epochs since node was created.
  int32 online = 3;
}

// Validation status of the node
enum ValidatorNodeStatus {
  VALIDATOR_NODE_STATUS_UNSPECIFIED = 0;
  // Node is a tendermint validator
  VALIDATOR_NODE_STATUS_TENDERMINT = 1;
  // Node is an ersatz validator
  VALIDATOR_NODE_STATUS_ERSATZ = 2;
  // Node is a pending validator
  VALIDATOR_NODE_STATUS_PENDING = 3;
}

message RankingScore {
  // Stake based score - no anti-whaling.
  string stake_score = 1;
  // Performance based score.
  string performance_score = 2;
  // Status of the validator in the previous epoch.
  ValidatorNodeStatus previous_status = 3;
  // Status of the validator in the current epoch.
  ValidatorNodeStatus status = 4;
  // Tendermint voting power of the validator.
  uint32 voting_power = 5;
  // Final score.
  string ranking_score = 6;
}

message RewardScore {
  // Stake based score - with anti-whaling.
  string raw_validator_score = 1;
  // Performance based score.
  string performance_score = 2;
  // Multisig score.
  string multisig_score = 3;
  // Un-normalised score.
  string validator_score = 4;
  // Normalised validator score for rewards.
  string normalised_score = 5;
  // Status of the validator for reward.
  ValidatorNodeStatus validator_status = 6;
}

message Node {
  // Node ID i.e. the node's wallet ID.
  string id = 1;
  // Public key of the node operator.
  string pub_key = 2;
  // Public key of Tendermint.
  string tm_pub_key = 3;
  // Ethereum public key of the node.
  string ethereum_address = 4;
  // URL where users can find out more information on the node.
  string info_url = 5;
  // Country code for the location of the node.
  string location = 6;
  // Amount the node operator has put up themselves. This field is an unsigned integer scaled to the asset's decimal places.
  string staked_by_operator = 7;
  // Amount of stake that has been delegated by token holders. This field is an unsigned integer scaled to the asset's decimal places.
  string staked_by_delegates = 8;
  // Total amount staked on node. This field is an unsigned integer scaled to the asset's decimal places.
  string staked_total = 9;
  // Max amount of (wanted) stake. This field is an unsigned integer scaled to the asset's decimal places.
  string max_intended_stake = 10;
  // Amount of stake on the next epoch. This field is an unsigned integer scaled to the asset's decimal places.
  string pending_stake = 11;
  // Information about epoch.
  EpochData epoch_data = 12;
  // Node status.
  NodeStatus status = 13;
  // Node's delegations.
  repeated Delegation delegations = 14;
  // Node reward score.
  RewardScore reward_score = 15;
  // Node ranking information.
  RankingScore ranking_score = 16;
  // Node name.
  string name = 17;
  // Avatar url.
  string avatar_url = 18;
}

// Details on the collection of nodes for a particular validator status
message NodeSet {
  // Total number of nodes in the node set.
  uint32 total = 1;
  // Number of nodes in the node set that had a performance score of 0 at the end of the last epoch.
  uint32 inactive = 2;
  // IDs of nodes that were promoted into this node set at the start of the epoch.
  repeated string promoted = 3;
  // IDs of nodes that were demoted into this node set at the start of the epoch.
  repeated string demoted = 4;
  // Total number of nodes allowed in the node set.
  optional uint32 maximum = 5;
}

message NodeData {
  // Total staked amount across all nodes. This field is an unsigned integer scaled to the asset's decimal places.
  string staked_total = 1;
  // Total number of nodes across all node sets.
  uint32 total_nodes = 2;
  // Total number of nodes that had a performance score of 0 at the end of the last epoch.
  uint32 inactive_nodes = 3;
  // Details on the set of consensus nodes in the network.
  NodeSet tendermint_nodes = 4;
  // Details on the set of ersatz (standby) nodes in the network.
  NodeSet ersatz_nodes = 5;
  // Details on the set of pending nodes in the network.
  NodeSet pending_nodes = 6;
  // Total uptime for all epochs across all nodes.
  float uptime = 7;
}

message Delegation {
  // Party which is delegating.
  string party = 1;
  // Node ID to delegate to.
  string node_id = 2;
  // Amount delegated. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 3;
  // Epoch of delegation.
  string epoch_seq = 4;
}

// Details for a single reward payment
message Reward {
  // Asset ID in which the reward is being paid.
  string asset_id = 1;
  // Party ID to whom the reward is being paid.
  string party_id = 2;
  // Epoch in which the reward is being paid.
  uint64 epoch = 3;
  // Amount paid as a reward. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 4;
  // Percentage of total rewards paid in the epoch.
  string percentage_of_total = 5;
  // Timestamp at which the reward was paid as Unix nano time.
  int64 received_at = 6;
  // Market ID in which the reward is being paid.
  string market_id = 7;
  // Type of reward being paid.
  string reward_type = 8;
}

// Details for rewards for a single asset
message RewardSummary {
  // Asset ID in which the reward is being paid.
  string asset_id = 1;
  // Party ID to whom the reward is being paid.
  string party_id = 2;
  // Total amount of rewards paid in the asset. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 3;
}

// Details for rewards for a combination of asset, market, and reward type in a given epoch
message EpochRewardSummary {
  // Epoch in which the reward is being paid.
  uint64 epoch = 1;
  // Asset ID in which the reward is being paid.
  string asset_id = 2;
  // Market ID in which the reward is being paid.
  string market_id = 3;
  // Type of reward being paid.
  string reward_type = 4;
  // Amount distributed. This field is an unsigned integer scaled to the asset's decimal places.
  string amount = 5;
}

message StateValueProposal {
  // State variable ID.
  string state_var_id = 1;
  // Event ID.
  string event_id = 2;
  // Key value tolerance triplets.
  repeated KeyValueBundle kvb = 3;
}

message KeyValueBundle {
  string key = 1;
  string tolerance = 2;
  StateVarValue value = 3;
}

message StateVarValue {
  oneof value {
    ScalarValue scalar_val = 1;
    VectorValue vector_val = 2;
    MatrixValue matrix_val = 3;
  }
}

message ScalarValue {
  string value = 1;
}

message VectorValue {
  repeated string value = 1;
}

message MatrixValue {
  repeated VectorValue value = 1;
}

message ReferralProgram {
  // Incremental version of the program. It is incremented after each program
  // update.
  uint64 version = 1;
  // Unique ID generated from the proposal that created this program.
  string id = 2;
  // Defined tiers in increasing order. First element will give Tier 1, second
  // element will give Tier 2, and so on.
  repeated BenefitTier benefit_tiers = 3;
  // Timestamp as Unix time in seconds after which when the current epoch ends, the
  // programs status will become STATE_CLOSED and benefits will be disabled.
  int64 end_of_program_timestamp = 4;
  // Number of epochs over which to evaluate a referral set's running volume.
  uint64 window_length = 5;
}

message BenefitTier {
  // Required running notional taker volume in quantum units for parties
  // to access this tier.
  string minimum_running_notional_taker_volume = 1;
  // Required number of epochs a party must have been in a referral set to
  // access this tier.
  string minimum_epochs = 2;
  // Proportion of the referee's taker fees to be rewarded to the referrer
  string referral_reward_factor = 3;
  // Proportion of the referee's taker fees to be discounted
  string referral_discount_factor = 4;
}
