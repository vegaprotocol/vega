// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/proto"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

// union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind
type Event interface {
	IsEvent()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type TradingMode interface {
	IsTradingMode()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// Represents an asset in vega
type Asset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// The origin source of the asset (e.g: an erc20 asset)
	Source AssetSource `json:"source"`
	// The infrastructure fee account for this asset
	InfrastructureFeeAccount *proto.Account `json:"infrastructureFeeAccount"`
}

func (Asset) IsEvent() {}

type AuctionEvent struct {
	// the market ID
	MarketID string `json:"marketID"`
	// event fired because of auction end
	Leave bool `json:"leave"`
	// event related to opening auction
	OpeningAuction bool `json:"openingAuction"`
	// start time of auction
	AuctionStart string `json:"auctionStart"`
	// optional end time of auction
	AuctionEnd string `json:"auctionEnd"`
}

func (AuctionEvent) IsEvent() {}

// A vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

// A vega builtin asset, mostly for testing purpose
type BuiltinAssetInput struct {
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

type BusEvent struct {
	// the id for this event
	EventID string `json:"eventID"`
	// the type of event we're dealing with
	Type BusEventType `json:"type"`
	// the payload - the wrapped event
	Event Event `json:"event"`
}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (ContinuousTrading) IsTradingMode() {}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTradingInput struct {
	// Size of an increment in price in terms of the quote currency. Note this field should not be used and will be ignored
	TickSize *string `json:"tickSize"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (DiscreteTrading) IsTradingMode() {}

// Frequent batch auctions trading mode
type DiscreteTradingInput struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency. Note this field should not be used and will be ignored
	TickSize *string `json:"tickSize"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

func (Erc20) IsAssetSource() {}

// An asset originated from an Ethereum ERC20 Token
type ERC20Input struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawan
	Amount string `json:"amount"`
	// The expiry of the approval (RFC3339Nano)
	Expiry string `json:"expiry"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// ERC20 specific details to start a withdrawal
type Erc20WithdrawalDetailsInput struct {
	// The ethereum address to which the withdrawn funds will be send to
	ReceiverAddress string `json:"receiverAddress"`
}

// An Ethereum oracle
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

// The factors applied to calculate the fees
type FeeFactors struct {
	// The factor applied to calculate MakerFees, a non-negative float
	MakerFee string `json:"makerFee"`
	// The factor applied to calculate InfrastructureFees, a non-negative float
	InfrastructureFee string `json:"infrastructureFee"`
	// The factor applied to calculate LiquidityFees, a non-negative float
	LiquidityFee string `json:"liquidityFee"`
}

// The fees applicable to a market
type Fees struct {
	// The factors used to calculate the different fees
	Factors *FeeFactors `json:"factors"`
}

// A Future product
type Future struct {
	// The maturity date of the product (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// The name of the asset (string)
	Asset *Asset `json:"asset"`
	// The oracle used for this product (Oracle union)
	Oracle Oracle `json:"oracle"`
}

func (Future) IsProduct() {}

type FutureProduct struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	Asset *Asset `json:"asset"`
}

// Future product configuration
type FutureProductInput struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	Asset string `json:"asset"`
}

// Describe something that can be traded on Vega
type Instrument struct {
	// Uniquely identify an instrument accrods all instruments available on Vega (string)
	ID string `json:"id"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)
	Code string `json:"code"`
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Metadata for this instrument
	Metadata *InstrumentMetadata `json:"metadata"`
	// A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)
	Product Product `json:"product"`
}

type InstrumentConfiguration struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Future product specification
	FutureProduct *FutureProduct `json:"futureProduct"`
}

type InstrumentConfigurationInput struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Future product specification
	FutureProduct *FutureProductInput `json:"futureProduct"`
}

// A set of metadata to associate to an instruments
type InstrumentMetadata struct {
	// An arbitrary list of tags to associated to associate to the Instrument (string list)
	Tags []string `json:"tags"`
}

type LedgerEntry struct {
	// account from which the asset was taken
	FromAccount string `json:"fromAccount"`
	// account to which the balance was transferred
	ToAccount string `json:"toAccount"`
	// the amount transferred
	Amount int `json:"amount"`
	// The transfer reference
	Reference string `json:"reference"`
	// Type of ledger entry
	Type string `json:"type"`
	// The time at which the transfer was made
	Timestamp string `json:"timestamp"`
}

// Parameters for the log normal risk model
type LogNormalModelParams struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

type LogNormalModelParamsInput struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

// A type of risk model for futures trading
type LogNormalRiskModel struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParams `json:"params"`
}

func (LogNormalRiskModel) IsRiskModel() {}

type LogNormalRiskModelInput struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParamsInput `json:"params"`
}

type LossSocialization struct {
	// the market ID where loss socialization happened
	MarketID string `json:"marketID"`
	// the party that was part of the loss socialization
	PartyID string `json:"partyID"`
	// the amount lost
	Amount int `json:"amount"`
}

func (LossSocialization) IsEvent() {}

type MarginCalculator struct {
	// The scaling factors that will be used for margin calculation
	ScalingFactors *ScalingFactors `json:"scalingFactors"`
}

// Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market struct {
	// Market ID
	ID string `json:"id"`
	// Market full name
	Name string `json:"name"`
	// Fees related data
	Fees *Fees `json:"fees"`
	// An instance of or reference to a tradable instrument.
	TradableInstrument *TradableInstrument `json:"tradableInstrument"`
	// Definitions and required configuration for the trading mode
	TradingMode TradingMode `json:"tradingMode"`
	// decimalPlaces indicates the number of decimal places that an integer must be shifted by in order to get a correct
	// number denominated in the currency of the Market. (uint64)
	//
	// Examples:
	//   Currency     Balance  decimalPlaces  Real Balance
	//   GBP              100              0       GBP 100
	//   GBP              100              2       GBP   1.00
	//   GBP              100              4       GBP   0.01
	//   GBP                1              4       GBP   0.0001   (  0.01p  )
	//
	//   GBX (pence)      100              0       GBP   1.00     (100p     )
	//   GBX (pence)      100              2       GBP   0.01     (  1p     )
	//   GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
	//   GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
	DecimalPlaces int `json:"decimalPlaces"`
	// Orders on a market
	Orders []*proto.Order `json:"orders"`
	// Get account for a party or market
	Accounts []*proto.Account `json:"accounts"`
	// Trades on a market
	Trades []*proto.Trade `json:"trades"`
	// Current depth on the orderbook for this market
	Depth *proto.MarketDepth `json:"depth"`
	// Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params
	Candles []*proto.Candle `json:"candles"`
	// marketData for the given market
	Data *proto.MarketData `json:"data"`
}

func (Market) IsEvent() {}

type MarketEvent struct {
	// the market ID
	MarketID string `json:"marketID"`
	// the message - market events are used for logging
	Payload string `json:"payload"`
}

func (MarketEvent) IsEvent() {}

type MarketTick struct {
	// the market ID
	MarketID string `json:"marketID"`
	// the block time
	Time string `json:"time"`
}

func (MarketTick) IsEvent() {}

// A new asset proposal change
type NewAsset struct {
	// the source of the new Asset
	Source AssetSource `json:"source"`
}

func (NewAsset) IsProposalChange() {}

// A new asset to be added into vega
type NewAssetInput struct {
	// A new builtin assed to be created
	BuiltinAsset *BuiltinAssetInput `json:"builtinAsset"`
	// A new ERC20 asset to be created
	Erc20 *ERC20Input `json:"erc20"`
}

type NewMarket struct {
	// New market instrument configuration
	Instrument *InstrumentConfiguration `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters RiskModel `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// Trading mode
	TradingMode TradingMode `json:"tradingMode"`
}

func (NewMarket) IsProposalChange() {}

// Allows creating new markets on the network
type NewMarketInput struct {
	// New market instrument configuration
	Instrument *InstrumentConfigurationInput `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters *RiskParametersInput `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// The proposed duration for the opening auction for this market in seconds
	OpeningAuctionDurationSecs *int `json:"openingAuctionDurationSecs"`
	// A mode where Vega try to execute order as soon as they are received. Valid only if discreteTrading is not set
	ContinuousTrading *ContinuousTradingInput `json:"continuousTrading"`
	// Frequent batch auctions trading mode. Valid only if continuousTrading is not set
	DiscreteTrading *DiscreteTradingInput `json:"discreteTrading"`
}

// An estimate of the fee to be paid by the order
type OrderEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
	// The margin requirement for this order
	MarginLevels *proto.MarginLevels `json:"marginLevels"`
}

type PositionResolution struct {
	// the market ID where position resolution happened
	MarketID string `json:"marketID"`
	// number of distressed traders on market
	Distressed int `json:"distressed"`
	// number of traders closed out
	Closed int `json:"closed"`
	// the mark price at which traders were distressed/closed out
	MarkPrice int `json:"markPrice"`
}

func (PositionResolution) IsEvent() {}

type PreparedAmendOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedCancelOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedProposal struct {
	// Raw transaction data to sign & submit
	Blob string `json:"blob"`
	// The pending proposal
	PendingProposal *proto.GovernanceData `json:"pendingProposal"`
}

type PreparedSubmitOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedVote struct {
	// Raw, serialised vote to be signed
	Blob string `json:"blob"`
	// The vote serialised in the blob field
	Vote *ProposalVote `json:"vote"`
}

type PreparedWithdrawal struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type ProposalTerms struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Actual change being introduced by the proposal - action the proposal triggers if passed and enacted.
	Change ProposalChange `json:"change"`
}

// Proposal terms input. Only one kind of change is expected. Proposals with no changes or more than one will not be accepted.
type ProposalTermsInput struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Field defining new market change - the proposal will create new market if passed and enacted.
	// It can only be set if "updateMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	NewMarket *NewMarketInput `json:"newMarket"`
	// Field defining update market change - the proposal will update existing market if passed and enacted.
	// It can only be set if "newMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateMarket *UpdateMarketInput `json:"updateMarket"`
	// Field defining update network change - the proposal will update Vega network parameters if passed and enacted.
	// It can only be set if "newMarket" and "updateMarket" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateNetwork *UpdateNetworkInput `json:"updateNetwork"`
	// a new Asset proposal, this will create a new asset to be used in the vega network
	NewAsset *NewAssetInput `json:"newAsset"`
}

type ProposalVote struct {
	// Cast vote
	Vote *Vote `json:"vote"`
	// Proposal casting the vote on
	ProposalID string `json:"proposalId"`
}

type RiskParametersInput struct {
	// Simple risk model parameters. Set only if risk model is Simple
	Simple *SimpleRiskModelParamsInput `json:"simple"`
	// Log normal risk model parameters. Set only if risk model is LogNormal
	LogNormal *LogNormalRiskModelInput `json:"logNormal"`
}

type ScalingFactors struct {
	// the scaling factor that determines the margin level at which we have to search for more money
	SearchLevel float64 `json:"searchLevel"`
	// the scaling factor that determines the optimal margin level
	InitialMargin float64 `json:"initialMargin"`
	// The scaling factor that determines the overflow margin level
	CollateralRelease float64 `json:"collateralRelease"`
}

type SettleDistressed struct {
	// the market in which a position was closed out
	MarketID string `json:"marketID"`
	// the party who closed out
	PartyID string `json:"partyID"`
	// the margin taken from distressed trader
	Margin int `json:"margin"`
	// the price at which position was closed out
	Price int `json:"price"`
}

func (SettleDistressed) IsEvent() {}

type SettlePosition struct {
	// the market in which a position was settled
	MarketID string `json:"marketID"`
	// the party who settled a position
	PartyID string `json:"partyID"`
	// the settle price
	Price int `json:"price"`
	// the trades that were settled to close the overall position
	TradeSettlements []*TradeSettlement `json:"tradeSettlements"`
}

func (SettlePosition) IsEvent() {}

// A signature to be bundled with a transaction
type SignatureInput struct {
	// The signature, base64 encoded
	Sig string `json:"sig"`
	// The algorithm used to produice the signature
	Algo string `json:"algo"`
	// The version of the signature
	Version int `json:"version"`
}

// A type of simple/dummy risk model where we can specify the risk factor long and short in params
type SimpleRiskModel struct {
	// Params for the simple risk model
	Params *SimpleRiskModelParams `json:"params"`
}

func (SimpleRiskModel) IsRiskModel() {}

// Parameters for the simple risk model
type SimpleRiskModelParams struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

type SimpleRiskModelParamsInput struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

type TimeUpdate struct {
	// timestamp - new block time
	Timestamp string `json:"timestamp"`
}

func (TimeUpdate) IsEvent() {}

// A tradable instrument is a combination of an instrument and a risk model
type TradableInstrument struct {
	// An instance of or reference to a fully specified instrument.
	Instrument *Instrument `json:"instrument"`
	// A reference to a risk model that is valid for the instrument
	RiskModel RiskModel `json:"riskModel"`
	// Margin calculation info, currently only the scaling factors (search, initial, release) for this tradable instrument
	MarginCalculator *MarginCalculator `json:"marginCalculator"`
}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the node runner to maintain the vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the market makers to provide liquidity in the market
	LiquidityFee string `json:"liquidityFee"`
}

type TradeSettlement struct {
	// the size of the trade
	Size int `json:"size"`
	// the price of the trade
	Price int `json:"price"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

type TransferBalance struct {
	// Account involved in transfer
	Account *proto.Account `json:"account"`
	// The new balance of the account
	Balance int `json:"balance"`
}

type TransferResponse struct {
	// the ledger entries and balances resulting from a transfer request
	Transfers []*LedgerEntry `json:"transfers"`
	// the balances of accounts involved in the transfer
	Balances []*TransferBalance `json:"balances"`
}

type TransferResponses struct {
	// a group of transfer responses - events from core
	Responses []*TransferResponse `json:"responses"`
}

func (TransferResponses) IsEvent() {}

// Incomplete change definition for governance proposal terms
// TODO: complete the type
type UpdateMarket struct {
	MarketID string `json:"marketId"`
}

func (UpdateMarket) IsProposalChange() {}

type UpdateMarketInput struct {
	MarketID string `json:"marketId"`
}

// Allows submitting a proposal for changing governance network parameters
type UpdateNetwork struct {
	// Network parameter that restricts when the earliest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MinCloseInSeconds *int `json:"minCloseInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MaxCloseInSeconds *int `json:"maxCloseInSeconds"`
	// Network parameter that restricts when the earliest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MinEnactInSeconds *int `json:"minEnactInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MaxEnactInSeconds *int `json:"maxEnactInSeconds"`
	// Network parameter that sets participation level required for any proposal to pass.
	// Value from 0 to 1.
	RequiredParticipation *float64 `json:"requiredParticipation"`
	// Network parameter that sets majority level required for any proposal to pass.
	// Value from 0.5 to 1.
	RequiredMajority *float64 `json:"requiredMajority"`
	// Network parameter that sets minimum balance required for a party
	// to be able to submit a new proposal. Value greater than 0 to 1.
	MinProposerBalance *float64 `json:"minProposerBalance"`
	// Network parameter that sets minimum balance required for a party
	// to be able to cast a vote.  Value greater than 0 to 1.
	MinVoterBalance *float64 `json:"minVoterBalance"`
}

func (UpdateNetwork) IsProposalChange() {}

// Allows submitting a proposal for changing governance network parameters
type UpdateNetworkInput struct {
	// Network parameter that restricts when the earliest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MinCloseInSeconds *int `json:"minCloseInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MaxCloseInSeconds *int `json:"maxCloseInSeconds"`
	// Network parameter that restricts when the earliest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MinEnactInSeconds *int `json:"minEnactInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MaxEnactInSeconds *int `json:"maxEnactInSeconds"`
	// Network parameter that sets participation level required for any proposal to pass.
	// Value from 0 to 1.
	RequiredParticipation *float64 `json:"requiredParticipation"`
	// Network parameter that sets majority level required for any proposal to pass.
	// Value from 0.5 to 1.
	RequiredMajority *float64 `json:"requiredMajority"`
	// Network parameter that sets minimum balance required for a party
	// to be able to submit a new proposal. Value greater than 0 to 1.
	MinProposerBalance *float64 `json:"minProposerBalance"`
	// Network parameter that sets minimum balance required for a party
	// to be able to cast a vote.  Value greater than 0 to 1.
	MinVoterBalance *float64 `json:"minVoterBalance"`
}

type Vote struct {
	// The vote value cast
	Value VoteValue `json:"value"`
	// The party casting the vote
	Party *proto.Party `json:"party"`
	// ISO-8601 time and date when the vote reached Vega network
	Datetime string `json:"datetime"`
}

func (Vote) IsEvent() {}

// The details of a withdrawal processed by vega
type Withdrawal struct {
	// The Vega internal id of the withdrawal
	ID string `json:"id"`
	// The PartyID initiating the witndrawal
	Party *proto.Party `json:"party"`
	// The amount to be withdrawn
	Amount string `json:"amount"`
	// The asset to be withdrawn
	Asset *Asset `json:"asset"`
	// The current status of the withdrawal
	Status WithdrawalStatus `json:"status"`
	// A reference the foreign chain can use to refere to when processing the withdrawal
	Ref string `json:"ref"`
	// The time until when the withdrawal will be valid (RFC3339Nano)
	Expiry string `json:"expiry"`
	// Time at which the withdrawal was created (RFC3339Nano)
	CreatedTimestamp string `json:"createdTimestamp"`
	// Time at which the withdrawal was finalized (RFC3339Nano)
	WithdrawnTimestamp *string `json:"withdrawnTimestamp"`
	// Hash of the transaction on the foreign chain
	TxHash *string `json:"txHash"`
	// Foreign chain specific details about the withdrawal
	Details WithdrawalDetails `json:"details"`
}

// The various account types we have (used by collateral)
type AccountType string

const (
	// Insurance pool account - only for 'system' party
	AccountTypeInsurance AccountType = "Insurance"
	// Settlement - only for 'system' party
	AccountTypeSettlement AccountType = "Settlement"
	// Margin - The leverage account for traders
	AccountTypeMargin AccountType = "Margin"
	// General account - the account containing 'unused' collateral for traders
	AccountTypeGeneral AccountType = "General"
	// Infrastructure fee account - the account where all infrastructure fees are collected
	AccountTypeFeeInfrastructure AccountType = "FeeInfrastructure"
	// Liquidity fee account - the account where all infrastructure fees are collected
	AccountTypeFeeLiquidity AccountType = "FeeLiquidity"
	// LockWithdraw - and account use for party in the process of withdrawing funds
	AccountTypeLockWithdraw AccountType = "LockWithdraw"
)

var AllAccountType = []AccountType{
	AccountTypeInsurance,
	AccountTypeSettlement,
	AccountTypeMargin,
	AccountTypeGeneral,
	AccountTypeFeeInfrastructure,
	AccountTypeFeeLiquidity,
	AccountTypeLockWithdraw,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeInsurance, AccountTypeSettlement, AccountTypeMargin, AccountTypeGeneral, AccountTypeFeeInfrastructure, AccountTypeFeeLiquidity, AccountTypeLockWithdraw:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BusEventType string

const (
	// all events
	BusEventTypeAll BusEventType = "All"
	// event type indicating TimeUpdate
	BusEventTypeTimeUpdate BusEventType = "TimeUpdate"
	// transfer response event
	BusEventTypeTransferResponses BusEventType = "TransferResponses"
	// position resolution event
	BusEventTypePositionResolution BusEventType = "PositionResolution"
	// order event
	BusEventTypeOrder BusEventType = "Order"
	// account event
	BusEventTypeAccount BusEventType = "Account"
	// party event
	BusEventTypeParty BusEventType = "Party"
	// trade event
	BusEventTypeTrade BusEventType = "Trade"
	// margin levels event
	BusEventTypeMarginLevels BusEventType = "MarginLevels"
	// proposal event
	BusEventTypeProposal BusEventType = "Proposal"
	// vote event
	BusEventTypeVote BusEventType = "Vote"
	// market data event
	BusEventTypeMarketData BusEventType = "MarketData"
	// node signature event
	BusEventTypeNodeSignature BusEventType = "NodeSignature"
	// loss socialization event
	BusEventTypeLossSocialization BusEventType = "LossSocialization"
	// settle position event
	BusEventTypeSettlePosition BusEventType = "SettlePosition"
	// settle distressed event
	BusEventTypeSettleDistressed BusEventType = "SettleDistressed"
	// market created event
	BusEventTypeMarketCreated BusEventType = "MarketCreated"
	// asset event
	BusEventTypeAsset BusEventType = "Asset"
	// market tick event
	BusEventTypeMarketTick BusEventType = "MarketTick"
	// auction event
	BusEventTypeAuction BusEventType = "Auction"
	// risk factor event
	BusEventTypeRiskFactor BusEventType = "RiskFactor"
	// constant for market events - mainly used for logging
	BusEventTypeMarket BusEventType = "Market"
)

var AllBusEventType = []BusEventType{
	BusEventTypeAll,
	BusEventTypeTimeUpdate,
	BusEventTypeTransferResponses,
	BusEventTypePositionResolution,
	BusEventTypeOrder,
	BusEventTypeAccount,
	BusEventTypeParty,
	BusEventTypeTrade,
	BusEventTypeMarginLevels,
	BusEventTypeProposal,
	BusEventTypeVote,
	BusEventTypeMarketData,
	BusEventTypeNodeSignature,
	BusEventTypeLossSocialization,
	BusEventTypeSettlePosition,
	BusEventTypeSettleDistressed,
	BusEventTypeMarketCreated,
	BusEventTypeAsset,
	BusEventTypeMarketTick,
	BusEventTypeAuction,
	BusEventTypeRiskFactor,
	BusEventTypeMarket,
}

func (e BusEventType) IsValid() bool {
	switch e {
	case BusEventTypeAll, BusEventTypeTimeUpdate, BusEventTypeTransferResponses, BusEventTypePositionResolution, BusEventTypeOrder, BusEventTypeAccount, BusEventTypeParty, BusEventTypeTrade, BusEventTypeMarginLevels, BusEventTypeProposal, BusEventTypeVote, BusEventTypeMarketData, BusEventTypeNodeSignature, BusEventTypeLossSocialization, BusEventTypeSettlePosition, BusEventTypeSettleDistressed, BusEventTypeMarketCreated, BusEventTypeAsset, BusEventTypeMarketTick, BusEventTypeAuction, BusEventTypeRiskFactor, BusEventTypeMarket:
		return true
	}
	return false
}

func (e BusEventType) String() string {
	return string(e)
}

func (e *BusEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusEventType", str)
	}
	return nil
}

func (e BusEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a deposit
type DepositStatus string

const (
	// The deposit is open and being processed by the network
	DepositStatusOpen DepositStatus = "Open"
	// The deposit have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	DepositStatusCancelled DepositStatus = "Cancelled"
	// The deposit was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts
	DepositStatusFinalized DepositStatus = "Finalized"
)

var AllDepositStatus = []DepositStatus{
	DepositStatusOpen,
	DepositStatusCancelled,
	DepositStatusFinalized,
}

func (e DepositStatus) IsValid() bool {
	switch e {
	case DepositStatusOpen, DepositStatusCancelled, DepositStatusFinalized:
		return true
	}
	return false
}

func (e DepositStatus) String() string {
	return string(e)
}

func (e *DepositStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DepositStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DepositStatus", str)
	}
	return nil
}

func (e DepositStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval for trade candles when subscribing via VEGA graphql, default is I15M
type Interval string

const (
	// 1 minute interval
	IntervalI1m Interval = "I1M"
	// 5 minute interval
	IntervalI5m Interval = "I5M"
	// 15 minute interval (default)
	IntervalI15m Interval = "I15M"
	// 1 hour interval
	IntervalI1h Interval = "I1H"
	// 6 hour interval
	IntervalI6h Interval = "I6H"
	// 1 day interval
	IntervalI1d Interval = "I1D"
)

var AllInterval = []Interval{
	IntervalI1m,
	IntervalI5m,
	IntervalI15m,
	IntervalI1h,
	IntervalI6h,
	IntervalI1d,
}

func (e Interval) IsValid() bool {
	switch e {
	case IntervalI1m, IntervalI5m, IntervalI15m, IntervalI1h, IntervalI6h, IntervalI1d:
		return true
	}
	return false
}

func (e Interval) String() string {
	return string(e)
}

func (e *Interval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Interval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Interval", str)
	}
	return nil
}

func (e Interval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// What market state are we in
type MarketState string

const (
	// Continuous trading where orders are processed and potentially matched on arrival
	MarketStateContinuous MarketState = "CONTINUOUS"
	// Auction at market open
	MarketStateAuctionOpening MarketState = "AUCTION_OPENING"
	// Auction seeking more liquidity for the market
	MarketStateAuctionLiquidity MarketState = "AUCTION_LIQUIDITY"
	// Auction triggered by price monitoring
	MarketStateAuctionPrice MarketState = "AUCTION_PRICE"
	// Frequent Batch Auction mode
	MarketStateAuctionFrequentBatch MarketState = "AUCTION_FREQUENT_BATCH"
)

var AllMarketState = []MarketState{
	MarketStateContinuous,
	MarketStateAuctionOpening,
	MarketStateAuctionLiquidity,
	MarketStateAuctionPrice,
	MarketStateAuctionFrequentBatch,
}

func (e MarketState) IsValid() bool {
	switch e {
	case MarketStateContinuous, MarketStateAuctionOpening, MarketStateAuctionLiquidity, MarketStateAuctionPrice, MarketStateAuctionFrequentBatch:
		return true
	}
	return false
}

func (e MarketState) String() string {
	return string(e)
}

func (e *MarketState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketState", str)
	}
	return nil
}

func (e MarketState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type signature provided by a node
type NodeSignatureKind string

const (
	// A signature for proposing a new asset into the network
	NodeSignatureKindAssetNew NodeSignatureKind = "AssetNew"
	// A signature for allowing a withdrawal of funds
	NodeSignatureKindAssetWithdrawal NodeSignatureKind = "AssetWithdrawal"
)

var AllNodeSignatureKind = []NodeSignatureKind{
	NodeSignatureKindAssetNew,
	NodeSignatureKindAssetWithdrawal,
}

func (e NodeSignatureKind) IsValid() bool {
	switch e {
	case NodeSignatureKindAssetNew, NodeSignatureKindAssetWithdrawal:
		return true
	}
	return false
}

func (e NodeSignatureKind) String() string {
	return string(e)
}

func (e *NodeSignatureKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeSignatureKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeSignatureKind", str)
	}
	return nil
}

func (e NodeSignatureKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the order beeing rejected by the core node
type OrderRejectionReason string

const (
	// Market id is invalid
	OrderRejectionReasonInvalidMarketID OrderRejectionReason = "InvalidMarketId"
	// Order id is invalid
	OrderRejectionReasonInvalidOrderID OrderRejectionReason = "InvalidOrderId"
	// Order is out of sequence
	OrderRejectionReasonOrderOutOfSequence OrderRejectionReason = "OrderOutOfSequence"
	// Remaining size in the order is invalid
	OrderRejectionReasonInvalidRemainingSize OrderRejectionReason = "InvalidRemainingSize"
	// Time has failed us
	OrderRejectionReasonTimeFailure OrderRejectionReason = "TimeFailure"
	// Unable to remove the order
	OrderRejectionReasonOrderRemovalFailure OrderRejectionReason = "OrderRemovalFailure"
	// Expiration time is invalid
	OrderRejectionReasonInvalidExpirationTime OrderRejectionReason = "InvalidExpirationTime"
	// Order reference is invalid
	OrderRejectionReasonInvalidOrderReference OrderRejectionReason = "InvalidOrderReference"
	// Edit is not allowed
	OrderRejectionReasonEditNotAllowed OrderRejectionReason = "EditNotAllowed"
	// Order amend fail
	OrderRejectionReasonOrderAmendFailure OrderRejectionReason = "OrderAmendFailure"
	// Order does not exist
	OrderRejectionReasonOrderNotFound OrderRejectionReason = "OrderNotFound"
	// Party id is invalid
	OrderRejectionReasonInvalidPartyID OrderRejectionReason = "InvalidPartyId"
	// Market is closed
	OrderRejectionReasonMarketClosed OrderRejectionReason = "MarketClosed"
	// Margin check failed
	OrderRejectionReasonMarginCheckFailed OrderRejectionReason = "MarginCheckFailed"
	// Order missing general account
	OrderRejectionReasonMissingGeneralAccount OrderRejectionReason = "MissingGeneralAccount"
	// An internal error happend
	OrderRejectionReasonInternalError OrderRejectionReason = "InternalError"
	// Invalid size
	OrderRejectionReasonInvalidSize OrderRejectionReason = "InvalidSize"
	// Invalid persistence
	OrderRejectionReasonInvalidPersistence OrderRejectionReason = "InvalidPersistence"
	// Invalid type
	OrderRejectionReasonInvalidType OrderRejectionReason = "InvalidType"
	// Self trading
	OrderRejectionReasonSelfTrading OrderRejectionReason = "SelfTrading"
	// Insufficient funds to pay fees
	OrderRejectionReasonInsufficientFundsToPayFees OrderRejectionReason = "InsufficientFundsToPayFees"
	// Invalid Time In Force
	OrderRejectionReasonInvalidTimeInForce OrderRejectionReason = "InvalidTimeInForce"
	// Attempt to amend order to GTT without ExpiryAt
	OrderRejectionReasonAmendToGTTWithoutExpiryAt OrderRejectionReason = "AmendToGTTWithoutExpiryAt"
	// Attempt to amend ExpiryAt to a value before CreatedAt
	OrderRejectionReasonExpiryAtBeforeCreatedAt OrderRejectionReason = "ExpiryAtBeforeCreatedAt"
	// Attempt to amend to GTC without an ExpiryAt value
	OrderRejectionReasonGTCWithExpiryAtNotValid OrderRejectionReason = "GTCWithExpiryAtNotValid"
	// Amending to FOK or IOC is invalid
	OrderRejectionReasonCannotAmendToFOKOrIoc OrderRejectionReason = "CannotAmendToFOKOrIOC"
	// Amending to GFA or GFN is invalid
	OrderRejectionReasonCannotAmendToGFAOrGfn OrderRejectionReason = "CannotAmendToGFAOrGFN"
	// Amending from GFA or GFN is invalid
	OrderRejectionReasonCannotAmendFromGFAOrGfn OrderRejectionReason = "CannotAmendFromGFAOrGFN"
	// Invalid Market Type
	OrderRejectionReasonInvalidMarketType OrderRejectionReason = "InvalidMarketType"
	// Good for normal order received during an auction
	OrderRejectionReasonGFAOrderDuringAuction OrderRejectionReason = "GFAOrderDuringAuction"
	// Good for auction order received during continuous trading
	OrderRejectionReasonGFNOrderDuringContinuousTrading OrderRejectionReason = "GFNOrderDuringContinuousTrading"
)

var AllOrderRejectionReason = []OrderRejectionReason{
	OrderRejectionReasonInvalidMarketID,
	OrderRejectionReasonInvalidOrderID,
	OrderRejectionReasonOrderOutOfSequence,
	OrderRejectionReasonInvalidRemainingSize,
	OrderRejectionReasonTimeFailure,
	OrderRejectionReasonOrderRemovalFailure,
	OrderRejectionReasonInvalidExpirationTime,
	OrderRejectionReasonInvalidOrderReference,
	OrderRejectionReasonEditNotAllowed,
	OrderRejectionReasonOrderAmendFailure,
	OrderRejectionReasonOrderNotFound,
	OrderRejectionReasonInvalidPartyID,
	OrderRejectionReasonMarketClosed,
	OrderRejectionReasonMarginCheckFailed,
	OrderRejectionReasonMissingGeneralAccount,
	OrderRejectionReasonInternalError,
	OrderRejectionReasonInvalidSize,
	OrderRejectionReasonInvalidPersistence,
	OrderRejectionReasonInvalidType,
	OrderRejectionReasonSelfTrading,
	OrderRejectionReasonInsufficientFundsToPayFees,
	OrderRejectionReasonInvalidTimeInForce,
	OrderRejectionReasonAmendToGTTWithoutExpiryAt,
	OrderRejectionReasonExpiryAtBeforeCreatedAt,
	OrderRejectionReasonGTCWithExpiryAtNotValid,
	OrderRejectionReasonCannotAmendToFOKOrIoc,
	OrderRejectionReasonCannotAmendToGFAOrGfn,
	OrderRejectionReasonCannotAmendFromGFAOrGfn,
	OrderRejectionReasonInvalidMarketType,
	OrderRejectionReasonGFAOrderDuringAuction,
	OrderRejectionReasonGFNOrderDuringContinuousTrading,
}

func (e OrderRejectionReason) IsValid() bool {
	switch e {
	case OrderRejectionReasonInvalidMarketID, OrderRejectionReasonInvalidOrderID, OrderRejectionReasonOrderOutOfSequence, OrderRejectionReasonInvalidRemainingSize, OrderRejectionReasonTimeFailure, OrderRejectionReasonOrderRemovalFailure, OrderRejectionReasonInvalidExpirationTime, OrderRejectionReasonInvalidOrderReference, OrderRejectionReasonEditNotAllowed, OrderRejectionReasonOrderAmendFailure, OrderRejectionReasonOrderNotFound, OrderRejectionReasonInvalidPartyID, OrderRejectionReasonMarketClosed, OrderRejectionReasonMarginCheckFailed, OrderRejectionReasonMissingGeneralAccount, OrderRejectionReasonInternalError, OrderRejectionReasonInvalidSize, OrderRejectionReasonInvalidPersistence, OrderRejectionReasonInvalidType, OrderRejectionReasonSelfTrading, OrderRejectionReasonInsufficientFundsToPayFees, OrderRejectionReasonInvalidTimeInForce, OrderRejectionReasonAmendToGTTWithoutExpiryAt, OrderRejectionReasonExpiryAtBeforeCreatedAt, OrderRejectionReasonGTCWithExpiryAtNotValid, OrderRejectionReasonCannotAmendToFOKOrIoc, OrderRejectionReasonCannotAmendToGFAOrGfn, OrderRejectionReasonCannotAmendFromGFAOrGfn, OrderRejectionReasonInvalidMarketType, OrderRejectionReasonGFAOrderDuringAuction, OrderRejectionReasonGFNOrderDuringContinuousTrading:
		return true
	}
	return false
}

func (e OrderRejectionReason) String() string {
	return string(e)
}

func (e *OrderRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderRejectionReason", str)
	}
	return nil
}

func (e OrderRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
type OrderStatus string

const (
	// The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
	// Active does not necessarily mean it's still on the order book.
	OrderStatusActive OrderStatus = "Active"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
	OrderStatusExpired OrderStatus = "Expired"
	// The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
	OrderStatusCancelled OrderStatus = "Cancelled"
	// This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity.
	OrderStatusStopped OrderStatus = "Stopped"
	// This order is fully filled with remaining equals zero.
	OrderStatusFilled OrderStatus = "Filled"
	// This order was rejected while beeing processed in the core.
	OrderStatusRejected OrderStatus = "Rejected"
	// This order was partially filled.
	OrderStatusPartiallyFilled OrderStatus = "PartiallyFilled"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusActive,
	OrderStatusExpired,
	OrderStatusCancelled,
	OrderStatusStopped,
	OrderStatusFilled,
	OrderStatusRejected,
	OrderStatusPartiallyFilled,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusActive, OrderStatusExpired, OrderStatusCancelled, OrderStatusStopped, OrderStatusFilled, OrderStatusRejected, OrderStatusPartiallyFilled:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order types, these determine what happens when an order is added to the book
type OrderTimeInForce string

const (
	// The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
	OrderTimeInForceFok OrderTimeInForce = "FOK"
	// The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
	OrderTimeInForceIoc OrderTimeInForce = "IOC"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
	OrderTimeInForceGtc OrderTimeInForce = "GTC"
	// This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
	// NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
	OrderTimeInForceGtt OrderTimeInForce = "GTT"
	// This order is only accepted during an auction period
	OrderTimeInForceGfa OrderTimeInForce = "GFA"
	// This order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
	OrderTimeInForceGfn OrderTimeInForce = "GFN"
)

var AllOrderTimeInForce = []OrderTimeInForce{
	OrderTimeInForceFok,
	OrderTimeInForceIoc,
	OrderTimeInForceGtc,
	OrderTimeInForceGtt,
	OrderTimeInForceGfa,
	OrderTimeInForceGfn,
}

func (e OrderTimeInForce) IsValid() bool {
	switch e {
	case OrderTimeInForceFok, OrderTimeInForceIoc, OrderTimeInForceGtc, OrderTimeInForceGtt, OrderTimeInForceGfa, OrderTimeInForceGfn:
		return true
	}
	return false
}

func (e OrderTimeInForce) String() string {
	return string(e)
}

func (e *OrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTimeInForce", str)
	}
	return nil
}

func (e OrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderType string

const (
	// the default order type
	OrderTypeMarket OrderType = "MARKET"
	// mentioned in ticket, but as yet unused order type
	OrderTypeLimit OrderType = "LIMIT"
	// Used for distressed traders, an order placed by the network to close out distressed traders
	// similar to MARKET order, only no party is attached to the order.
	OrderTypeNetwork OrderType = "NETWORK"
)

var AllOrderType = []OrderType{
	OrderTypeMarket,
	OrderTypeLimit,
	OrderTypeNetwork,
}

func (e OrderType) IsValid() bool {
	switch e {
	case OrderTypeMarket, OrderTypeLimit, OrderTypeNetwork:
		return true
	}
	return false
}

func (e OrderType) String() string {
	return string(e)
}

func (e *OrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderType", str)
	}
	return nil
}

func (e OrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the proposal beeing rejected by the core node
type ProposalRejectionReason string

const (
	// The specified close time is too early based on network parameters
	ProposalRejectionReasonCloseTimeTooSoon ProposalRejectionReason = "CloseTimeTooSoon"
	// The specified close time is too late based on network parameters
	ProposalRejectionReasonCloseTimeTooLate ProposalRejectionReason = "CloseTimeTooLate"
	// The specified enactment time is too early based on network parameters
	ProposalRejectionReasonEnactTimeTooSoon ProposalRejectionReason = "EnactTimeTooSoon"
	// The specified enactment time is too late based on network parameters
	ProposalRejectionReasonEnactTimeTooLate ProposalRejectionReason = "EnactTimeTooLate"
	// The proposer for this proposal as insufficient token
	ProposalRejectionReasonInsufficientTokens ProposalRejectionReason = "InsufficientTokens"
	// The instrument quote name and base name were the same
	ProposalRejectionReasonInvalidInstrumentSecurity ProposalRejectionReason = "InvalidInstrumentSecurity"
	// The proposal has no product specified
	ProposalRejectionReasonNoProduct ProposalRejectionReason = "NoProduct"
	// The specified product is not supported
	ProposalRejectionReasonUnsupportedProduct ProposalRejectionReason = "UnsupportedProduct"
	// Invalid future maturity timestamp (expect RFC3339)
	ProposalRejectionReasonInvalidFutureMaturityTimestamp ProposalRejectionReason = "InvalidFutureMaturityTimestamp"
	// The product maturity is already in the past
	ProposalRejectionReasonProductMaturityIsPassed ProposalRejectionReason = "ProductMaturityIsPassed"
	// The proposal has no trading mode
	ProposalRejectionReasonNoTradingMode ProposalRejectionReason = "NoTradingMode"
	// The proposal has an unsupported trading mode
	ProposalRejectionReasonUnsupportedTradingMode ProposalRejectionReason = "UnsupportedTradingMode"
	// The proposal failed node validation
	ProposalRejectionReasonNodeValidationFailed ProposalRejectionReason = "NodeValidationFailed"
	// A builtin asset configuration is missing
	ProposalRejectionReasonMissingBuiltinAssetField ProposalRejectionReason = "MissingBuiltinAssetField"
	// The ERC20 contract address is missing from an ERC20 asset proposal
	ProposalRejectionReasonMissingERC20ContractAddress ProposalRejectionReason = "MissingERC20ContractAddress"
	// The specified asset for the market proposal is invalid
	ProposalRejectionReasonInvalidAsset ProposalRejectionReason = "InvalidAsset"
	// proposal terms timestamps are not compatible (Validation < Closing < Enactment)
	ProposalRejectionReasonIncompatibleTimestamps ProposalRejectionReason = "IncompatibleTimestamps"
)

var AllProposalRejectionReason = []ProposalRejectionReason{
	ProposalRejectionReasonCloseTimeTooSoon,
	ProposalRejectionReasonCloseTimeTooLate,
	ProposalRejectionReasonEnactTimeTooSoon,
	ProposalRejectionReasonEnactTimeTooLate,
	ProposalRejectionReasonInsufficientTokens,
	ProposalRejectionReasonInvalidInstrumentSecurity,
	ProposalRejectionReasonNoProduct,
	ProposalRejectionReasonUnsupportedProduct,
	ProposalRejectionReasonInvalidFutureMaturityTimestamp,
	ProposalRejectionReasonProductMaturityIsPassed,
	ProposalRejectionReasonNoTradingMode,
	ProposalRejectionReasonUnsupportedTradingMode,
	ProposalRejectionReasonNodeValidationFailed,
	ProposalRejectionReasonMissingBuiltinAssetField,
	ProposalRejectionReasonMissingERC20ContractAddress,
	ProposalRejectionReasonInvalidAsset,
	ProposalRejectionReasonIncompatibleTimestamps,
}

func (e ProposalRejectionReason) IsValid() bool {
	switch e {
	case ProposalRejectionReasonCloseTimeTooSoon, ProposalRejectionReasonCloseTimeTooLate, ProposalRejectionReasonEnactTimeTooSoon, ProposalRejectionReasonEnactTimeTooLate, ProposalRejectionReasonInsufficientTokens, ProposalRejectionReasonInvalidInstrumentSecurity, ProposalRejectionReasonNoProduct, ProposalRejectionReasonUnsupportedProduct, ProposalRejectionReasonInvalidFutureMaturityTimestamp, ProposalRejectionReasonProductMaturityIsPassed, ProposalRejectionReasonNoTradingMode, ProposalRejectionReasonUnsupportedTradingMode, ProposalRejectionReasonNodeValidationFailed, ProposalRejectionReasonMissingBuiltinAssetField, ProposalRejectionReasonMissingERC20ContractAddress, ProposalRejectionReasonInvalidAsset, ProposalRejectionReasonIncompatibleTimestamps:
		return true
	}
	return false
}

func (e ProposalRejectionReason) String() string {
	return string(e)
}

func (e *ProposalRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalRejectionReason", str)
	}
	return nil
}

func (e ProposalRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Varoius states a proposal can transition through:
//   Open ->
//       - Passed -> Enacted.
//       - Rejected.
//   Proposal can enter Failed state from any other state.
type ProposalState string

const (
	// Proposal became invalid and cannot be processed
	ProposalStateFailed ProposalState = "Failed"
	// Proposal is open for voting
	ProposalStateOpen ProposalState = "Open"
	// Proposal has gained enough support to be executed
	ProposalStatePassed ProposalState = "Passed"
	// Proposal didn't get enough votes
	ProposalStateDeclined ProposalState = "Declined"
	// Proposal has could not gain enough support to be executed
	ProposalStateRejected ProposalState = "Rejected"
	// Proposal has been executed and the changes under this proposal have now been applied
	ProposalStateEnacted ProposalState = "Enacted"
	// Proposal is waiting for the node to run validation
	ProposalStateWaitingForNodeVote ProposalState = "WaitingForNodeVote"
)

var AllProposalState = []ProposalState{
	ProposalStateFailed,
	ProposalStateOpen,
	ProposalStatePassed,
	ProposalStateDeclined,
	ProposalStateRejected,
	ProposalStateEnacted,
	ProposalStateWaitingForNodeVote,
}

func (e ProposalState) IsValid() bool {
	switch e {
	case ProposalStateFailed, ProposalStateOpen, ProposalStatePassed, ProposalStateDeclined, ProposalStateRejected, ProposalStateEnacted, ProposalStateWaitingForNodeVote:
		return true
	}
	return false
}

func (e ProposalState) String() string {
	return string(e)
}

func (e *ProposalState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalState", str)
	}
	return nil
}

func (e ProposalState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether the placer of an order is aiming to buy or sell on the market
type Side string

const (
	// The Placer of the order is aiming to buy
	SideBuy Side = "Buy"
	// The placer of the order is aiming to sell
	SideSell Side = "Sell"
)

var AllSide = []Side{
	SideBuy,
	SideSell,
}

func (e Side) IsValid() bool {
	switch e {
	case SideBuy, SideSell:
		return true
	}
	return false
}

func (e Side) String() string {
	return string(e)
}

func (e *Side) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Side(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Side", str)
	}
	return nil
}

func (e Side) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid trade types
type TradeType string

const (
	// Default trade type
	TradeTypeDefault TradeType = "Default"
	// Network close-out - good
	TradeTypeNetworkCloseOutGood TradeType = "NetworkCloseOutGood"
	// Network close-out - bad
	TradeTypeNetworkCloseOutBad TradeType = "NetworkCloseOutBad"
)

var AllTradeType = []TradeType{
	TradeTypeDefault,
	TradeTypeNetworkCloseOutGood,
	TradeTypeNetworkCloseOutBad,
}

func (e TradeType) IsValid() bool {
	switch e {
	case TradeTypeDefault, TradeTypeNetworkCloseOutGood, TradeTypeNetworkCloseOutBad:
		return true
	}
	return false
}

func (e TradeType) String() string {
	return string(e)
}

func (e *TradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeType", str)
	}
	return nil
}

func (e TradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteValue string

const (
	// NO reject a proposal
	VoteValueNo VoteValue = "NO"
	// YES accept a proposal
	VoteValueYes VoteValue = "YES"
)

var AllVoteValue = []VoteValue{
	VoteValueNo,
	VoteValueYes,
}

func (e VoteValue) IsValid() bool {
	switch e {
	case VoteValueNo, VoteValueYes:
		return true
	}
	return false
}

func (e VoteValue) String() string {
	return string(e)
}

func (e *VoteValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteValue", str)
	}
	return nil
}

func (e VoteValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a withdrawal
type WithdrawalStatus string

const (
	// The withdrawal is open and being processed by the network
	WithdrawalStatusOpen WithdrawalStatus = "Open"
	// The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	WithdrawalStatusCancelled WithdrawalStatus = "Cancelled"
	// The withdrawal was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts
	WithdrawalStatusFinalized WithdrawalStatus = "Finalized"
)

var AllWithdrawalStatus = []WithdrawalStatus{
	WithdrawalStatusOpen,
	WithdrawalStatusCancelled,
	WithdrawalStatusFinalized,
}

func (e WithdrawalStatus) IsValid() bool {
	switch e {
	case WithdrawalStatusOpen, WithdrawalStatusCancelled, WithdrawalStatusFinalized:
		return true
	}
	return false
}

func (e WithdrawalStatus) String() string {
	return string(e)
}

func (e *WithdrawalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WithdrawalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WithdrawalStatus", str)
	}
	return nil
}

func (e WithdrawalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
