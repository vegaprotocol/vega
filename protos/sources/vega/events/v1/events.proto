syntax = "proto3";

package vega.events.v1;

import "vega/assets.proto";
import "vega/commands/v1/commands.proto";
import "vega/commands/v1/data.proto";
import "vega/commands/v1/validator_commands.proto";
import "vega/governance.proto";
import "vega/markets.proto";
import "vega/oracle.proto";
import "vega/vega.proto";

option go_package = "code.vegaprotocol.io/vega/protos/vega/events/v1";

// Summary of the vesting and locked balances for an epoch
message VestingBalancesSummary {
  // Epoch for which these balances are valid.
  uint64 epoch_seq = 1;
  // Parties' summaries.
  repeated PartyVestingSummary parties_vesting_summary = 2;
}

// Summary of a party's vesting balances
message PartyVestingSummary {
  // Party ID.
  string party = 1;
  // List of locked balances.
  repeated PartyLockedBalance party_locked_balances = 2;
  // List of vesting balances.
  repeated PartyVestingBalance party_vesting_balances = 3;
}

// A party's locked balance for a given asset.
message PartyLockedBalance {
  // Asset ID.
  string asset = 1;
  // Epoch in which the balance will be released.
  uint64 until_epoch = 2;
  // Locked balance.
  string balance = 3;
}

// Balance that is being vested for the party.
message PartyVestingBalance {
  // Asset ID.
  string asset = 1;
  // Balance that is vested.
  string balance = 2;
}

// Stats of all parties eligible for volume discount.
message VolumeDiscountStatsUpdated {
  // Epoch at which the volume discount statistics are updated.
  uint64 at_epoch = 1;
  // All parties' stats.
  repeated PartyVolumeDiscountStats stats = 2;
}

// Volume discount stats for a given party.
message PartyVolumeDiscountStats {
  // Party ID.
  string party_id = 1;
  // Discount factor applied to fees.
  string discount_factor = 2;
  // The party's running volume.
  string running_volume = 3;
}

// Stats of all parties invested in the vesting program.
message VestingStatsUpdated {
  // Epoch at which the vesting statistics are updated.
  uint64 at_epoch = 1;
  // All parties stats.
  repeated PartyVestingStats stats = 2;
}

// The vesting stats for a given party.
message PartyVestingStats {
  // The party.
  string party_id = 1;
  // The bonus multiplier applied on the reward.
  string reward_bonus_multiplier = 2;
  // The balance of the party, in quantum.
  string quantum_balance = 3;
}

// Fees rewards and discounts paid / received per parties during an epoch
message FeesStats {
  reserved 10;

  // Market the fees were paid in
  string market = 1;
  // Settlement asset of the market.
  string asset = 2;
  // Epoch for which these stats where valid.
  uint64 epoch_seq = 3;
  // Total referral rewards received by the referrer of the referral set.
  repeated PartyAmount total_rewards_received = 4;
  // Referral rewards generated by all referee taker fees.
  repeated ReferrerRewardsGenerated referrer_rewards_generated = 5;
  // Total referral discounts applied to all referee taker fees.
  repeated PartyAmount referees_discount_applied = 6;
  // Total volume discounts applied to all referee taker fees.
  repeated PartyAmount volume_discount_applied = 7;
  // Total maker fees received by the maker side.
  repeated PartyAmount total_maker_fees_received = 8;
  // Maker fees paid by all trade aggressors, and which makers the fees were paid to.
  repeated MakerFeesGenerated maker_fees_generated = 9;
  // Total trading fees received and paid by the party.
  repeated PartyAmount total_fees_paid_and_received = 11;
}

// Rewards generated for referrers by each of their referees
message ReferrerRewardsGenerated {
  // Referrer party.
  string referrer = 1;
  // Amount of rewards generated per party.
  repeated PartyAmount generated_reward = 2;
}

// Maker fees generated by the trade aggressor
message MakerFeesGenerated {
  // Party that paid the fees.
  string taker = 1;
  // Amount of maker fees paid by the taker to the maker.
  repeated PartyAmount maker_fees_paid = 2;
}

// A pair of a party and amount
message PartyAmount {
  // Receiving party ID.
  string party = 1;
  // Amount received.
  string amount = 2;
  // Amount value in quantum.
  string quantum_amount = 3;
}

// The updated activity streak of a party at end of epoch
message PartyActivityStreak {
  // The party.
  string party = 1;
  // How many epoch this party has been active for.
  uint64 active_for = 2;
  // how many epoch this party has been inactive for.
  uint64 inactive_for = 3;
  // Is this party considered active or not.
  bool is_active = 4;
  // The current rewards distribution multiplier for this party.
  string reward_distribution_activity_multiplier = 5;
  // The vesting multiplier for this party.
  string reward_vesting_activity_multiplier = 6;
  // The epoch this information is relevant to.
  uint64 epoch = 7;
  // Party's traded volume at the end of the given epoch
  string traded_volume = 8;
  // Party's open interest volume at the end of the given epoch
  string open_volume = 9;
}

// Event notifying on the details of a funding interval for a perpetuals market.
message FundingPeriod {
  // ID of the market for which this funding period relates to.
  string market_id = 1;
  // Sequence number of the funding period.
  uint64 seq = 2;
  // Time in Unix nanoseconds when the funding period started.
  int64 start = 3;
  // Time in Unix nanoseconds when the funding period ended.
  optional int64 end = 4;
  // Funding payment for this period as the difference between the time-weighted average price of the external and internal data point.
  optional string funding_payment = 5;
  // Percentage difference between the time-weighted average price of the external and internal data point.
  optional string funding_rate = 6;
  // TWAP for this period based on the internal data-points.
  optional string internal_twap = 7;
  // TWAP for this period based on the external data-points.
  optional string external_twap = 8;
}

// The amount gained or lost by a party as a result of a funding payment.
message FundingPayment {
  // ID of the party.
  string party_id = 1;
  // The amount paid, this can be negative for parties who lost at the end of the funding period.
  string amount = 2;
}

// Event notifying of funding payments at the end of a funding period.
message FundingPayments {
  // ID of the market.
  string market_id = 1;
  // Sequence number of the funding period associated with these payments.
  uint64 seq = 2;
  // List of parties and the payment amounts, this can be negative for parties who lost at the end of the funding period.
  repeated FundingPayment payments = 3;
}

// Event notifying a data point for a funding period.
message FundingPeriodDataPoint {
  enum Source {
    // Default value
    SOURCE_UNSPECIFIED = 0;
    // Data point is from an external data source, such as an oracle, and represents the spot price of the underlying asset.
    SOURCE_EXTERNAL = 1;
    // Data point from within Vega such as the mark price after performing mark-to-market.
    SOURCE_INTERNAL = 2;
  }

  // Market ID which the data point relates to.
  string market_id = 1;
  // Sequence number of the funding period this data point belongs to.
  uint64 seq = 2;
  // Origin of the data point.
  Source data_point_type = 3;
  // Price of the asset as seen by this data point.
  string price = 4;
  // Timestamp in Unix nanoseconds of when the data point was received.
  int64 timestamp = 6;
  // The TWAP for this source with this data-point added.
  string twap = 7;
}

message StopOrderEvent {
  commands.v1.OrderSubmission submission = 1;
  vega.StopOrder stop_order = 2;
}

message ERC20MultiSigSignerAdded {
  // ID of the signature bundle
  string signature_id = 1;
  // Node ID of the Vega node to be added
  string validator_id = 2;
  // Time at which this happened
  int64 timestamp = 3;
  // Ethereum address of the new signer
  string new_signer = 4;
  // Address of the submitter of the transaction
  string submitter = 5;
  // Nonce used.
  string nonce = 6;
  // Epoch that the node was added for
  string epoch_seq = 7;
}

message ERC20MultiSigSignerRemovedSubmitter {
  // Signature ID of the signer removed.
  string signature_id = 1;
  // Address of the submitter of the transaction
  string submitter = 2;
}

message ERC20MultiSigSignerRemoved {
  // List containing all the IDs of bundle generated
  // There should be one bundle generated for every validators
  // in the validator set
  repeated ERC20MultiSigSignerRemovedSubmitter signature_submitters = 1;
  // Node ID of the Vega node which is to be removed
  string validator_id = 2;
  // Time at which this happened
  int64 timestamp = 3;
  // Ethereum address of the signer to be removed
  string old_signer = 4;
  // Nonce used.
  string nonce = 5;
  // Epoch that the node was removed for
  string epoch_seq = 6;
}

message Transfer {
  enum Status {
    // Default value
    STATUS_UNSPECIFIED = 0;
    // Indicates a transfer still being processed
    STATUS_PENDING = 1;
    // Indicates a transfer accepted by the Vega network
    STATUS_DONE = 2;
    // Indicates a transfer rejected by the Vega network
    STATUS_REJECTED = 3;
    // Indicates a transfer stopped by the Vega network
    // e.g: no funds left to cover the transfer
    STATUS_STOPPED = 4;
    // Indicates a transfer cancelled by the user
    STATUS_CANCELLED = 5;
  }

  string id = 1;
  string from = 2;
  vega.AccountType from_account_type = 3;
  string to = 4;
  vega.AccountType to_account_type = 5;
  string asset = 6;
  string amount = 7;
  string reference = 8;
  Status status = 9;
  int64 timestamp = 10;
  optional string reason = 11;
  // ID of the game this transfer was made in relation to. A transfer is made to members of a team
  // or participants who take part in a game and are rewarded for their participation
  optional string game_id = 12;

  oneof kind {
    OneOffTransfer one_off = 101;
    RecurringTransfer recurring = 102;
    OneOffGovernanceTransfer one_off_governance = 103;
    RecurringGovernanceTransfer recurring_governance = 104;
  }
}

message OneOffGovernanceTransfer {
  int64 deliver_on = 1;
}

message OneOffTransfer {
  int64 deliver_on = 1;
}

message RecurringTransfer {
  uint64 start_epoch = 1;
  optional uint64 end_epoch = 2;
  string factor = 3;
  DispatchStrategy dispatch_strategy = 4;
}

message RecurringGovernanceTransfer {
  uint64 start_epoch = 1;
  optional uint64 end_epoch = 2;
  optional DispatchStrategy dispatch_strategy = 3;
}

// StakeLinking - an event notifying of stake being deposited or removed for a given party
// These events are emitted for every Staking deposit or removed accepted by the network
message StakeLinking {
  enum Type {
    // Default value
    TYPE_UNSPECIFIED = 0;
    // Indicate of a stake deposit instruction
    TYPE_LINK = 1;
    // Indicate of a stake remove instruction
    TYPE_UNLINK = 2;
  }

  enum Status {
    // Default value
    STATUS_UNSPECIFIED = 0;
    // Indicates an event waiting for confirmation from the Vega network
    STATUS_PENDING = 1;
    // Indicates an event accepted by the Vega network
    STATUS_ACCEPTED = 2;
    // Indicates an event rejected by the Vega network
    STATUS_REJECTED = 3;
  }

  // Internal ID for this staking event
  string id = 1;
  // Stake linking event type.
  Type type = 2;
  // Timestamp in Unix nanoseconds of when the event was emitted by Ethereum.
  int64 ts = 3;
  // Party to whom the event is directed at.
  string party = 4;
  // Amount of stake deposited or removed.
  string amount = 5;
  // Status of the event.
  Status status = 6;
  // Time at which the Vega network finalised the state of the event.
  int64 finalized_at = 7;
  // Hash of the transaction in which the event happened.
  string tx_hash = 8;
  // Block when the event happened.
  uint64 block_height = 9;
  // Block time.
  int64 block_time = 10;
  // Log index.
  uint64 log_index = 11;
  // Ethereum address from which the stake link was initiated.
  string ethereum_address = 12;
}

message ERC20MultiSigSignerEvent {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_ADDED = 1;
    TYPE_REMOVED = 2;
  }

  string id = 1;
  Type type = 2;
  string signer = 3;
  string nonce = 4;
  int64 block_time = 5;
  string tx_hash = 6;
  uint64 log_index = 7;
  uint64 block_number = 8;
}

message ERC20MultiSigThresholdSetEvent {
  string id = 1;
  uint32 new_threshold = 2;
  string nonce = 3;
  int64 block_time = 4;
  string tx_hash = 5;
  uint64 log_index = 6;
  uint64 block_number = 7;
}

message CheckpointEvent {
  string hash = 1;
  string block_hash = 2;
  uint64 block_height = 3;
}

message StreamStartEvent {
  string chain_id = 1;
}

message RewardPayoutEvent {
  string party = 1;
  string epoch_seq = 2;
  string asset = 3;
  string amount = 4;
  string percent_of_total_reward = 5;
  int64 timestamp = 6;
  string reward_type = 7;
  reserved 8;
  string locked_until_epoch = 9;
  string quantum_amount = 10;
  optional string game_id = 11;
}

// ValidatorScoreEvent is the score a validator gets for a given epoch
message ValidatorScoreEvent {
  string node_id = 1;
  string epoch_seq = 2;
  string validator_score = 3;
  string normalised_score = 4;
  string validator_performance = 5;
  string raw_validator_score = 6;
  string validator_status = 7;
  string multisig_score = 8;
}

// DelegationBalanceEvent - updates on the delegation balance of a party to a node in the current epoch in effect
message DelegationBalanceEvent {
  string party = 1;
  string node_id = 2;
  string amount = 3;
  string epoch_seq = 4;
}

// MarketEvent - the common denominator for all market events
// interface has a method to return a string for logging
message MarketEvent {
  // Market ID for the event
  string market_id = 1;
  // Payload is a unique information string
  string payload = 2;
}

message TransferFees {
  // Transfer that triggered the collection of fees.
  string transfer_id = 1;
  // Amount of fees paid.
  string amount = 2;
  // Epoch when the transfer was dispatched, and fees were paid.
  uint64 epoch = 3;
  // Amount that was subtracted from the transfer fee based on available discounts.
  string discount_applied = 4;
}

message TransferFeesDiscount {
  // Party that the transfer fee discount applies to.
  string party = 1;
  // Asset that the transfer fee discount is relevant to.
  string asset = 2;
  // Amount that the transfer fee was discounted by.
  string amount = 3;
  // Epoch in which the discount was first available.
  uint64 epoch = 4;
}

message TransactionResult {
  // Unique party ID for the related party
  string party_id = 1;
  // Status of the transaction, did it succeed or an error was raised.
  bool status = 2;
  // Hash of the transaction
  string hash = 3;
  // Transaction itself as received by the network

  oneof transaction {
    commands.v1.OrderSubmission order_submission = 101;
    commands.v1.OrderAmendment order_amendment = 102;
    commands.v1.OrderCancellation order_cancellation = 103;
    commands.v1.ProposalSubmission proposal = 104;
    commands.v1.VoteSubmission vote_submission = 105;
    commands.v1.LiquidityProvisionSubmission liquidity_provision_submission = 106;
    commands.v1.WithdrawSubmission withdraw_submission = 107;
    commands.v1.DelegateSubmission delegate_submission = 108;
    commands.v1.UndelegateSubmission undelegate_submission = 109;
    commands.v1.LiquidityProvisionCancellation liquidity_provision_cancellation = 111;
    commands.v1.LiquidityProvisionAmendment liquidity_provision_amendment = 112;
    commands.v1.Transfer transfer = 113;
    commands.v1.CancelTransfer cancel_transfer = 114;
    commands.v1.AnnounceNode announce_node = 115;
    commands.v1.OracleDataSubmission oracle_data_submission = 116;
    commands.v1.ProtocolUpgradeProposal protocol_upgrade_proposal = 117;
    commands.v1.IssueSignatures issue_signatures = 118;
    commands.v1.BatchMarketInstructions batch_market_instructions = 119;
    commands.v1.KeyRotateSubmission key_rotate_submission = 120;
    commands.v1.EthereumKeyRotateSubmission ethereum_key_rotate_submission = 121;
    commands.v1.StopOrdersSubmission stop_order_submission = 122;
    commands.v1.StopOrdersCancellation stop_order_cancellation = 123;
    commands.v1.CreateReferralSet create_referral_set = 124;
    commands.v1.UpdateReferralSet update_referral_set = 125;
    commands.v1.ApplyReferralCode apply_referral_code = 126;
    commands.v1.UpdateMarginMode update_margin_mode = 127;
    commands.v1.JoinTeam join_team = 128;
    commands.v1.BatchProposalSubmission batch_proposal = 129;
    commands.v1.UpdatePartyProfile update_party_profile = 130;
    commands.v1.SubmitAMM submit_amm = 131;
    commands.v1.AmendAMM amend_amm = 132;
    commands.v1.CancelAMM cancel_amm = 133;
  }

  // extra details about the transaction processing
  oneof extra {
    SuccessDetails success = 1001;
    FailureDetails failure = 1002;
  }

  message SuccessDetails {
    // TBD
  }

  message FailureDetails {
    // Error message explaining the reason for the transaction failing processing
    string error = 1;
  }
}

message TxErrorEvent {
  // This was the old restore checkpoint command
  reserved 110;

  // Unique party ID for the related party
  string party_id = 1;
  // Error message describing what went wrong
  string err_msg = 2;
  // Transaction that failed
  oneof transaction {
    commands.v1.OrderSubmission order_submission = 101;
    commands.v1.OrderAmendment order_amendment = 102;
    commands.v1.OrderCancellation order_cancellation = 103;
    commands.v1.ProposalSubmission proposal = 104;
    commands.v1.VoteSubmission vote_submission = 105;
    commands.v1.LiquidityProvisionSubmission liquidity_provision_submission = 106;
    commands.v1.WithdrawSubmission withdraw_submission = 107;
    commands.v1.DelegateSubmission delegate_submission = 108;
    commands.v1.UndelegateSubmission undelegate_submission = 109;
    commands.v1.LiquidityProvisionCancellation liquidity_provision_cancellation = 111;
    commands.v1.LiquidityProvisionAmendment liquidity_provision_amendment = 112;
    commands.v1.Transfer transfer = 113;
    commands.v1.CancelTransfer cancel_transfer = 114;
    commands.v1.AnnounceNode announce_node = 115;
    commands.v1.OracleDataSubmission oracle_data_submission = 116;
    commands.v1.ProtocolUpgradeProposal protocol_upgrade_proposal = 117;
    commands.v1.IssueSignatures issue_signatures = 118;
    commands.v1.BatchMarketInstructions batch_market_instructions = 119;
  }
}

// Time update event contains the latest time update from Vega blockchain and indicates the start of a new block
message TimeUpdate {
  // Timestamp containing latest update from Vega blockchain aka Vega-time
  int64 timestamp = 1;
}

// Epoch details
message EpochEvent {
  // Sequence number that increases by one each epoch
  uint64 seq = 1;
  // Action tells us what action is taking place
  vega.EpochAction action = 2;
  // Vega time at which this epoch started
  int64 start_time = 3;
  // Vega time at which this epoch should end
  int64 expire_time = 4;
  // Vega time at which this epoch actually ended
  int64 end_time = 5;
}

// Transfer responses event contains a collection of transfer information
message LedgerMovements {
  // One or more entries containing internal transfer information
  repeated LedgerMovement ledger_movements = 1;
}

// Position resolution event contains information on distressed trades
message PositionResolution {
  // Market ID for the event
  string market_id = 1;
  // Number of distressed traders
  int64 distressed = 2;
  // Number of close outs
  int64 closed = 3;
  // Mark price as a string representing a scaled price
  string mark_price = 4;
}

// Loss socialization event contains details on the amount of wins unable to be distributed
message LossSocialization {
  // Market ID for the event
  string market_id = 1;
  // Party ID (public key) for the event
  string party_id = 2;
  // Amount distributed
  string amount = 3;
}

// Trade settlement is part of the settle position event
message TradeSettlement {
  // Size of trade settlement
  int64 size = 1;
  // Price of settlement as string (in asset decimals)
  string price = 2;
  // Price of settlement as a string (in market decimals)
  string market_price = 3;
}

// Settle position event contains position settlement information for a party
message SettlePosition {
  // Market ID for the event
  string market_id = 1;
  // Party ID (public key) for the event
  string party_id = 2;
  // Price of settlement as a string
  string price = 3;
  // A collection of 1 or more trade settlements
  repeated TradeSettlement trade_settlements = 4;
  // Position factor - 10 ^ number of position decimal places
  string position_factor = 5;
}

// Settle market event to notify data node that a market has been settled
// so positions and PL can be updated accordingly
message SettleMarket {
  // Market ID for the event
  string market_id = 1;
  // Price of settlement as a string
  string price = 2;
  // Position factor - 10 ^ number of position decimal places
  string position_factor = 3;
}

// Position state event contains the current position state for a single party in a single market
message PositionStateEvent {
  // Party ID for this position update
  string party_id = 1;
  // Market ID for this position update
  string market_id = 2;
  // Current position
  int64 size = 3;
  // Potential orders
  int64 potential_buys = 4;
  int64 potential_sells = 5;
  // Volume weighted prices
  string vw_buy_price = 6;
  string vw_sell_price = 7;
}

// Settle distressed event contains information on distressed trading parties who are closed out
message SettleDistressed {
  // Note: Any PositionResolution event (market level) will most likely be followed by a number of these events

  // Market ID for the event
  string market_id = 1;
  // Party ID i.e. a party's public key for the event
  string party_id = 2;
  // Margin value as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places
  string margin = 3;
  // Price as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places
  string price = 4;
}

// Distressed order contains the party IDs for all parties that were distressed and had their orders closed,
// but did not need to be closed out after cancelling their orders
message DistressedOrders {
  // Market ID for the event
  string market_id = 1;
  // Slice of Party IDs i.e. each party's public key for the event
  repeated string parties = 2;
}

// Distressed positions event contains the party IDs for all parties that were distressed, had their orders closed but because of insufficient volume on the book
// could not be fully closed out. These parties are distressed, but still hold an active position on the book as a result. Once enough volume is on the book to close
// them out, a SettleDistressed event will be sent. In case they manage to reduce their position, or meet the margin requirements, this status will be updated.
// Parties that are no longer distressed but active will be listed in the safe_parties field.
message DistressedPositions {
  // Market ID for the event
  string market_id = 1;
  // Slice of party IDs i.e. each party's public key, that are distressed but still have open volume
  repeated string distressed_parties = 2;
  // Slice of party IDs i.e. each party's public key, who were distressed but now can safely maintain their position
  repeated string safe_parties = 3;
}

// Market tick event contains the time value for when a particular market was last processed on Vega
message MarketTick {
  // Market ID for the event
  string id = 1;
  // Timestamp containing latest update from Vega blockchain aka Vega-time
  int64 time = 2;
}

// Auction event indicating a change in auction state, for example starting or ending an auction
message AuctionEvent {
  // Market ID for the event
  string market_id = 1;
  // True if the event indicates an auction opening and False otherwise
  bool opening_auction = 2;
  // True if the event indicates leaving auction mode and False otherwise
  bool leave = 3;
  // Timestamp containing the start time for an auction
  int64 start = 4;
  // Timestamp containing the end time for an auction
  int64 end = 5;
  // Reason this market is/was in auction
  AuctionTrigger trigger = 6;
  // If an auction was ongoing, but was extended for whatever reason, this field will
  // be set to the trigger type indicating which component extended the auction
  AuctionTrigger extension_trigger = 7;
}

// Validator update event contains information about validator node
message ValidatorUpdate {
  // Node ID of the validator node
  string node_id = 1;
  // Vega public key of validator node
  string vega_pub_key = 2;
  // Ethereum public key of validator node
  string ethereum_address = 3;
  // Public key of Tendermint
  string tm_pub_key = 4;
  // URL with more info on the node
  string info_url = 5;
  // Country code (ISO 3166-1 alpha-2) for the location of the node
  string country = 6;
  // Name of the validator
  string name = 7;
  // AvatarURL of the validator
  string avatar_url = 8;
  // Vega public key derivation index
  uint32 vega_pub_key_index = 9;
  // Flag indicating if the validator has been added to or removed from vega
  bool added = 10;
  // Epoch in which the announced pending node will start participating in the network
  uint64 from_epoch = 11;
  // Ethereum public key being used as the submitter to allow automatic signature generation
  string submitter_address = 12;
  // Epoch in which the node was announced or removed from the network
  uint64 epoch_seq = 13;
}

// Event that explains the status of the validator for the coming epoch
message ValidatorRankingEvent {
  string node_id = 1;
  // Stake based score - no anti-whaling
  string stake_score = 2;
  // Performance base score
  string performance_score = 3;
  // Final score
  string ranking_score = 4;
  // Status of the validator in the previous epoch
  string previous_status = 5;
  // Status of the validator in the next epoch
  string next_status = 6;
  // Epoch seq for which the status is valid
  string epoch_seq = 7;
  // Tendermint voting power of the validator
  uint32 tm_voting_power = 8;
}

// Event that contains information about a Vega key rotation
message KeyRotation {
  // Node ID of the node that rotated their Vega key
  string node_id = 1;
  // Vega public key that was previously associated with the node
  string old_pub_key = 2;
  // Vega public key that is newly associated with the node
  string new_pub_key = 3;
  // Block height when the key rotation took effect
  uint64 block_height = 4;
}

// Event that contains information about an Ethereum key rotation
message EthereumKeyRotation {
  // Node ID of the node that rotated their Ethereum key
  string node_id = 1;
  // Ethereum address that was previously associated with the node
  string old_address = 2;
  // Ethereum address that is newly associated with the node
  string new_address = 3;
  // Block height when the key rotation took effect
  uint64 block_height = 4;
}

enum ProtocolUpgradeProposalStatus {
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_UNSPECIFIED = 0;
  // The proposal is pending
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_PENDING = 1;
  // The proposal is approved
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_APPROVED = 2;
  // The proposal is rejected
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_REJECTED = 3;
}

message ProtocolUpgradeEvent {
  // Block height at which to perform the upgrade
  uint64 upgrade_block_height = 1;
  // Release tag for the vega binary
  string vega_release_tag = 2;
  // Tendermint validators that have agreed to the upgrade
  repeated string approvers = 3;
  // Status of the proposal
  ProtocolUpgradeProposalStatus status = 4;
}

// StateVar event updates on state changes in state variable consensus
message StateVar {
  string id = 1;
  string event_id = 2;
  string state = 3;
}

// BeginBlock
message BeginBlock {
  uint64 height = 1;
  int64 timestamp = 2;
  string hash = 3;
}

// EndBlock
message EndBlock {
  uint64 height = 1;
}

// Event indicating the core is starting a protocol upgrade
message ProtocolUpgradeStarted {
  uint64 last_block_height = 1;
}

// Event indicating the data node is ready for protocol upgrade
message ProtocolUpgradeDataNodeReady {
  uint64 last_block_height = 1;
}

// CoreSnapshotData represents the core snapshot data.
message CoreSnapshotData {
  // Block height at which snapshot was taken
  uint64 block_height = 1;
  // Hash of the snapshot block
  string block_hash = 2;
  // Semver version number of the core.
  string core_version = 3;
  // Indicates if the snapshot is taken as part of protocol upgrade
  bool protocol_upgrade_block = 4;
}

message ExpiredOrders {
  // Market ID for the event
  string market_id = 1;
  // Slice of expired order IDs
  repeated string order_ids = 2;
}

message TeamCreated {
  // The unique identifier of the created team.
  string team_id = 1;
  // The party that created the team.
  string referrer = 2;
  // Name of the team.
  string name = 3;
  // Link to the team's homepage.
  optional string team_url = 4;
  // Link to an image of the team's avatar.
  optional string avatar_url = 5;
  // Time in Unix nanoseconds when the team is created.
  int64 created_at = 6;
  // Tells if a party can join the team or not.
  bool closed = 7;
  // Epoch at which the team was created.
  uint64 at_epoch = 8;
  // List of public keys that are allowed to join the team.
  repeated string allow_list = 9;
}

message TeamUpdated {
  // The unique identifier for the updated team.
  string team_id = 1;
  // Name of the team.
  string name = 2;
  // Link to the team's homepage.
  optional string team_url = 3;
  // Link to an image of the team's avatar.
  optional string avatar_url = 4;
  // Tells if a party can join the team or not.
  bool closed = 5;
  // List of public keys that are allowed to join the team.
  repeated string allow_list = 6;
}

message RefereeSwitchedTeam {
  // The unique identifier of the team the referee left.
  string from_team_id = 1;
  // The unique identifier of the team joined.
  string to_team_id = 2;
  // The party that switched team.
  string referee = 3;
  // Time in Unix nanoseconds when the party switched team. This time acts as
  // the joining time.
  int64 switched_at = 4;
  // Epoch at which the party switched the team.
  uint64 at_epoch = 5;
}

message RefereeJoinedTeam {
  // The unique identifier of the team the referee joined.
  string team_id = 1;
  // The party that joined the team.
  string referee = 2;
  // Time in Unix nanoseconds when the party joined a team.
  int64 joined_at = 3;
  // Epoch at which the party joined the team.
  uint64 at_epoch = 4;
}

message ReferralSetCreated {
  // Unique ID of the created set.
  string set_id = 1;
  // Party that created the set.
  string referrer = 2;
  // Time in Unix nanoseconds when the set was created.
  int64 created_at = 3;
  // Time in Unix nanoseconds when the set was updated.
  int64 updated_at = 4;
}

message ReferralSetStatsUpdated {
  // Unique ID of the set.
  string set_id = 1;
  // Epoch at which the set's statistics are updated.
  uint64 at_epoch = 2;
  // Running volume for the set based on the window length of the current
  // referral program.
  string referral_set_running_notional_taker_volume = 3;
  // Referees' statistics for that epoch.
  repeated RefereeStats referees_stats = 4;
  // Reward factor applied to the trades.
  string reward_factor = 5;
  // Rewards multiplier applied to the trades.
  string rewards_multiplier = 6;
  // Rewards factor multiplier for the trades.
  string rewards_factor_multiplier = 7;
  // Indicates if the referral set was eligible to be part of the referral program.
  bool was_eligible = 8;
  // Taker volume of the referrer
  string referrer_taker_volume = 9;
}

message RefereeStats {
  // Unique ID of the party.
  string party_id = 1;
  // Discount factor applied to the party.
  string discount_factor = 2;
  // Current referee notional taker volume
  string epoch_notional_taker_volume = 4;
}

message RefereeJoinedReferralSet {
  // Unique ID of the referral set the referee joined.
  string set_id = 1;
  // Party that joined the set.
  string referee = 2;
  // Time in Unix nanoseconds when the party joined the set.
  int64 joined_at = 3;
  // Epoch at which the party joined the set.
  uint64 at_epoch = 4;
}

message ReferralProgramStarted {
  // Referral program that has started.
  vega.ReferralProgram program = 1;
  // Time in Unix nanoseconds when the referral program started.
  int64 started_at = 2;
  // Epoch at which the referral program started.
  uint64 at_epoch = 3;
}

message ReferralProgramUpdated {
  // The updated referral program.
  vega.ReferralProgram program = 1;
  // Time in Unix nanoseconds when the referral program was updated.
  int64 updated_at = 2;
  // Epoch at which the referral program was updated.
  uint64 at_epoch = 3;
}

message ReferralProgramEnded {
  // Program update version.
  uint64 version = 1;
  // Unique ID of the referral program.
  string id = 2;
  // Time in Unix nanoseconds when the referral program ended.
  int64 ended_at = 3;
  // Epoch at which the referral program ended.
  uint64 at_epoch = 4;
}

message VolumeDiscountProgramStarted {
  // Volume discount program that has started.
  vega.VolumeDiscountProgram program = 1;
  // Time in Unix nanoseconds when the volume discount program started.
  int64 started_at = 2;
  // Epoch at which the volume discount program started.
  uint64 at_epoch = 3;
}

message VolumeDiscountProgramUpdated {
  // The updated volume discount program.
  vega.VolumeDiscountProgram program = 1;
  // Time in Unix nanoseconds when the volume discount program was updated.
  int64 updated_at = 2;
  // Epoch at which the volume discount program was updated.
  uint64 at_epoch = 3;
}

message VolumeDiscountProgramEnded {
  // Program update version.
  uint64 version = 1;
  // Unique ID of the volume discount program.
  string id = 2;
  // Time in Unix nanoseconds when the referral program ended.
  int64 ended_at = 3;
  // Epoch at which the referral program ended.
  uint64 at_epoch = 4;
}

message PaidLiquidityFeesStats {
  // Market the fees were paid in.
  string market = 1;
  // Settlement asset of the market.
  string asset = 2;
  // Epoch for which these stats where valid.
  uint64 epoch_seq = 3;
  // Total fees paid across all parties.
  string total_fees_paid = 4;
  // Fees paid per party.
  repeated PartyAmount fees_paid_per_party = 5;
}

message PartyMarginModeUpdated {
  // Unique ID of the market in which the update happened.
  string market_id = 1;
  // Unique ID of the party that updated their margin mode.
  string party_id = 2;
  // Updated margin mode.
  vega.MarginMode margin_mode = 3;
  // Margin factor for the market. Isolated mode only.
  optional string margin_factor = 4;
  // Minimum theoretical margin factor for the market. Isolated mode only.
  optional string min_theoretical_margin_factor = 5;
  // Maximum theoretical leverage for the market. Isolated mode only.
  optional string max_theoretical_leverage = 6;
  // Epoch at which the update happened.
  uint64 at_epoch = 7;
}

message PartyProfileUpdated {
  // Party's profile updated.
  vega.PartyProfile updated_profile = 1;
}

// Bus event type is used to specify a type of event
// It has 2 styles of event:
// Single values (e.g. BUS_EVENT_TYPE_ORDER) where they represent one data item
// Group values (e.g. BUS_EVENT_TYPE_AUCTION) where they represent a group of data items
enum BusEventType {
  // Default value, always invalid
  BUS_EVENT_TYPE_UNSPECIFIED = 0;
  // Events of ALL event types, used when filtering stream from event bus
  BUS_EVENT_TYPE_ALL = 1;
  // Event for blockchain time updates
  BUS_EVENT_TYPE_TIME_UPDATE = 2;
  // Event for when a transfer happens internally, contains the transfer information
  BUS_EVENT_TYPE_LEDGER_MOVEMENTS = 3;
  // Event indicating position resolution has occurred
  BUS_EVENT_TYPE_POSITION_RESOLUTION = 4;
  // Event for order updates, both new and existing orders
  BUS_EVENT_TYPE_ORDER = 5;
  // Event for account updates
  BUS_EVENT_TYPE_ACCOUNT = 6;
  // Event for party updates
  BUS_EVENT_TYPE_PARTY = 7;
  // Event indicating a new trade has occurred
  BUS_EVENT_TYPE_TRADE = 8;
  // Event indicating margin levels have changed for a party
  BUS_EVENT_TYPE_MARGIN_LEVELS = 9;
  // Event for proposal updates (for governance)
  BUS_EVENT_TYPE_PROPOSAL = 10;
  // Event indicating a new vote has occurred (for governance)
  BUS_EVENT_TYPE_VOTE = 11;
  // Event for market data updates
  BUS_EVENT_TYPE_MARKET_DATA = 12;
  // Event for a new signature for a Vega node
  BUS_EVENT_TYPE_NODE_SIGNATURE = 13;
  // Event indicating loss socialisation occurred for a party
  BUS_EVENT_TYPE_LOSS_SOCIALIZATION = 14;
  // Event for when a position is being settled
  BUS_EVENT_TYPE_SETTLE_POSITION = 15;
  // Event for when a position is distressed
  BUS_EVENT_TYPE_SETTLE_DISTRESSED = 16;
  // Event indicating a new market was created
  BUS_EVENT_TYPE_MARKET_CREATED = 17;
  // Event for when an asset is added to Vega
  BUS_EVENT_TYPE_ASSET = 18;
  // Event indicating a market tick event
  BUS_EVENT_TYPE_MARKET_TICK = 19;
  // Event for when a withdrawal occurs
  BUS_EVENT_TYPE_WITHDRAWAL = 20;
  // Event for when a deposit occurs
  BUS_EVENT_TYPE_DEPOSIT = 21;
  // Event indicating a change in auction state, for example starting or ending an auction
  BUS_EVENT_TYPE_AUCTION = 22;
  // Event indicating a risk factor has been updated
  BUS_EVENT_TYPE_RISK_FACTOR = 23;
  // Event indicating a network parameter has been added or updated
  BUS_EVENT_TYPE_NETWORK_PARAMETER = 24;
  // Event indicating a liquidity provision has been created or updated
  BUS_EVENT_TYPE_LIQUIDITY_PROVISION = 25;
  // Event indicating a new market was created
  BUS_EVENT_TYPE_MARKET_UPDATED = 26;
  // Event indicating an oracle spec has been created or updated
  BUS_EVENT_TYPE_ORACLE_SPEC = 27;
  // Event indicating that an oracle data has been broadcast
  BUS_EVENT_TYPE_ORACLE_DATA = 28;
  // Event indicating that an delegation balance of a party to a node for current epoch has changed
  BUS_EVENT_TYPE_DELEGATION_BALANCE = 29;
  // Event indicating the validator score for the given epoch
  BUS_EVENT_TYPE_VALIDATOR_SCORE = 30;
  // Event indicating the start or end of an epoch
  BUS_EVENT_TYPE_EPOCH_UPDATE = 31;
  // Event indicating that validator node has been updated
  BUS_EVENT_TYPE_VALIDATOR_UPDATE = 32;
  // Event indicating a new staking event have been processed by the network
  BUS_EVENT_TYPE_STAKE_LINKING = 33;
  // Event indicating the payout of a reward has been initiated
  BUS_EVENT_TYPE_REWARD_PAYOUT_EVENT = 34;
  // Event indicating a new checkpoint was created
  BUS_EVENT_TYPE_CHECKPOINT = 35;
  // Event indicating stream is starting
  BUS_EVENT_TYPE_STREAM_START = 36;
  // Event indicating key rotation took place
  BUS_EVENT_TYPE_KEY_ROTATION = 37;
  // Event indicating state transitions in state variable consensus
  BUS_EVENT_TYPE_STATE_VAR = 38;
  // Event indicating network limits set or updated
  BUS_EVENT_TYPE_NETWORK_LIMITS = 39;
  // Event indicating a update for a transfer
  BUS_EVENT_TYPE_TRANSFER = 40;
  // Event indicating the ranking of validator and their status in Vega
  BUS_EVENT_TYPE_VALIDATOR_RANKING = 41;
  // Event indicating a new multi sig signer event have been processed
  BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_EVENT = 42;
  // Event indicating the erc20 multi sig threshold have been updated
  BUS_EVENT_TYPE_ERC20_MULTI_SIG_SET_THRESHOLD = 43;
  // Event indicating a new signer has been added to the ERC-20 multisig
  BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_ADDED = 44;
  // Event indicating a signer has been removed from the ERC-20 multisig
  BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_REMOVED = 45;
  // Event indicating that a party's position has changed
  BUS_EVENT_TYPE_POSITION_STATE = 46;
  // Event indicating Ethereum key rotation took place
  BUS_EVENT_TYPE_ETHEREUM_KEY_ROTATION = 47;
  // Event indicating protocol upgrade proposal updates
  BUS_EVENT_TYPE_PROTOCOL_UPGRADE_PROPOSAL = 48;
  // Event indicating the core is starting to process a new block
  BUS_EVENT_TYPE_BEGIN_BLOCK = 49;
  // Event indicating the core finished to process a block
  BUS_EVENT_TYPE_END_BLOCK = 50;
  // Event indicating the core is starting a protocol upgrade
  BUS_EVENT_TYPE_PROTOCOL_UPGRADE_STARTED = 51;
  // Event indicating the market has stopped and settled
  BUS_EVENT_TYPE_SETTLE_MARKET = 52;
  // Event indicating the result of a transaction processed by the network
  BUS_EVENT_TYPE_TRANSACTION_RESULT = 53;
  // Event indicating a snapshot was taken at this block height
  BUS_EVENT_TYPE_SNAPSHOT_TAKEN = 54;

  // Event data node uses to notify that it is ready to upgrade
  BUS_EVENT_TYPE_PROTOCOL_UPGRADE_DATA_NODE_READY = 55;

  // Event indicating parties had orders closed because they were distressed, but were not closed out.
  BUS_EVENT_TYPE_DISTRESSED_ORDERS_CLOSED = 56;
  // Event indicating parties had orders closed because they were distressed, but were not closed out.
  BUS_EVENT_TYPE_EXPIRED_ORDERS = 57;
  // Event indicating parties have become, or were, distressed but still have an active position.
  BUS_EVENT_TYPE_DISTRESSED_POSITIONS = 58;

  // Event indicating a spot liquidity provision has been created or updated.
  BUS_EVENT_TYPE_SPOT_LIQUIDITY_PROVISION = 59;

  // Event indicating a stop order has been submitted or updated.
  BUS_EVENT_TYPE_STOP_ORDER = 60;

  // Event indicating the start or end of a funding period.
  BUS_EVENT_TYPE_FUNDING_PERIOD = 61;

  // Event indicating a data point for a funding period has been received.
  BUS_EVENT_TYPE_FUNDING_PERIOD_DATA_POINT = 62;

  // Event indicating a team has been created.
  BUS_EVENT_TYPE_TEAM_CREATED = 63;

  // Event indicating a team has been updated.
  BUS_EVENT_TYPE_TEAM_UPDATED = 64;

  // Event indicating a referee switched team.
  BUS_EVENT_TYPE_REFEREE_SWITCHED_TEAM = 65;

  // Event indicating a referee joined a team.
  BUS_EVENT_TYPE_REFEREE_JOINED_TEAM = 66;

  // Event indicating a referral program started.
  BUS_EVENT_TYPE_REFERRAL_PROGRAM_STARTED = 67;

  // Event indicating a referral program has been updated.
  BUS_EVENT_TYPE_REFERRAL_PROGRAM_UPDATED = 68;

  // Event indicating a referral program ended.
  BUS_EVENT_TYPE_REFERRAL_PROGRAM_ENDED = 69;

  // Event indicating a set has been created.
  BUS_EVENT_TYPE_REFERRAL_SET_CREATED = 70;

  // Event indicating a referee joined a set.
  BUS_EVENT_TYPE_REFEREE_JOINED_REFERRAL_SET = 71;

  // Event indicating the updated activity streak for a party
  BUS_EVENT_TYPE_PARTY_ACTIVITY_STREAK = 72;

  // Event indicating a volume discount program started.
  BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_STARTED = 73;

  // Event indicating a volume discount program has been updated.
  BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_UPDATED = 74;

  // Event indicating a volume discount program ended.
  BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_ENDED = 75;

  // Event indicating the updated statistics for a referral set.
  BUS_EVENT_TYPE_REFERRAL_SET_STATS_UPDATED = 76;

  // Event indicating the updated statistics for the vesting program.
  BUS_EVENT_TYPE_VESTING_STATS_UPDATED = 77;

  // Event indicating the updated statistics for the volume discount.
  BUS_EVENT_TYPE_VOLUME_DISCOUNT_STATS_UPDATED = 78;

  // Event indicating the fees statistics per market at end of epoch
  BUS_EVENT_TYPE_FEES_STATS_UPDATED = 79;

  // Event indicating a funding period has ended and resulted in funding payment transfers.
  BUS_EVENT_TYPE_FUNDING_PAYMENTS = 80;

  // Event used to report the updated paid liquidity fee statistics for the market at the end of the epoch
  BUS_EVENT_TYPE_PAID_LIQUIDITY_FEES_STATS_UPDATED = 81;

  // Event used to report the summary of vesting and locked balances at the end of the epoch
  BUS_EVENT_TYPE_VESTING_SUMMARY = 82;

  // Event used to link ledger entries to the transfer that triggered the fees being collected.
  BUS_EVENT_TYPE_TRANSFER_FEES_PAID = 83;

  // Event indicating that a party's available transfer fee discount has changed, per asset.
  BUS_EVENT_TYPE_TRANSFER_FEES_DISCOUNT_UPDATED = 84;

  // Event indicating that a party updated their margin mode on a market.
  BUS_EVENT_TYPE_PARTY_MARGIN_MODE_UPDATED = 85;

  // Event indicating that a party updated their profile.
  BUS_EVENT_TYPE_PARTY_PROFILE_UPDATED = 86;

  // Event indicating a market related event, for example when a market opens
  BUS_EVENT_TYPE_MARKET = 101;
  // Event used to report failed transactions back to a user, this is excluded from the ALL type
  BUS_EVENT_TYPE_TX_ERROR = 201;
}

// Bus event is a container for event bus events emitted by Vega
message BusEvent {
  // Unique event ID for the message
  string id = 1;
  // The batch or block of transactions that the events relate to
  string block = 2;
  // The type of bus event. Must be one of the list below:
  BusEventType type = 3;
  oneof event {
    // Time update events
    TimeUpdate time_update = 101;
    // Transfer responses update events
    LedgerMovements ledger_movements = 102;
    // Position resolution events
    PositionResolution position_resolution = 103;
    // Order events
    Order order = 104;
    // Account events
    Account account = 105;
    // Party events
    Party party = 106;
    // Trade events
    Trade trade = 107;
    // Margin level update events
    MarginLevels margin_levels = 108;
    // Proposal events for governance
    Proposal proposal = 109;
    // Vote events for governance
    Vote vote = 110;
    // Market data events
    MarketData market_data = 111;
    // Node signature events
    vega.commands.v1.NodeSignature node_signature = 112;
    // Loss socialization events
    LossSocialization loss_socialization = 113;
    // Position settlement events
    SettlePosition settle_position = 114;
    // Position distressed events
    SettleDistressed settle_distressed = 115;
    // Market created events
    Market market_created = 116;
    // Asset events
    Asset asset = 117;
    // Market tick events
    MarketTick market_tick = 118;
    // Withdrawal events
    Withdrawal withdrawal = 119;
    // Deposit events
    Deposit deposit = 120;
    // Auction events
    AuctionEvent auction = 121;
    // Risk factor events
    RiskFactor risk_factor = 122;
    // Network parameter events
    NetworkParameter network_parameter = 123;
    // LiquidityProvision  events
    LiquidityProvision liquidity_provision = 124;
    // Market created events
    Market market_updated = 125;
    // OracleSpec events
    vega.OracleSpec oracle_spec = 126;
    // OracleData events
    vega.OracleData oracle_data = 127;
    // Delegation balance events
    DelegationBalanceEvent delegation_balance = 129;
    // Validator score calculated
    ValidatorScoreEvent validator_score = 130;
    // Epoch update events
    EpochEvent epoch_event = 131;
    // Validator update events
    ValidatorUpdate validator_update = 132;
    // Staking event
    StakeLinking stake_linking = 133;
    // Reward payout event
    RewardPayoutEvent reward_payout = 134;
    // Checkpoint was created
    CheckpointEvent checkpoint = 135;
    // Key rotation took place
    KeyRotation key_rotation = 136;
    // State variable consensus state transition update
    StateVar state_var = 137;
    // Network limits events
    NetworkLimits network_limits = 138;
    // Transfer event
    Transfer transfer = 139;
    // Ranking event
    ValidatorRankingEvent ranking_event = 140;
    // ERC20 multi sig signer event
    ERC20MultiSigSignerEvent erc20_multisig_signer_event = 141;
    // ERC20 multi sig set threshold event
    ERC20MultiSigThresholdSetEvent erc20_multisig_set_threshold_event = 142;
    // ERC20 multi sig signer added
    ERC20MultiSigSignerAdded erc20_multisig_signer_added = 143;
    // ERC20 multi sig signer removed
    ERC20MultiSigSignerRemoved erc20_multisig_signer_removed = 144;
    // Position status for a party in a market
    PositionStateEvent position_state_event = 145;
    // Ethereum key rotation took place
    EthereumKeyRotation ethereum_key_rotation = 146;
    // Protocol upgrade proposal updates
    ProtocolUpgradeEvent protocol_upgrade_event = 147;
    // Core is starting to process a new block
    BeginBlock begin_block = 148;
    // Core finished processing a block
    EndBlock end_block = 149;
    // Core is starting a protocol upgrade
    ProtocolUpgradeStarted protocol_upgrade_started = 150;
    // Settle market event for data-node to update positions for settled markets
    SettleMarket settle_market = 151;
    // Result of a transaction processed by the network
    TransactionResult transaction_result = 152;
    // Core snapshot has been taken at the end of the block
    CoreSnapshotData core_snapshot_event = 153;
    // Core snapshot has been taken at the end of the block
    ProtocolUpgradeDataNodeReady protocol_upgrade_data_node_ready = 154;
    // Parties that had their orders closed because they were distressed
    DistressedOrders distressed_orders = 155;
    // Orders that expired for a given market
    ExpiredOrders expired_orders = 156;
    // Open positions on the market that are/were distressed
    DistressedPositions distressed_positions = 157;
    // A stop order event
    StopOrderEvent stop_order = 158;
    // Start or end of a funding period.
    FundingPeriod funding_period = 159;
    // Data point within a funding period.
    FundingPeriodDataPoint funding_period_data_point = 160;
    // Event notifying of the creation of a team.m
    TeamCreated team_created = 161;
    // Event notifying of an update to a team.
    TeamUpdated team_updated = 162;
    // Event notifying that a referee switched teams.
    RefereeSwitchedTeam referee_switched_team = 163;
    // Event notifying that a referee joined a team.
    RefereeJoinedTeam referee_joined_team = 164;
    // Event notifying that a referral program has started.
    ReferralProgramStarted referral_program_started = 165;
    // Event notifying that a referral program has been updated.
    ReferralProgramUpdated referral_program_updated = 166;
    // Event notifying that a referral program has ended.
    ReferralProgramEnded referral_program_ended = 167;
    // Event notifying a referral set has been created.
    ReferralSetCreated referral_set_created = 168;
    // Event notifying a referee has joined a referral set.
    RefereeJoinedReferralSet referee_joined_referral_set = 169;
    // Event notifying of an update to a party's activity streak
    PartyActivityStreak party_activity_streak = 170;
    // Event notifying that a volume discount program has started.
    VolumeDiscountProgramStarted volume_discount_program_started = 171;
    // Event notifying that a volume discount program has been updated.
    VolumeDiscountProgramUpdated volume_discount_program_updated = 172;
    // Event notifying that a volume discount program has ended.
    VolumeDiscountProgramEnded volume_discount_program_ended = 173;
    // Event notifying of an update to a referral set's statistics.
    ReferralSetStatsUpdated referral_set_stats_updated = 174;
    // Event notifying of an update to the vesting statistics.
    VestingStatsUpdated vesting_stats_updated = 175;
    // Event notifying of an update to the volume discount statistics.
    VolumeDiscountStatsUpdated volume_discount_stats_updated = 176;
    // Event notifying of an update the fees stats for a market.
    FeesStats fees_stats = 177;
    // Event notifying of funding payments at the end of a funding period.
    FundingPayments funding_payments = 178;
    // Event notifying of an update to the liqudity fees stats for a market.
    PaidLiquidityFeesStats paid_liquidity_fees_stats = 179;
    // Event notifying of an update to the vesting and locked balances.
    VestingBalancesSummary vesting_balances_summary = 180;
    // Event notifying of fees related to a transfer being paid.
    TransferFees transfer_fees = 181;
    // Event notifying of a party's available discounts for transfer fees, per asset.
    TransferFeesDiscount transfer_fees_discount = 182;
    // Event notifying of a party's margin mode update on a market.
    PartyMarginModeUpdated party_margin_mode_updated = 183;
    // Event notifying of a party's profile update.
    PartyProfileUpdated party_profile_updated = 184;

    // Market tick events
    MarketEvent market = 1001;
    // Transaction error events, not included in the ALL event type
    TxErrorEvent tx_err_event = 2001;
  }
  // Version of bus event
  uint32 version = 4;
  string chain_id = 5;
  string tx_hash = 6;
}
