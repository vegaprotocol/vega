## VEGA - GraphQL schema

schema {
    query: Query
    subscription: Subscription
    mutation: Mutation
}

"Mutations are similar to GraphQL queries, however they allow a caller to change or mutate data."
type Mutation {

  """
  Send a submit order request to be prepared, and returns a blob of the transaction to submit.
  The OrderSubmit data is validated. Price and expiration will be converted to uint64 internally.
  """
  prepareOrderSubmit(
    "ID of the market to place the order"
    marketId: String!
    "ID of the party placing the order"
    partyId: String!
    "Price of the asset"
    price: String
    "Size of the order"
    size: String!
    "Side of the order (Buy or Sell)"
    side: Side!
    "TimeInForce of the order"
    timeInForce: OrderTimeInForce!
    "exiration of the the order"
    expiration: String
    "type of the order"
    type: OrderType!
    "client reference for the order"
    reference: String
  ): PreparedSubmitOrder!

  """
  Send a cancel order request to be prepared. Returns a pending order + blob of the transaction to submit.
  The data is verified. The response can be signed and submitted through the submitTransaction mutation.
  """
  prepareOrderCancel(
    "ID of the order to cancel"
    id: ID!
    "ID of the party placing the order"
    partyId: String!
    "ID of the market where to find the order"
    marketId: String!
  ): PreparedCancelOrder!

  """
  Send an amend order request to be prepared. Returns a pending order + blob of the transaction to submit.
  The data is verified. The response can be signed and submitted through the submitTransaction mutation.
  """
  prepareOrderAmend(
    "ID of the order to amend"
    id: ID!
    "ID of the party which created the order"
    partyId: String!
    "New price for this order"
    price: String!
    "New size for this order"
    sizeDelta: String!
    "New expiration time"
    expiration: String
    "Time in force"
    timeInForce: OrderTimeInForce!
  ): PreparedAmendOrder!

  """
  Prepare a proposal so it can be sent into the network.
  Returns a pending proposal along with a transaction blob ready for submission.
  The data is verified. The response can be signed and submitted through the submitTransaction mutation.
  """
  prepareProposal(
    "ID of the party which created this proposal"
    partyId: String!
    "A UUID reference for the caller to aid in tracking operations on VEGA"
    reference: String
    "Terms of the proposal"
    proposalTerms: ProposalTermsInput!
  ): PreparedProposal!

  """
  Prepare a vote so it can be signed and submitted.
  Returns a pending vote with a transaction blob for signing.
  No validation other than the vote value being correct is done.
  """
  prepareVote(
    "vote value"
    value: VoteValue!
    "the party casting the vote"
    partyID: String!
    "the proposal voted on"
    propopsalID: String!
  ): PreparedVote!

  """
  Submit a new, signed, transaction to the VEGA network. This transaction will not be executed immediately.
  It validates the signature, and sends the transaction out for consensus
  """
  submitTransaction(
    "The signed transaction"
    data: String!
    "The signature"
    sig: String!
    "address is one of 2 possible auth values, currently only pubkey is used"
    address: String
    "pubkey is used to verify the signature, currently the only supported one"
    pubkey: String
  ): TransactionSubmitted!

}


"Subscriptions allow a caller to receive new information as it is available from the VEGA platform."
type Subscription {
  "Subscribe to the candles updates"
  candles(
    "ID of the market we want to listen candles for"
    marketId: String!
    "Interval of the candles we want to listen for"
    interval: Interval!
  ): Candle!

  "Subscribe to orders updates"
  orders(
    "ID of the market from which we want orders updates"
    marketId: String
    "ID of the party from which we want orders updates"
    partyId: String
  ): [Order!]

  "Subscribe to the trades updates"
  trades(
    "ID of the market from which we want trades updates"
    marketId: String
    "ID of the party from which we want trades updates"
    partyId: String
  ): [Trade!]

  "Subscribe to the positions updates"
  positions(
    "ID of the party from we want updates for"
    partyId: String!
  ): Position!

  "Subscribe to the market depths update"
  marketDepth(
    "ID of the market we want to receive market depth updates for"
    marketId: String!
  ): MarketDepth!

  "Subscribe to the accounts updates"
  accounts(
    "ID of the market from which we want accounts updates"
    marketId: String
    "ID of the party from which we want accounts updates"
    partyId: String,
    "Asset code"
    asset: String,
    "Type of the account"
    type: AccountType
  ): Account!

  "Subscribe to the mark price changes"
  marketData(
    "id of the market we want to subscribe to the market data changes"
    marketId: String
  ): MarketData!

  "Subscribe to the margin changes"
  margins(
    "id of the trader we want to subscribe for margin updates"
    partyId: String!
    "market we want to listen to margin updates (nil if we want updates for all markets)"
    marketID: String
  ): MarginLevels!

  "Subscribe to proposals. Leave out all arguments to receive all proposals"
  proposals(
    "Optional party id whose proposals are to be streamed"
    partyID: String
  ): Proposal!

  "Subscribe to votes, either by proposal id or pary id"
  votes(
    "Optional proposal id which votes are to be streamed"
    proposalID: String
    "Optional party id whose votes are to be streamed"
    partyID: String
  ): ProposalVote!
}

"Margins for a given a trader"
type MarginLevels {
  "market in which the margin is required for this trader"
  market: Market!
  "asset for the current margins"
  asset: String!
  "id of the trader for this margin"
  party: Party!
  "minimal margin for the position to be maintained in the network (unsigned int actually)"
  maintenanceLevel: String!
  "if the margin is between maintenance and search, the network will initiate a collateral search (unsigned int actually)"
  searchLevel: String!
  "this is the minimal margin required for a trader to place a new order on the network (unsigned int actually)"
  initialLevel: String!

  """
  If the margin of the trader is greater than this level, then collateral will be released from the margin account into
  the general account of the trader for the given asset.
  """
  collateralReleaseLevel: String!

  "time at which these margin level were relevant"
  timestamp: String!
}

"Live data of a Market"
type MarketData {
  "market id of the associated mark price"
  market: Market!
  "the mark price (actually an unsgined int)"
  markPrice: String!
  "the highest price level on an order book for buy orders."
  bestBidPrice: String!
  "the aggregated volume being bid at the best bid price."
  bestBidVolume: String!
  "the lowest price level on an order book for offer orders."
  bestOfferPrice: String!
  "the aggregated volume being offered at the best offer price."
  bestOfferVolume: String!
  "the arithmetic average of the best bid price and best offer price."
  midPrice: String!
  "time at which this mark price was relevant"
  timestamp: String!
}

type PreparedSubmitOrder {
  "blob: the raw transaction to sign & submit"
  blob: String!
}

type PreparedCancelOrder {
  "blob: the raw transaction to sign & submit"
  blob: String!
}

type PreparedAmendOrder {
  "blob: the raw transaction to sign & submit"
  blob: String!
}

type TransactionSubmitted {
  success: Boolean!
}

"Queries allow a caller to read data and filter data via GraphQL."
type Query {

  "One or more instruments that are trading on the VEGA network"
  markets(
    "ID of the market"
    id: String
  ): [Market!]

  "An instrument that is trading on the VEGA network"
  market(
    "Optional ID of a market"
    id: String!
  ): Market

  "One or more entities that are trading on the VEGA network"
  parties(
    "Optional ID of a party"
    id: String
  ): [Party!]

  "An entity that is trading on the VEGA network"
  party(
    "ID of a party"
    id: String!
  ): Party

  "a bunch of statistics about the node"
  statistics: Statistics!

  "An order in the VEGA network found by orderID"
  orderByID(
    "ID for an order"
    orderID: String!

    "version of the order (omitted or 0 for most recent; 1 for original; 2 for first amendment, etc)"
    version: Int
  ): Order!

  "Order versions (created via amendments if any) found by orderID"
  orderVersions(
    "ID for an order"
    orderID: String!

    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Order!]

  "An order in the VEGA network found by referenceID"
  orderByReferenceID(
    "ReferenceID for an order"
    referenceID: String!
  ): Order!

  "All governance proposals in the VEGA network"
  proposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "A governance proposal located by either its id or reference. If both are set, id is used."
  proposal(
    "Optionally, locate proposal by its id"
    id: String
    "Optionally, locate proposal by its reference. If id is set, this parameter is ignored."
    reference: String
  ): Proposal!

  "Governance proposals that aim creating new markets"
  newMarketProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that aim updating existing markets"
  updateMarketProposals(
    "Optionally, select proposals for a specific market. Leave out for all"
    marketId: String
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that aim updating Vega network parameters"
  networkParametersProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]

  "Governance proposals that aim creating new assets in Vega"
  newAssetProposals(
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal!]
}

"Statistics about the node"
type Statistics {
  "Current block number"
  blockHeight: Int!

  "Number of items in the backlog"
  backlogLength: Int!

  "Total number of peers on the vega network"
  totalPeers: Int!

  "Genesis time of the chain"
  genesisTime: String!

  "Current time (real)"
  currentTime: String!

  "Uptime of the node"
  upTime: String!

  "Current time of the chain (decided through consensus)"
  vegaTime: String!

  "Status of the vega application connection with the chain"
  status: String!

  "Number of transaction processed per block"
  txPerBlock: Int!

  "Average size of the transactions"
  averageTxBytes: Int!

  "Average number of orders added per blocks"
  averageOrdersPerBlock: Int!

  "Number of the trades per seconds"
  tradesPerSecond: Int!

  "Number of orders per seconds"
  ordersPerSecond: Int!

  "Total number of markets"
  totalMarkets: Int!

  "Total number of amended orders"
  totalAmendOrder: Int!

  "Total number of cancelled orders"
  totalCancelOrder: Int!

  "Total number of orders created"
  totalCreateOrder: Int!

  "Total number of orders"
  totalOrders: Int!

  "Total number of trades"
  totalTrades: Int!

  "Version commit hash of the vega node"
  appVersionHash: String!

  "Version of the vega node (semver)"
  appVersion: String!

  "Version of the chain (semver)"
  chainVersion: String!

  "Duration of the last block, in nanoseconds"
  blockDuration: Int!

  "Number of orders subscriptions"
  orderSubscriptions: Int!

  "Number of trades subscriptions"
  tradeSubscriptions: Int!

  "Number of candles subscriptions"
  candleSubscriptions: Int!

  "Number of market depth subscriptions"
  marketDepthSubscriptions: Int!

  "Number of positions subscriptions"
  positionsSubscriptions: Int!
}

"A mode where Vega try to execute order as soon as they are received"
type ContinuousTrading {
  "Duration of continuous trading in nanoseconds. Maximum 1 month."
  duration: Int!
  "Size of an increment in price in terms of the quote currency"
  tickSize: Int!
}

"Some non continuous trading mode"
type DiscreteTrading {
  "Duration of continuous trading in nanoseconds. Maximum 1 month."
  duration: Int!
  "Size of an increment in price in terms of the quote currency"
  tickSize: Int!
}

union TradingMode =
ContinuousTrading
| DiscreteTrading

"Parameters for the log normal risk model"
type LogNormalModelParams {
  "mu parameter"
  mu: Float!
  "r parameter"
  r: Float!
  "sigma parameter"
  sigma: Float!
}

"Parameters for the simple risk model"
type SimpleRiskModelParams {
  "Risk factor for long"
  factorLong: Float!
  "Risk factor for short"
  factorShort: Float!
}


"A type of risk model for futures trading"
type LogNormalRiskModel {
  "Lambda parameter of the risk model"
  riskAversionParameter: Float!
  "Tau parameter of the risk model"
  tau: Float!
  "Params for the log normal risk model"
  params: LogNormalModelParams!
}

"A type of simple/dummy risk model where we can specify the risk factor long and short in params"
type SimpleRiskModel {
  "Params for the simple risk model"
  params: SimpleRiskModelParams!
}

union RiskModel = LogNormalRiskModel | SimpleRiskModel

"A set of metadata to associate to an instruments"
type InstrumentMetadata {

  "An arbitrary list of tags to associated to associate to the Instrument (string list)"
  tags: [String]!
}

"An Ethereum oracle"
type EthereumEvent {

  "The ID of the ethereum contract to use (string)"
  contractId: String!

  "Name of the Ethereum event to listen to. (string)"
  event: String!
}

union Oracle = EthereumEvent

"A Future product"
type Future {

  "The maturity date of the product (ISO8601/RFC3339 timestamp)"
  maturity: String!

  "The name of the asset (string)"
  asset: String!

  "The oracle used for this product (Oracle union)"
  oracle: Oracle!
}

union Product = Future

"Describe something that can be traded on Vega"
type Instrument {

  "Uniquely identify an instrument accrods all instruments available on Vega (string)"
  id: String!

  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)"
  code: String!

  "Full and fairly descriptive name for the instrument"
  name: String!

  "String representing the base (e.g. BTCUSD -> BTC is base)"
  baseName: String!

  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!

  "Metadata for this instrument"
  metadata: InstrumentMetadata!

  "A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)"
  product: Product!
}

type MarginCalculator {
  "The scaling factors that will be used for margin calculation"
  scalingFactors: ScalingFactors!
}

type ScalingFactors {
  "the scaling factor that determines the margin level at which we have to search for more money"
  searchLevel: Float!

  "the scaling factor that determines the optimal margin level"
  initialMargin: Float!

  "The scaling factor that determines the overflow margin level"
  collateralRelease: Float!
}

"A tradable instrument is a combination of an instrument and a risk model"
type TradableInstrument {
  "An instance of or reference to a fully specified instrument."
  instrument: Instrument!

  "A reference to a risk model that is valid for the instrument"
  riskModel: RiskModel!

  "Margin calculation info, currently only the scaling factors (search, initial, release) for this tradable instrument"
  marginCalculator: MarginCalculator
}

"Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history"
type Market {

  "Market ID"
  id: String!

	# Market full name
  name: String!

  "An instance of or reference to a tradable instrument."
  tradableInstrument: TradableInstrument!

  "Definitions and required configuration for the trading mode"
  tradingMode: TradingMode!

  """
  decimalPlaces indicates the number of decimal places that an integer must be shifted by in order to get a correct
  number denominated in the currency of the Market. (uint64)

  Examples:
    Currency     Balance  decimalPlaces  Real Balance
    GBP              100              0       GBP 100
    GBP              100              2       GBP   1.00
    GBP              100              4       GBP   0.01
    GBP                1              4       GBP   0.0001   (  0.01p  )

    GBX (pence)      100              0       GBP   1.00     (100p     )
    GBX (pence)      100              2       GBP   0.01     (  1p     )
    GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
    GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
  """
  decimalPlaces: Int!

  "Orders on a market"
  orders (
    "Filter open orders only"
    open: Boolean
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int
  ): [Order!]

  "Get account for a party or market"
  accounts(
    "Id of the party to get the margin account for"
    partyId: String
  ): [Account!]

  "Trades on a market"
  trades (
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Trade!]

  "Current depth on the orderbook for this market"
  depth(
    "Maximum market order book depth (returns whole order book if omitted)"
    maxDepth: Int): MarketDepth!

  "Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params"
  candles (
    "RFC3339Nano encoded time from when to get candles"
    since: String!
    "Interval of the candles"
    interval: Interval!
  ): [Candle]

  "Query an order by reference for the given market"
  orderByReference (
    "reference of the order"
    reference: String!
  ): Order!

  "marketData for the given market"
  data: MarketData!
}

"""
Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
The depth of market measure provides an indication of the liquidity and depth for the instrument.
"""
type MarketDepth {

    "Market id"
    market: Market!

    "Buy side price levels (if available)"
    buy: [PriceLevel!]

    "Sell side price levels (if available)"
    sell: [PriceLevel!]

    "Last trade for the given market (if available)"
    lastTrade: Trade
}

"Represents a price on either the buy or sell side and all the orders at that price"
type PriceLevel {

    "The price of all the orders at this level (uint64)"
    price: String!

    "The total remaining size of all orders at this level (uint64)"
    volume: String!

    "The number of orders at this price level (uint64)"
    numberOfOrders: String!

    "The cumulative total volume to this price level (uint64)"
    cumulativeVolume: String!
}

"Candle stick representation of trading"
type Candle {

    "Unix epoch+nanoseconds for when the candle occurred"
    timestamp: String!

    "ISO-8601 RFC3339+Nano formatted data and time for the candle"
    datetime: String!

    "High price (uint64)"
    high: String!

    "Low price (uint64)"
    low: String!

    "Open price (uint64)"
    open: String!

    "Close price (uint64)"
    close: String!

    "Volume price (uint64)"
    volume: String!

    "Interval price (string)"
    interval: Interval!
}

"Represents a party on Vega, could be an ethereum wallet address in the future"
type Party {
  "Party identifier"
  id: String!

  "Orders relating to a party"
  orders(
    "Is the order still open or not"
    open: Boolean
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Order!]

  "Trades relating to a party (specifically where party is either buyer OR seller)"
  trades(
    "ID of the market we want to get trades for"
    marketId: String
    "Pagination skip"
    skip: Int
    "Pagination first element"
    first: Int
    "Pagination last element"
    last: Int): [Trade!]

  "Collateral accounts relating to a party"
  accounts(
    "Market ID - specify what market accounts for the party to return"
    marketId: String
    "Asset (USD, EUR etc)"
    asset: String,
    "Filter accounts by type (General account, margin account, etc...)"
    type: AccountType
  ): [Account!]

  "Trading positions relating to a party"
  positions: [Position!]

  "marginLevels"
  margins(
    "market id off the margin to get, nil if all markets"
    marketId: String,
  ): [MarginLevels!]

  proposals(
    "Select only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
  ): [Proposal]

  votes: [ProposalVote]
}

"""
An individual trader at any point in time is considered net long or net short. This refers to their Open Volume,
calculated using FIFO. This volume is signed as either negative for LONG positions and positive for SHORT positions. A
single trade may end up "splitting" with some of its volume matched into closed volume and some of its volume
remaining as open volume. This is why we don't refer to positions being comprised of trades, rather of volume.
"""
type Position {

  "Market relating to this position"
  market: Market!

  "Open volume (uint64)"
  openVolume: String!

  "Realised Profit and Loss (int64)"
  realisedPNL: String!

  "Unrealised Profit and Loss (int64)"
  unrealisedPNL: String!

  "Average entry price for this position"
  averageEntryPrice: String!

  "margins of the party for the given position"
  margins: [MarginLevels!]
}

"An order in Vega, if active it will be on the OrderBoook for the market"
type Order {

  "Hash of the order data"
  id: ID!

  "The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)"
  price: String!

  "The timeInForce of order (determines how and if it executes, and whether it persists on the book)"
  timeInForce: OrderTimeInForce!

  "Whether the order is to buy or sell"
  side: Side!

  "The market the order is trading on (probably stored internally as a hash of the market details)"
  market: Market!

  "Total number of contracts that may be bought or sold (immutable) (uint64)"
  size: String!

  "Number of contracts remaining of the total that have not yet been bought or sold (uint64)"
  remaining: String!

  "The trader who place the order (probably stored internally as the trader's public key)"
  party: Party!

  "ISO-8601 RFC3339+Nano formatted date and time for when the order was created (timestamp)"
  createdAt: String!

  "Expiration time of this order (ISO-8601 RFC3339+Nano formatted date)"
  expiresAt: String

  "The status of an order, for example 'Active'"
  status: OrderStatus!

  "The external reference (if available) for the order"
  reference: String!

  "Trades relating to this order"
  trades: [Trade!]

  "Type the order type (defaults to TRADER)"
  type: OrderType

  "Reason for the order to be rejected"
  rejectionReason: RejectionReason
}

"A trade on Vega, the result of two orders being 'matched' in the market"
type Trade {

  "The hash of the trade data"
  id: ID!

  "The market the trade occurred on"
  market: Market!

  "The order that bought"
  buyOrder: String!

  "The order that sold"
  sellOrder: String!

  "The party that bought"
  buyer: Party!

  "The party that sold"
  seller: Party!

  "The aggressor indicates whether this trade was related to a BUY or SELL"
  aggressor: Side!

  "The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)"
  price: String!

  "The number of contracts trades, will always be <= the remaining size of both orders immediately before the trade (uint64)"
  size: String!

  "RFC3339Nano for when the trade occurred"
  createdAt: String!

  "The type of trade"
  type: TradeType!
}

"Valid trade types"
enum TradeType {

  "Default trade type"
  Default

  "Network close-out - good"
  NetworkCloseOutGood

  "Network close-out - bad"
  NetworkCloseOutBad
}

"An account record"
type Account {
  "Balance as string - current account balance (approx. as balances can be updated several times per second)"
  balance: String!
  "Asset, the 'currency'"
  asset: String!
  "Account type (General, Margin, etc)"
  type: AccountType!
  "Market (only relevant to margin accounts)"
  market: Market
}

"Valid order types, these determine what happens when an order is added to the book"
enum OrderTimeInForce {

    "The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade"
    FOK

    "The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)"
    IOC

    "This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled"
    GTC

    """
    This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
    NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
    """
    GTT
}

"Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order."
enum OrderStatus {

  """
  The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
  Active does not necessarily mean it's still on the order book.
  """
  Active

  "This order trades any amount and as much as possible and remains on the book until it either trades completely or expires."
  Expired

  "The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining."
  Cancelled

  "This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity."
  Stopped

  "This order is fully filled with remaining equals zero."
  Filled

  "This order was rejected while beeing processed in the core."
  Rejected

  "This order was partially filled."
  PartiallyFilled
}

"Reason for the order beeing rejected by the core node"
enum RejectionReason {

  "Market id is invalid"
  InvalidMarketId

  "Order id is invalid"
  InvalidOrderId

  "Order is out of sequence"
  OrderOutOfSequence

  "Remaining size in the order is invalid"
  InvalidRemainingSize

  "Time has failed us"
  TimeFailure

  "Unable to remove the order"
  OrderRemovalFailure

  "Expiration time is invalid"
  InvalidExpirationTime

  "Order reference is invalid"
  InvalidOrderReference

  "Edit is not allowed"
  EditNotAllowed

  "Order amend fail"
  OrderAmendFailure

  "Order does not exist"
  OrderNotFound

  "Party id is invalid"
  InvalidPartyId

  "Market is closed"
  MarketClosed

  "Margin check failed"
  MarginCheckFailed

  "Order missing general account"
  MissingGeneralAccount

  "An internal error happend"
  InternalError

  "Invalid size"
  InvalidSize

  "Invalid persistence"
  InvalidPersistence

  "Invalid type"
  InvalidType
}

enum OrderType {
  "the default order type"
  MARKET

  "mentioned in ticket, but as yet unused order type"
  LIMIT

  """
  Used for distressed traders, an order placed by the network to close out distressed traders
  similar to MARKET order, only no party is attached to the order.
  """
  NETWORK
}

"Whether the placer of an order is aiming to buy or sell on the market"
enum Side {
  "The Placer of the order is aiming to buy"
  Buy

  "The placer of the order is aiming to sell"
  Sell
}

"The interval for trade candles when subscribing via VEGA graphql, default is I15M"
enum Interval {
  "1 minute interval"
  I1M

  "5 minute interval"
  I5M

  "15 minute interval (default)"
  I15M

  "1 hour interval"
  I1H

  "6 hour interval"
  I6H

  "1 day interval"
  I1D
}

"The various account types we have (used by collateral)"
enum AccountType {
  "Insurance pool account - only for 'system' party"
  Insurance
  "Settlement - only for 'system' party"
  Settlement
  "Margin - The leverage account for traders"
  Margin
  "General account - the account containing 'unused' collateral for traders"
  General
}

"Predefined risk models"
enum RiskModelType {
  "Simple risk model"
  Simple
  "Log normal risk model"
  LogNormal
}

input SimpleRiskModelParamsInput {
  "Risk factor for long"
  factorLong: Float!
  "Risk factor for short"
  factorShort: Float!
}

input LogNormalModelParamsInput {
  "mu parameter"
  mu: Float!
  "r parameter"
  r: Float!
  "sigma parameter"
  sigma: Float!
}

input LogNormalRiskModelInput {
  "Lambda parameter of the risk model"
  riskAversionParameter: Float!
  "Tau parameter of the risk model"
  tau: Float!
  "Params for the log normal risk model"
  params: LogNormalModelParamsInput!
}

input RiskInput {
  model: RiskModelType!
  "Simple risk model parameters. Set only if risk model is Simple"
  simpleParameters: SimpleRiskModelParamsInput
  "Log normal risk model parameters. Set only if risk model is LogNormal"
  logNormalParameters: LogNormalRiskModelInput
}

type Risk {
  model: RiskModelType!
  "Simple risk model parameters. Set only if risk model is Simple"
  simpleParameters: SimpleRiskModelParams
  "Log normal risk model parameters. Set only if risk model is LogNormal"
  logNormalParameters: LogNormalRiskModel
}

"Future product configuration"
input FutureProductInput {
  "Future product maturity (ISO8601/RFC3339 timestamp)"
  maturity: String!
  "Product asset name"
  asset: String!
}

type FutureProduct {
  "Future product maturity (ISO8601/RFC3339 timestamp)"
  maturity: String!
  "Product asset name"
  asset: String!
}

input IntrumentConfigurationInput {
  "Full and fairly descriptive name for the instrument"
  name: String!
  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)"
  code: String!
  "String representing the base (e.g. BTCUSD -> BTC is base)"
  baseName: String!
  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!
  "Future product specification"
  futureProduct: FutureProductInput
}

type IntrumentConfiguration {
  "Full and fairly descriptive name for the instrument"
  name: String!
  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)"
  code: String!
  "String representing the base (e.g. BTCUSD -> BTC is base)"
  baseName: String!
  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!
  "Future product specification"
  futureProduct: FutureProduct
}

enum TradingModeType {
  Continuous
  Discrete
}

input TradingModeInput {
  mode: TradingModeType!
  "Duration of continuous trading in nanoseconds. Maximum 1 month."
  duration: Int!
  "Size of an increment in price in terms of the quote currency"
  tickSize: Int!
}

"""
Allows creating new markets on the network
"""
input NewMarketInput {
  "New market instrument configuration"
  instrument: IntrumentConfigurationInput!
  "Decimal places used for the new market"
  decimalPlaces: Int!
  "New market risk configuration"
  risk: RiskInput!
  "Metadata for this instrument, tags"
  metadata: [String]!
  "Trading mode"
  tradingMode: TradingModeInput!
}

type NewMarket {
  "New market instrument configuration"
  instrument: IntrumentConfiguration!
  "Decimal places used for the new market"
  decimalPlaces: Int!
  "New market risk configuration"
  risk: Risk!
  "Metadata for this instrument, tags"
  metadata: [String]!
  "Trading mode"
  tradingMode: TradingMode!
}

"""
Incomplete change definition for governance proposal terms
TODO: complete the type
"""
type UpdateMarket {
  marketId: String!
}
input UpdateMarketInput {
  marketId: String!
}


"Allows submitting a proposal for changing governance network parameters"
type UpdateNetwork {
  """
  Network parameter that restricts when the earliest a proposal
  can be set to close voting. Value represents duration in seconds.
  """
  minCloseInSeconds: Int
  """
  Network parameter that restricts when the latest a proposal
  can be set to close voting. Value represents duration in seconds.
  """
  maxCloseInSeconds: Int
  """
  Network parameter that restricts when the earliest a proposal
  can be set to be executed (if that proposal passed).
  Value represents duration in seconds.
  """
  minEnactInSeconds: Int
  """
  Network parameter that restricts when the latest a proposal
  can be set to be executed (if that proposal passed).
  Value represents duration in seconds.
  """
  maxEnactInSeconds: Int

  """
  Network parameter that sets participation level required for any proposal to pass.
  Value from 0 to 1.
  """
  requiredParticipation: Float
  """
  Network parameter that sets majority level required for any proposal to pass.
  Value from 0.5 to 1.
  """
  requiredMajority: Float

  """
  Network parameter that sets minimum balance required for a party
  to be able to submit a new proposal. Value greater than 0 to 1.
  """
  minProposerBalance: Float

  """
  Network parameter that sets minimum balance required for a party
  to be able to cast a vote.  Value greater than 0 to 1.
  """
  minVoterBalance: Float
}

"Allows submitting a proposal for changing governance network parameters"
input UpdateNetworkInput {
  """
  Network parameter that restricts when the earliest a proposal
  can be set to close voting. Value represents duration in seconds.
  """
  minCloseInSeconds: Int
  """
  Network parameter that restricts when the latest a proposal
  can be set to close voting. Value represents duration in seconds.
  """
  maxCloseInSeconds: Int
  """
  Network parameter that restricts when the earliest a proposal
  can be set to be executed (if that proposal passed).
  Value represents duration in seconds.
  """
  minEnactInSeconds: Int
  """
  Network parameter that restricts when the latest a proposal
  can be set to be executed (if that proposal passed).
  Value represents duration in seconds.
  """
  maxEnactInSeconds: Int

  """
  Network parameter that sets participation level required for any proposal to pass.
  Value from 0 to 1.
  """
  requiredParticipation: Float
  """
  Network parameter that sets majority level required for any proposal to pass.
  Value from 0.5 to 1.
  """
  requiredMajority: Float

  """
  Network parameter that sets minimum balance required for a party
  to be able to submit a new proposal. Value greater than 0 to 1.
  """
  minProposerBalance: Float

  """
  Network parameter that sets minimum balance required for a party
  to be able to cast a vote.  Value greater than 0 to 1.
  """
  minVoterBalance: Float
}


union ProposalChange = NewMarket | UpdateMarket | UpdateNetwork
# there are no unions for input types as of today, see: https://github.com/graphql/graphql-spec/issues/488

type ProposalTerms {
  """
  ISO-8601 time and date when voting closes for this proposal.
  Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
  """
  closingDatetime: String!
  """
  ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
  Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
  """
  enactmentDatetime: String!

  "Actual change being introduced by the proposal - action the proposal triggers if passed and enacted."
  change: ProposalChange!
}

# there are no unions for input types as of today, see: https://github.com/graphql/graphql-spec/issues/488
"Proposal terms input. Only one kind of change is expected. Proposals with no changes or more than one will not be accepted."
input ProposalTermsInput {
  """
  ISO-8601 time and date when voting closes for this proposal.
  Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
  """
  closingDatetime: String!
  """
  ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
  Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
  """
  enactmentDatetime: String!


  """
  Field defining new market change - the proposal will create new market if passed and enacted.
  It can only be set if "updateMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
  One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
  """
  newMarket: NewMarketInput
  """
  Field defining update market change - the proposal will update existing market if passed and enacted.
  It can only be set if "newMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
  One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
  """
  updateMarket: UpdateMarketInput

  """
  Field defining update network change - the proposal will update Vega network parameters if passed and enacted.
  It can only be set if "newMarket" and "updateMarket" are not set (the proposal will be rejected otherwise).
  One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
  """
  updateNetwork: UpdateNetworkInput
}

"""
Varoius states a proposal can transition through:
  Open ->
      - Passed -> Enacted.
      - Rejected.
  Proposal can enter Failed state from any other state.
"""
enum ProposalState {
  "Proposal became invalid and cannot be processed"
  Failed
  "Proposal is open for voting"
  Open
  "Proposal has gained enough support to be executed"
  Passed
  "Proposal didn't get enough votes"
  Declined
  "Proposal has could not gain enough support to be executed"
  Rejected
  "Proposal has been executed and the changes under this proposal have now been applied"
  Enacted
}

type Proposal {
  "Proposal id that is filled by VEGA once proposal reaches the network"
  id: ID
  "A UUID reference to aid tracking proposals on VEGA"
  reference: String!
  "Party that prepared the proposal"
  party: Party!
  "State of the proposal"
  state: ProposalState!
  "ISO-8601 time and date when the proposal reached Vega network"
  datetime: String!
  "Terms of the proposal"
  terms: ProposalTerms!

  "Yes votes cast for this proposal"
  yesVotes: [Vote]
  "No votes cast for this proposal"
  noVotes: [Vote]
}

type PreparedProposal {
  "Raw transaction data to sign & submit"
  blob: String!
  "The pending proposal"
  pendingProposal: Proposal!
}

enum VoteValue {
  "NO reject a proposal"
  NO
  "YES accept a proposal"
  YES
}

type Vote {
  "The vote value cast"
  value: VoteValue!

  "The party casting the vote"
  party: Party!

  "ISO-8601 time and date when the vote reached Vega network"
  datetime: String!
}

type ProposalVote {
  "Cast vote"
  vote: Vote!

  "Proposal casting the vote on"
  proposalID: ID!
}

type PreparedVote {
  "Raw, serialised vote to be signed"
  blob: String!
  "The vote serialised in the blob field"
  vote: ProposalVote!
}
