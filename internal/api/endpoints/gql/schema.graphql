## VEGA - GraphQL schema

# Represents a date/time
scalar DateTime

schema {
    query: Query,
    subscription: Subscription,
    mutation: Mutation
}

# Mutations are similar to GraphQL queries, however they allow a caller to change or mutate data.
type Mutation {

    # Send a create order request into VEGA network, this does not immediately create the order.
    # It validates and sends the request out for consensus. Price, expiration and size will be converted to uint64 internally.
    orderCreate(market: String!, party: String!, price: String!, size: String!, side: Side!, type: OrderType!, expiration: String): PendingOrder!

    # Send a cancel order request into VEGA network, this does not immediately cancel an order.
    # It validates and sends the request out for consensus.
    orderCancel(id: ID!, market: String!, party: String!): PendingOrder!
}

# Subscriptions allow a caller to receive new information as it is available from the VEGA platform.
type Subscription {
    candles(market: String!, interval: Interval!): Candle!
    orders(market: String, party: String): [Order!]
    trades(market: String, party: String): [Trade!]
    positions(party: String!): Position!
    marketDepth(market: String!): MarketDepth!
}

# An operation that is run before passing on to consensus, e.g. cancelling an order, will report whether it was accepted.
type PendingOrder {

  # The id of the Order, can be null if the request was SubmitOrder
  id: String

  # A UUID reference for the caller to aid in tracking operations on VEGA
  reference: String!

  # The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)
  price: String

  # The type of order (determines how and if it executes, and whether it persists on the book)
  type: OrderType

  # Whether the order is to buy or sell
  side: Side

  # The market the order is trading on (probably stored internally as a hash of the market details)
  # could be nil if the submit order failed an no order is getting created
  market: Market

  # Total number of contracts that may be bought or sold (immutable) (uint64)
  size: String

  # The trader who place the order (probably stored internally as the trader's public key)
  party: String

  # The status of an order, for example 'Active'
  status: OrderStatus
}

# Queries allow a caller to read data and filter data via GraphQL.
type Query {

    # One or more instruments that are trading on the VEGA network
    markets(name: String): [Market!]

    # An instrument that is trading on the VEGA network
    market(name: String!): Market

    # One or more entities that are trading on the VEGA network
    parties(name: String): [Party!]

    # An entity that is trading on the VEGA network
    party(name: String!): Party
}

# A mode where Vega try to execute order as soon as they are received
type ContinuousTrading {
  # Size of an increment in price in terms of the quote currency (uint64)
  tickSize: Int
}

# Some non continuous trading mode
type DiscreteTrading {
  # Duration of the trading (uint64)
  duration: Int
}

union TradingMode =
ContinuousTrading
| DiscreteTrading

type BuiltinFutures {
  # The historic volatily of the future (float64)
  historicVolatility: Float!
}

union RiskModel = BuiltinFutures

# A set of metadat to associate to an instruments
type InstrumentMetadata {

  # An arbitrary list of tags to associated to associate to the Instrument (string list)
  tags: [String]!
}

# An Ethereum oracle
type EthereumEvent {

  # The ID of the ethereum contract to use (string)
  contractId: String!

  # Name of the Ethereum event to listen to. (string)
  event: String!
}

union Oracle = EthereumEvent

# A Future product
type Future {

  # The maturity date of the product (string)
  maturity: String!

  # The name of the asset (string)
  asset: String!

  # The oracle used for this product (Oracle union)
  oracle: Oracle!
}

union Product = Future

# Describe something that can be traded on Vega
type Instrument {

  # Uniquely identify an instrument accrods all instruments available on Vega (string)
  id: String!

  # A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)
  code: String!

  # Full and fairly descriptive name for the instrument
  name: String!

  # Metadata for this instrument
  metadata: InstrumentMetadata!

  # A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)
  product: Product!
}

# A tradable instrument is a combination of an instrument and a risk model
type TradableInstrument {
  # An instance of or reference to a fully specified instrument.
  instrument: Instrument!

  # A reference to a risk model that is valid for the instrument
  riskModel: RiskModel!
}

# Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market {

  # Market full name
  id: String!

  # An instance of or reference to a tradable instrument.
  tradableInstrument: TradableInstrument!

  # Definitions and required configuration for the trading mode
  tradingMode: TradingMode!

  #  number of decimals places for price quotes, e.g. if quote currency is USD and decimal places is 2 then prices are quoted in integer numbers of cents. (uint64)
  decimalPlaces: Int!

  # Orders on a market
  orders (open: Boolean, skip: Int, first: Int, last: Int): [Order!]

  # Trades on a market
  trades (skip: Int, first: Int, last: Int): [Trade!]

  # Current depth on the orderbook for this market
  depth: MarketDepth!

  # Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params
  candles (sinceTimestamp: String!, interval: Interval!): [Candle]
}

# Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
# The depth of market measure provides an indication of the liquidity and depth for the instrument.
type MarketDepth {

    # Market id
    name: String!

    # Buy side price levels (if available)
    buy: [PriceLevel!]

    # Sell side price levels (if available)
    sell: [PriceLevel!]

    # Last trade for the given market (if availabe)
    lastTrade: Trade
}

# Represents a price on either the buy or sell side and all the orders at that price
type PriceLevel {

    # The price of all the orders at this level (uint64)
    price: String!

    # The total remaining size of all orders at this level (uint64)
    volume: String!

    # The number of orders at this price level (uint64)
    numberOfOrders: String!

    # The cumulative total volume to this price level (uint64)
    cumulativeVolume: String!
}

# Candle stick representation of trading
type Candle {

    # Unix epoch+nanoseconds for when the candle ocurred
    timestamp: String!

    # ISO-8601 RFC3339+Nano formatted data and time for the candle
    datetime: String!

    # High price (uint64)
    high: String!

    # Low price (uint64)
    low: String!

    # Open price (uint64)
    open: String!

    # Close price (uint64)
    close: String!

    # Volume price (uint64)
    volume: String!

    # Interval price (string)
    interval: Interval!
}

# Represents a party on Vega, could be an ethereum wallet address in the future
type Party {
    # Party identifier
    name: String!

    # Orders relating to a party
    orders(open: Boolean, skip: Int, first: Int, last: Int): [Order!]

    # Trades relating to a party (specifically where party is either buyer OR seller)
    trades(market: String, skip: Int, first: Int, last: Int): [Trade!]

    # Trading positions relating to a party
    positions: [Position!]
}

# An individual trader at any point in time is considered net long or net short.
# This refers to their Open Volume, calculated using FIFO. This volume should now be signed as either
# negative for LONG positions and positive for SHORT positions. A single trade may end up "splitting" with some
# of its volume matched into closed volume and some of its volume remaining as open volume. This is why we don't
# refer to positions being comprised of trades, rather of volume.
type Position {

    # Market relating to this position
    market: Market!

    # Realised volume (uint64)
    realisedVolume: String!

    # Realised Profit and Loss (int64, will be converted to uint64 with +ve/-ve indicator in future)
    realisedProfitValue: String!

    # Realised Profit or Loss direction
    realisedProfitDirection: ValueDirection!

    # Unrealised volume (uint64)
    unrealisedVolume: String!

    # Unrealised Profit and Loss  (int64, will be converted to uint64 with +ve/-ve indicator in future)
    unrealisedProfitValue: String!

    # Unrealised Profit or Loss direction
    unrealisedProfitDirection: ValueDirection!

    # Average entry price for this position
    averageEntryPrice: String!

    # Minimum margin for this position
    minimumMargin: String!
}

# An order in Vega, if active it will be on the OrderBoook for the market
type Order {

  # Hash of the order data
  id: ID!

  # The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)
  price: String!

  # The type of order (determines how and if it executes, and whether it persists on the book)
  type: OrderType!

  # Whether the order is to buy or sell
  side: Side!

  # The market the order is trading on (probably stored internally as a hash of the market details)
  market: Market!

  # Total number of contracts that may be bought or sold (immutable) (uint64)
  size: String!

  # Number of contracts remaining of the total that have not yet been bought or sold (uint64)
  remaining: String!

  # The trader who place the order (probably stored internally as the trader's public key)
  party: String!

  # Unix epoch+nanoseconds for when the order was created
  timestamp: String! @deprecated(reason: "This field is being replaced by createdAt in the near future")

  # ISO-8601 RFC3339+Nano formatted date and time for when the order was created (timestamp)
  datetime: String! @deprecated(reason: "This field is being replaced by createdAt in the near future")

  # ISO-8601 RFC3339+Nano formatted date and time for when the order was created (timestamp)
  createdAt: String!

  # Expiration time of this order (ISO-8601 RFC3339+Nano formatted date)
  expiresAt: String

  # The status of an order, for example 'Active'
  status: OrderStatus!

  # The external reference (if available) for the order
  reference: String!

  # Trades relating to this order
  trades: [Trade]
}

# A trade on Vega, the result of two orders being "matched" in the market
type Trade {

  # The hash of the trade data
  id: ID!

  # The market the trade occurred on
  market: Market!

  # The order that bought
  buyer: String!

  # The order that sold
  seller: String!

  # The aggressor indicates whether this trade was related to a BUY or SELL
  aggressor: Side!

  # The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)
  price: String!

  # The number of contracts trades, will always be <= the remaining size of both orders immediately before the trade (uint64)
  size: String!

  # Unix epoch+nanoseconds for when the trade occured
  timestamp: String! @deprecated(reason: "This field is being replaced by createdAt in the near future")

  # ISO-8601 RFC3339+Nano formatted data and time for when the trade occured (timestamp)
  datetime: String! @deprecated(reason: "This field is being replaced by createdAt in the near future")

  # RFC3339Nano for when th trade occured
  createdAt: String!
}

# Valid order types, these determine what happens when an order is added to the book
enum OrderType {

    # The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
    FOK,

    # The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
    ENE,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
    GTC,

    # This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
    # NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
    GTT,
}

# Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
enum OrderStatus {

    # The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
    # Active does not necessarily mean it's still on the order book.
    Active,

    # The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
    Cancelled,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
    Expired,

    # This order was of type ENE or FOK and could not be processed by the matching engine due to lack of liquidity.
    Stopped,

    # This order is fully filled with remaining equals zero.
    Filled,
}

# Whether the placer of an order is aiming to buy or sell on the market
enum Side {
    Buy
    Sell
}

# Whether the position etc value is in profit (positive) or loss (negative).
enum ValueDirection {
    Positive
    Negative
}

# Filters for Trade queries on VEGA graphql, typically specified by WHERE clause
input TradeFilter {
    # logical operators
    AND: [TradeFilter!] # combines all passed `TradeFilter` objects with logical AND
    OR: [TradeFilter!] # combines all passed `TradeFilter` objects with logical OR

    # ID filters
    id: ID # matches all trades with exact ID value
    id_neq: ID # matches all trades with different ID to value

    # Market filters
    market: String # matches all trades with exact market value
    market_neq: String # matches all trades with different market to value

    # Buyer filters
    buyer: String # matches all trades with exact buyer value
    buyer_neq: String # matches all trades with different buyer to value

    # Buyer filters
    seller: String # matches all trades with exact seller value
    seller_neq: String # matches all trades with different seller to value

    # Aggressor filters
    aggressor: Side # matches all trades with exact aggressor value e.g. Buy
    aggressor_neq: Side # matches all trades with different aggressor to value

    # Price filters
    price: String # matches all trades with exact price value
    price_neq: String # matches all trades with different price to value
    price_from: String # matches all trades from this price value
    price_to: String # matches all trades to this price value

    # Size filters
    size: String # matches all trades with exact size value
    size_neq: String # matches all trades with different size to value
    size_from: String # matches all trades from this size value
    size_to: String # matches all trades to this size value

    # TimeStamp filters
    timestamp: String # matches all trades with exact timestamp value
    timestamp_neq: String # matches all trades with different timestamp to value
    timestamp_from: String # matches all trades from this timestamp value
    timestamp_to: String # matches all trades to this timestamp value
}

# Filters for Order queries on VEGA graphql, typically specified by WHERE clause
input OrderFilter {
    # logical operators
    AND: [OrderFilter!] # combines all passed `OrderFilter` objects with logical AND
    OR: [OrderFilter!] # combines all passed `OrderFilter` objects with logical OR

    # Open only filter
    open: Boolean # Include only open orders in results (default: False)

    # ID filters
    id: ID # matches all orders with exact ID value
    id_neq: ID # matches all orders with different ID to value

    # Market filters
    market: String # matches all orders with exact market value
    market_neq: String # matches all orders with different market to value

    # Party filters
    party: String # matches all orders with exact party value
    party_neq: String # matches all orders with different party to value

    # Side filters
    side: Side # matches all orders with exact side value e.g. Buy
    side_neq: Side # matches all orders with different side to value

    # Price filters
    price: String # matches all orders with exact price value
    price_neq: String # matches all orders with different price to value
    price_from: String # matches all orders from this price value
    price_to: String # matches all orders to this price value

    # Size filters
    size: String # matches all orders with exact size value
    size_neq: String # matches all orders with different size to value
    size_from: String # matches all orders from this size value
    size_to: String # matches all orders to this size value

    # Remaining filters
    remaining: String # matches all orders with exact remaining value
    remaining_neq: String # matches all orders with different remaining to value
    remaining_from: String # matches all orders from this remaining value
    remaining_to: String # matches all orders to this remaining value

    # Type filters
    type: OrderType # matches all orders with exact type value
    type_neq: OrderType # matches all orders with different type to value

    # Timestamp filters
    timestamp: String # matches all orders with exact timestamp value
    timestamp_neq: String # matches all orders with different timestamp to value
    timestamp_from: String # matches all orders from this timestamp value
    timestamp_to: String # matches all orders to this timestamp value

    # Status filters
    status: OrderStatus # matches all orders with exact status value
    status_neq: OrderStatus # matches all orders with different status to value
}

# The interval for trade candles when subscribing via VEGA graphql, default is I15M
enum Interval {
    I1M # 1 minute interval
    I5M # 5 minute interval
    I15M # 15 minute interval (default)
    I1H # 1 hour interval
    I6H # 6 hour interval
    I1D # 1 day interval
}
