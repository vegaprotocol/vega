## VEGA - GraphQL schema

# Represents a date/time
scalar DateTime

schema {
    query: Query,
    subscription: Subscription,
    mutation: Mutation
}

# Mutations are similar to GraphQL queries, however they allow a caller to change or mutate data.
type Mutation {
    
    # Send a create order request into VEGA network, this does not immediately create the order.
    # It validates and sends the request out for consensus. Price and Size will be converted to uint64 internally.
    orderCreate(market: String!, party: String!, price: String!, size: String!, side: Side!, type: OrderType!): PreConsensus!

    # Send a cancel order request into VEGA network, this does not immediately cancel an order.
    # It validates and sends the request out for consensus.
    orderCancel(id: ID!, market: String!, party: String!): PreConsensus!
}

# Queries allow a caller to read data and filter data via GraphQL.
type Query {
    # Int64 not yet supported, strings are returned and will need to be handled by clients:
    # https://github.com/graphql-go/graphql/issues/257
    
    # VEGA root query
    vega: Vega!
}

# Subscriptions allow a caller to receive new information as it is available from the VEGA platform.
type Subscription {
    candles(market: String!, interval: Int!): Candle!
    orders(market: String, party: String): [Order!]
    trades(market: String, party: String): [Trade!]
    positions(party: String!): Position!
    marketDepth(market: String!): MarketDepth!
}

# An operation that is run before passing on to consensus, e.g. cancelling an order, will report whether it was accepted.
type PreConsensus {

    # If true then the operation was validated and passed on for consensus with other nodes on the VEGA platform.
    accepted: Boolean!

    # A UUID reference for the caller to aid in tracking operations on VEGA
    reference: String!
}

# VEGA the world's premier distributed derivatives trading platform
type Vega {
    
    # An instrument that is trading on the VEGA network
    markets(name: String): [Market!]

    # An entity that is trading on the VEGA network
    parties(name: String): [Party!]
}

# Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market {
    
    # Market full name
    name: String!

    # Orders on a market
    orders (where: OrderFilter, skip: Int, first: Int, last: Int): [Order!]

    # Trades on a market
    trades (where: TradeFilter, skip: Int, first: Int, last: Int): [Trade!]

    # Current depth on the orderbook for this market
    depth: MarketDepth!

    # Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params
    candles (last: Int!, interval: Int!): [Candle!]
}

# Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
# The depth of market measure provides an indication of the liquidity and depth for the instrument.
type MarketDepth {

    # Market name
    name: String!

    # Buy side price levels (if available)
    buy: [PriceLevel!]
    
    # Sell side price levels (if available)
    sell: [PriceLevel!]

    # Last trade for the given market (if availabe)
    lastTrade: Trade
}

# Represents a price on either the buy or sell side and all the orders at that price
type PriceLevel {

    # The price of all the orders at this level (uint64)
    price: String!

    # The total remaining size of all orders at this level (uint64)
    volume: String!

    # The number of orders at this price level (uint64)
    numberOfOrders: String!

    # The cumulative total volume to this price level (uint64)
    cumulativeVolume: String!
}

# Candle stick representation of trading
type Candle {

    # The date and time for the candlestick
    date: DateTime!

    # High price (uint64)
    high: String!

    # Low price (uint64)
    low: String!

    # Open price (uint64)
    open: String!

    # Close price (uint64)
    close: String!

    # Volume price (uint64)
    volume: String!

    # The block number of the opening trade (uint64)
    openBlockNumber: String!

    # The block number of the closing trade (uint64)
    closeBlockNumber: String!
}

# Represents a party on Vega, could be an ethereum wallet address in the future
type Party {
    # Party identifier
    name: String!

    # Orders relating to a party
    orders(where: OrderFilter, skip: Int, first: Int, last: Int): [Order!]

    # Trading positions relating to a party
    positions: [Position!]
}

# An individual trader at any point in time is considered net long or net short.
# This refers to their Open Volume, calculated using FIFO. This volume should now be signed as either
# negative for LONG positions and positive for SHORT positions. A single trade may end up "splitting" with some
# of its volume matched into closed volume and some of its volume remaining as open volume. This is why we don't
# refer to positions being comprised of trades, rather of volume.
type Position {

    # Market relating to this position
    market: Market!

    # Realised volume (uint64)
    realisedVolume: String!

    # Realised Profit and Loss (int64, will be converted to uint64 with +ve/-ve indicator in future)
    realisedProfitValue: String!

    # Realised Profit or Loss direction
    realisedProfitDirection: ValueDirection!

    # Unrealised volume (uint64)
    unrealisedVolume: String!

    # Unrealised Profit and Loss  (int64, will be converted to uint64 with +ve/-ve indicator in future)
    unrealisedProfitValue: String!

    # Unrealised Profit or Loss direction
    unrealisedProfitDirection: ValueDirection!

    # Average entry price for this position
    averageEntryPrice: String!

    # Minimum margin for this position
    minimumMargin: String!
}

# An order in Vega, if active it will be on the OrderBoook for the market
type Order {

    # Hash of the order data
    id: ID!

    # The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)
    price: String!

    # The type of order (determines how and if it executes, and whether it persists on the book)
    type: OrderType!

    # Whether the order is to buy or sell
    side: Side!

    # The market the order is trading on (probably stored internally as a hash of the market details)
    market: Market!

    # Total number of contracts that may be bought or sold (immutable) (uint64)
    size: String!

    # Number of contracts remaining of the total that have not yet been bought or sold (uint64)
    remaining: String!

    # The trader who place the order (probably stored internally as the trader's public key)
    party: String!

    # If the order was added to the book or uncrossed at any point, the timestamp when that was done
    timestamp: String!

    # The status of an order, for example 'Active'
    status: OrderStatus!
}

# A trade on Vega, the result of two orders being "matched" in the market
type Trade {

    # The hash of the trade data
    id: ID!

    # The market the trade occurred on
    market: Market!

    # The order that bought
    buyer: String!

    # The order that sold
    seller: String!

    # The aggressor indicates whether this trade was related to a BUY or SELL
    aggressor: Side!

    # The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)
    price: String!

    # The number of contracts trades, will always be <= the remaining size of both orders immediately before the trade (uint64)
    size: String!

    # When the trade occured, probably the timestamp of the agressive order
    timestamp: String!
}

# Valid order types, these determine what happens when an order is added to the book
enum OrderType {

    # The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
    FOK,

    # The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
    ENE,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
    GTC,

    # This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
    # NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
    GTT,
}

# Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
enum OrderStatus {

    # The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
    # Active does not necessarily mean it's still on the order book.
    Active,

    # The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
    Cancelled,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
    Expired,

    # This order was of type ENE or FOK and could not be processed by the matching engine due to lack of liquidity.
    Stopped,

    # This order is fully filled with remaining equals zero.
    Filled,
}

# Whether the placer of an order is aiming to buy or sell on the market
enum Side {
    Buy
    Sell
}

# Whether the position etc value is in profit (positive) or loss (negative).
enum ValueDirection {
    Positive
    Negative
}

# Filters for Trade queries on VEGA graphql, typically specified by WHERE clause
input TradeFilter {
    # logical operators
    AND: [TradeFilter!] # combines all passed `TradeFilter` objects with logical AND
    OR: [TradeFilter!] # combines all passed `TradeFilter` objects with logical OR

    # ID filters
    id: ID # matches all trades with exact ID value
    id_neq: ID # matches all trades with different ID to value

    # Market filters
    market: String # matches all trades with exact market value
    market_neq: String # matches all trades with different market to value
    
    # Buyer filters
    buyer: String # matches all trades with exact buyer value
    buyer_neq: String # matches all trades with different buyer to value

    # Buyer filters
    seller: String # matches all trades with exact seller value
    seller_neq: String # matches all trades with different seller to value

    # Aggressor filters
    aggressor: Side # matches all trades with exact aggressor value e.g. Buy
    aggressor_neq: Side # matches all trades with different aggressor to value

    # Price filters
    price: String # matches all trades with exact price value
    price_neq: String # matches all trades with different price to value
    price_from: String # matches all trades from this price value
    price_to: String # matches all trades to this price value

    # Size filters
    size: String # matches all trades with exact size value
    size_neq: String # matches all trades with different size to value
    size_from: String # matches all trades from this size value
    size_to: String # matches all trades to this size value

    # TimeStamp filters
    timestamp: String # matches all trades with exact timestamp value
    timestamp_neq: String # matches all trades with different timestamp to value
    timestamp_from: String # matches all trades from this timestamp value
    timestamp_to: String # matches all trades to this timestamp value
}

# Filters for Order queries on VEGA graphql, typically specified by WHERE clause
input OrderFilter {
    # logical operators
    AND: [OrderFilter!] # combines all passed `OrderFilter` objects with logical AND
    OR: [OrderFilter!] # combines all passed `OrderFilter` objects with logical OR

    # Open only filter
    open: Boolean # Include only open orders in results (default: False)

    # ID filters
    id: ID # matches all orders with exact ID value
    id_neq: ID # matches all orders with different ID to value

    # Market filters
    market: String # matches all orders with exact market value
    market_neq: String # matches all orders with different market to value

    # Party filters
    party: String # matches all orders with exact party value
    party_neq: String # matches all orders with different party to value

    # Side filters
    side: Side # matches all orders with exact side value e.g. Buy
    side_neq: Side # matches all orders with different side to value

    # Price filters
    price: String # matches all orders with exact price value
    price_neq: String # matches all orders with different price to value
    price_from: String # matches all orders from this price value
    price_to: String # matches all orders to this price value

    # Size filters
    size: String # matches all orders with exact size value
    size_neq: String # matches all orders with different size to value
    size_from: String # matches all orders from this size value
    size_to: String # matches all orders to this size value

    # Remaining filters
    remaining: String # matches all orders with exact remaining value
    remaining_neq: String # matches all orders with different remaining to value
    remaining_from: String # matches all orders from this remaining value
    remaining_to: String # matches all orders to this remaining value

    # Type filters
    type: OrderType # matches all orders with exact type value
    type_neq: OrderType # matches all orders with different type to value
    
    # Timestamp filters
    timestamp: String # matches all orders with exact timestamp value
    timestamp_neq: String # matches all orders with different timestamp to value
    timestamp_from: String # matches all orders from this timestamp value
    timestamp_to: String # matches all orders to this timestamp value

    # Status filters
    status: OrderStatus # matches all orders with exact status value
    status_neq: OrderStatus # matches all orders with different status to value
}