// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/proto"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type TradingMode interface {
	IsTradingMode()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// Represents an asset in vega
type Asset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// The origin source of the asset (e.g: an erc20 asset)
	Source AssetSource `json:"source"`
	// The infrastructure fee account for this asset
	InfrastructureFeeAccount *proto.Account `json:"infrastructureFeeAccount"`
}

// A vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

// A vega builtin asset, mostly for testing purpose
type BuiltinAssetInput struct {
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (ContinuousTrading) IsTradingMode() {}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTradingInput struct {
	// Size of an increment in price in terms of the quote currency. Note this field should not be used and will be ignored
	TickSize *string `json:"tickSize"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (DiscreteTrading) IsTradingMode() {}

// Frequent batch auctions trading mode
type DiscreteTradingInput struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency. Note this field should not be used and will be ignored
	TickSize *string `json:"tickSize"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

func (Erc20) IsAssetSource() {}

// An asset originated from an Ethereum ERC20 Token
type ERC20Input struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawan
	Amount string `json:"amount"`
	// The expiry of the approval (RFC3339Nano)
	Expiry string `json:"expiry"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// ERC20 specific details to start a withdrawal
type Erc20WithdrawalDetailsInput struct {
	// The ethereum address to which the withdrawn funds will be send to
	ReceiverAddress string `json:"receiverAddress"`
}

// An Ethereum oracle
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

// The factors applied to calculate the fees
type FeeFactors struct {
	// The factor applied to calculate MakerFees, a non-negative float
	MakerFee string `json:"makerFee"`
	// The factor applied to calculate InfrastructureFees, a non-negative float
	InfrastructureFee string `json:"infrastructureFee"`
	// The factor applied to calculate LiquidityFees, a non-negative float
	LiquidityFee string `json:"liquidityFee"`
}

// The fees applicable to a market
type Fees struct {
	// The factors used to calculate the different fees
	Factors *FeeFactors `json:"factors"`
}

// A Future product
type Future struct {
	// The maturity date of the product (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// The name of the asset (string)
	Asset *Asset `json:"asset"`
	// The oracle used for this product (Oracle union)
	Oracle Oracle `json:"oracle"`
}

func (Future) IsProduct() {}

type FutureProduct struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	Asset *Asset `json:"asset"`
}

// Future product configuration
type FutureProductInput struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	Asset string `json:"asset"`
}

// Describe something that can be traded on Vega
type Instrument struct {
	// Uniquely identify an instrument accrods all instruments available on Vega (string)
	ID string `json:"id"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)
	Code string `json:"code"`
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Metadata for this instrument
	Metadata *InstrumentMetadata `json:"metadata"`
	// A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)
	Product Product `json:"product"`
}

type InstrumentConfiguration struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Future product specification
	FutureProduct *FutureProduct `json:"futureProduct"`
}

type InstrumentConfigurationInput struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Future product specification
	FutureProduct *FutureProductInput `json:"futureProduct"`
}

// A set of metadata to associate to an instruments
type InstrumentMetadata struct {
	// An arbitrary list of tags to associated to associate to the Instrument (string list)
	Tags []string `json:"tags"`
}

// Parameters for the log normal risk model
type LogNormalModelParams struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

type LogNormalModelParamsInput struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

// A type of risk model for futures trading
type LogNormalRiskModel struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParams `json:"params"`
}

func (LogNormalRiskModel) IsRiskModel() {}

type LogNormalRiskModelInput struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParamsInput `json:"params"`
}

type MarginCalculator struct {
	// The scaling factors that will be used for margin calculation
	ScalingFactors *ScalingFactors `json:"scalingFactors"`
}

// Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market struct {
	// Market ID
	ID string `json:"id"`
	// Market full name
	Name string `json:"name"`
	// Fees related data
	Fees *Fees `json:"fees"`
	// An instance of or reference to a tradable instrument.
	TradableInstrument *TradableInstrument `json:"tradableInstrument"`
	// Definitions and required configuration for the trading mode
	TradingMode TradingMode `json:"tradingMode"`
	// decimalPlaces indicates the number of decimal places that an integer must be shifted by in order to get a correct
	// number denominated in the currency of the Market. (uint64)
	//
	// Examples:
	//   Currency     Balance  decimalPlaces  Real Balance
	//   GBP              100              0       GBP 100
	//   GBP              100              2       GBP   1.00
	//   GBP              100              4       GBP   0.01
	//   GBP                1              4       GBP   0.0001   (  0.01p  )
	//
	//   GBX (pence)      100              0       GBP   1.00     (100p     )
	//   GBX (pence)      100              2       GBP   0.01     (  1p     )
	//   GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
	//   GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
	DecimalPlaces int `json:"decimalPlaces"`
	// Orders on a market
	Orders []*proto.Order `json:"orders"`
	// Get account for a party or market
	Accounts []*proto.Account `json:"accounts"`
	// Trades on a market
	Trades []*proto.Trade `json:"trades"`
	// Current depth on the orderbook for this market
	Depth *proto.MarketDepth `json:"depth"`
	// Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params
	Candles []*proto.Candle `json:"candles"`
	// marketData for the given market
	Data *proto.MarketData `json:"data"`
}

// A new asset proposal change
type NewAsset struct {
	// the source of the new Asset
	Source AssetSource `json:"source"`
}

func (NewAsset) IsProposalChange() {}

// A new asset to be added into vega
type NewAssetInput struct {
	// A new builtin assed to be created
	BuiltinAsset *BuiltinAssetInput `json:"builtinAsset"`
	// A new ERC20 asset to be created
	Erc20 *ERC20Input `json:"erc20"`
}

type NewMarket struct {
	// New market instrument configuration
	Instrument *InstrumentConfiguration `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters RiskModel `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// Trading mode
	TradingMode TradingMode `json:"tradingMode"`
}

func (NewMarket) IsProposalChange() {}

// Allows creating new markets on the network
type NewMarketInput struct {
	// New market instrument configuration
	Instrument *InstrumentConfigurationInput `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters *RiskParametersInput `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// The proposed duration for the opening auction for this market in seconds
	OpeningAuctionDurationSecs *int `json:"openingAuctionDurationSecs"`
	// A mode where Vega try to execute order as soon as they are received. Valid only if discreteTrading is not set
	ContinuousTrading *ContinuousTradingInput `json:"continuousTrading"`
	// Frequent batch auctions trading mode. Valid only if continuousTrading is not set
	DiscreteTrading *DiscreteTradingInput `json:"discreteTrading"`
}

// An estimate of the fee to be paid by the order
type OrderFeeEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
}

type PreparedAmendOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedCancelOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedProposal struct {
	// Raw transaction data to sign & submit
	Blob string `json:"blob"`
	// The pending proposal
	PendingProposal *proto.GovernanceData `json:"pendingProposal"`
}

type PreparedSubmitOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedVote struct {
	// Raw, serialised vote to be signed
	Blob string `json:"blob"`
	// The vote serialised in the blob field
	Vote *ProposalVote `json:"vote"`
}

type PreparedWithdrawal struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type ProposalTerms struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Actual change being introduced by the proposal - action the proposal triggers if passed and enacted.
	Change ProposalChange `json:"change"`
}

// Proposal terms input. Only one kind of change is expected. Proposals with no changes or more than one will not be accepted.
type ProposalTermsInput struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Field defining new market change - the proposal will create new market if passed and enacted.
	// It can only be set if "updateMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	NewMarket *NewMarketInput `json:"newMarket"`
	// Field defining update market change - the proposal will update existing market if passed and enacted.
	// It can only be set if "newMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateMarket *UpdateMarketInput `json:"updateMarket"`
	// Field defining update network change - the proposal will update Vega network parameters if passed and enacted.
	// It can only be set if "newMarket" and "updateMarket" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateNetwork *UpdateNetworkInput `json:"updateNetwork"`
	// a new Asset proposal, this will create a new asset to be used in the vega network
	NewAsset *NewAssetInput `json:"newAsset"`
}

type ProposalVote struct {
	// Cast vote
	Vote *Vote `json:"vote"`
	// Proposal casting the vote on
	ProposalID string `json:"proposalId"`
}

type RiskParametersInput struct {
	// Simple risk model parameters. Set only if risk model is Simple
	Simple *SimpleRiskModelParamsInput `json:"simple"`
	// Log normal risk model parameters. Set only if risk model is LogNormal
	LogNormal *LogNormalRiskModelInput `json:"logNormal"`
}

type ScalingFactors struct {
	// the scaling factor that determines the margin level at which we have to search for more money
	SearchLevel float64 `json:"searchLevel"`
	// the scaling factor that determines the optimal margin level
	InitialMargin float64 `json:"initialMargin"`
	// The scaling factor that determines the overflow margin level
	CollateralRelease float64 `json:"collateralRelease"`
}

// A signature to be bundled with a transaction
type SignatureInput struct {
	// The signature, base64 encoded
	Sig string `json:"sig"`
	// The algorithm used to produice the signature
	Algo string `json:"algo"`
	// The version of the signature
	Version int `json:"version"`
}

// A type of simple/dummy risk model where we can specify the risk factor long and short in params
type SimpleRiskModel struct {
	// Params for the simple risk model
	Params *SimpleRiskModelParams `json:"params"`
}

func (SimpleRiskModel) IsRiskModel() {}

// Parameters for the simple risk model
type SimpleRiskModelParams struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

type SimpleRiskModelParamsInput struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

// A tradable instrument is a combination of an instrument and a risk model
type TradableInstrument struct {
	// An instance of or reference to a fully specified instrument.
	Instrument *Instrument `json:"instrument"`
	// A reference to a risk model that is valid for the instrument
	RiskModel RiskModel `json:"riskModel"`
	// Margin calculation info, currently only the scaling factors (search, initial, release) for this tradable instrument
	MarginCalculator *MarginCalculator `json:"marginCalculator"`
}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the node runner to maintain the vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the market makers to provide liquidity in the market
	LiquidityFee string `json:"liquidityFee"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

// Incomplete change definition for governance proposal terms
// TODO: complete the type
type UpdateMarket struct {
	MarketID string `json:"marketId"`
}

func (UpdateMarket) IsProposalChange() {}

type UpdateMarketInput struct {
	MarketID string `json:"marketId"`
}

// Allows submitting a proposal for changing governance network parameters
type UpdateNetwork struct {
	// Network parameter that restricts when the earliest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MinCloseInSeconds *int `json:"minCloseInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MaxCloseInSeconds *int `json:"maxCloseInSeconds"`
	// Network parameter that restricts when the earliest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MinEnactInSeconds *int `json:"minEnactInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MaxEnactInSeconds *int `json:"maxEnactInSeconds"`
	// Network parameter that sets participation level required for any proposal to pass.
	// Value from 0 to 1.
	RequiredParticipation *float64 `json:"requiredParticipation"`
	// Network parameter that sets majority level required for any proposal to pass.
	// Value from 0.5 to 1.
	RequiredMajority *float64 `json:"requiredMajority"`
	// Network parameter that sets minimum balance required for a party
	// to be able to submit a new proposal. Value greater than 0 to 1.
	MinProposerBalance *float64 `json:"minProposerBalance"`
	// Network parameter that sets minimum balance required for a party
	// to be able to cast a vote.  Value greater than 0 to 1.
	MinVoterBalance *float64 `json:"minVoterBalance"`
}

func (UpdateNetwork) IsProposalChange() {}

// Allows submitting a proposal for changing governance network parameters
type UpdateNetworkInput struct {
	// Network parameter that restricts when the earliest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MinCloseInSeconds *int `json:"minCloseInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MaxCloseInSeconds *int `json:"maxCloseInSeconds"`
	// Network parameter that restricts when the earliest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MinEnactInSeconds *int `json:"minEnactInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MaxEnactInSeconds *int `json:"maxEnactInSeconds"`
	// Network parameter that sets participation level required for any proposal to pass.
	// Value from 0 to 1.
	RequiredParticipation *float64 `json:"requiredParticipation"`
	// Network parameter that sets majority level required for any proposal to pass.
	// Value from 0.5 to 1.
	RequiredMajority *float64 `json:"requiredMajority"`
	// Network parameter that sets minimum balance required for a party
	// to be able to submit a new proposal. Value greater than 0 to 1.
	MinProposerBalance *float64 `json:"minProposerBalance"`
	// Network parameter that sets minimum balance required for a party
	// to be able to cast a vote.  Value greater than 0 to 1.
	MinVoterBalance *float64 `json:"minVoterBalance"`
}

type Vote struct {
	// The vote value cast
	Value VoteValue `json:"value"`
	// The party casting the vote
	Party *proto.Party `json:"party"`
	// ISO-8601 time and date when the vote reached Vega network
	Datetime string `json:"datetime"`
}

// The details of a withdrawal processed by vega
type Withdrawal struct {
	// The Vega internal id of the withdrawal
	ID string `json:"id"`
	// The PartyID initiating the witndrawal
	Party *proto.Party `json:"party"`
	// The amount to be withdrawn
	Amount string `json:"amount"`
	// The asset to be withdrawn
	Asset *Asset `json:"asset"`
	// The current status of the withdrawal
	Status WithdrawalStatus `json:"status"`
	// A reference the foreign chain can use to refere to when processing the withdrawal
	Ref string `json:"ref"`
	// The time until when the withdrawal will be valid (RFC3339Nano)
	Expiry string `json:"expiry"`
	// Time at which the withdrawal was created (RFC3339Nano)
	CreatedTimestamp string `json:"createdTimestamp"`
	// Time at which the withdrawal was finalized (RFC3339Nano)
	WithdrawnTimestamp *string `json:"withdrawnTimestamp"`
	// Hash of the transaction on the foreign chain
	TxHash *string `json:"txHash"`
	// Foreign chain specific details about the withdrawal
	Details WithdrawalDetails `json:"details"`
}

// The various account types we have (used by collateral)
type AccountType string

const (
	// Insurance pool account - only for 'system' party
	AccountTypeInsurance AccountType = "Insurance"
	// Settlement - only for 'system' party
	AccountTypeSettlement AccountType = "Settlement"
	// Margin - The leverage account for traders
	AccountTypeMargin AccountType = "Margin"
	// General account - the account containing 'unused' collateral for traders
	AccountTypeGeneral AccountType = "General"
	// Infrastructure fee account - the account where all infrastructure fees are collected
	AccountTypeFeeInfrastructure AccountType = "FeeInfrastructure"
	// Liquidity fee account - the account where all infrastructure fees are collected
	AccountTypeFeeLiquidity AccountType = "FeeLiquidity"
	// LockWithdraw - and account use for party in the process of withdrawing funds
	AccountTypeLockWithdraw AccountType = "LockWithdraw"
)

var AllAccountType = []AccountType{
	AccountTypeInsurance,
	AccountTypeSettlement,
	AccountTypeMargin,
	AccountTypeGeneral,
	AccountTypeFeeInfrastructure,
	AccountTypeFeeLiquidity,
	AccountTypeLockWithdraw,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeInsurance, AccountTypeSettlement, AccountTypeMargin, AccountTypeGeneral, AccountTypeFeeInfrastructure, AccountTypeFeeLiquidity, AccountTypeLockWithdraw:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval for trade candles when subscribing via VEGA graphql, default is I15M
type Interval string

const (
	// 1 minute interval
	IntervalI1m Interval = "I1M"
	// 5 minute interval
	IntervalI5m Interval = "I5M"
	// 15 minute interval (default)
	IntervalI15m Interval = "I15M"
	// 1 hour interval
	IntervalI1h Interval = "I1H"
	// 6 hour interval
	IntervalI6h Interval = "I6H"
	// 1 day interval
	IntervalI1d Interval = "I1D"
)

var AllInterval = []Interval{
	IntervalI1m,
	IntervalI5m,
	IntervalI15m,
	IntervalI1h,
	IntervalI6h,
	IntervalI1d,
}

func (e Interval) IsValid() bool {
	switch e {
	case IntervalI1m, IntervalI5m, IntervalI15m, IntervalI1h, IntervalI6h, IntervalI1d:
		return true
	}
	return false
}

func (e Interval) String() string {
	return string(e)
}

func (e *Interval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Interval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Interval", str)
	}
	return nil
}

func (e Interval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// What market state are we in
type MarketState string

const (
	// Continuous trading where orders are processed and potentially matched on arrival
	MarketStateContinuous MarketState = "CONTINUOUS"
	// Auction trading where orders are uncrossed at the end of the auction period
	MarketStateAuction MarketState = "AUCTION"
)

var AllMarketState = []MarketState{
	MarketStateContinuous,
	MarketStateAuction,
}

func (e MarketState) IsValid() bool {
	switch e {
	case MarketStateContinuous, MarketStateAuction:
		return true
	}
	return false
}

func (e MarketState) String() string {
	return string(e)
}

func (e *MarketState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketState", str)
	}
	return nil
}

func (e MarketState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type signature provided by a node
type NodeSignatureKind string

const (
	// A signature for proposing a new asset into the network
	NodeSignatureKindAssetNew NodeSignatureKind = "AssetNew"
	// A signature for allowing a withdrawal of funds
	NodeSignatureKindAssetWithdrawal NodeSignatureKind = "AssetWithdrawal"
)

var AllNodeSignatureKind = []NodeSignatureKind{
	NodeSignatureKindAssetNew,
	NodeSignatureKindAssetWithdrawal,
}

func (e NodeSignatureKind) IsValid() bool {
	switch e {
	case NodeSignatureKindAssetNew, NodeSignatureKindAssetWithdrawal:
		return true
	}
	return false
}

func (e NodeSignatureKind) String() string {
	return string(e)
}

func (e *NodeSignatureKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeSignatureKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeSignatureKind", str)
	}
	return nil
}

func (e NodeSignatureKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the order beeing rejected by the core node
type OrderRejectionReason string

const (
	// Market id is invalid
	OrderRejectionReasonInvalidMarketID OrderRejectionReason = "InvalidMarketId"
	// Order id is invalid
	OrderRejectionReasonInvalidOrderID OrderRejectionReason = "InvalidOrderId"
	// Order is out of sequence
	OrderRejectionReasonOrderOutOfSequence OrderRejectionReason = "OrderOutOfSequence"
	// Remaining size in the order is invalid
	OrderRejectionReasonInvalidRemainingSize OrderRejectionReason = "InvalidRemainingSize"
	// Time has failed us
	OrderRejectionReasonTimeFailure OrderRejectionReason = "TimeFailure"
	// Unable to remove the order
	OrderRejectionReasonOrderRemovalFailure OrderRejectionReason = "OrderRemovalFailure"
	// Expiration time is invalid
	OrderRejectionReasonInvalidExpirationTime OrderRejectionReason = "InvalidExpirationTime"
	// Order reference is invalid
	OrderRejectionReasonInvalidOrderReference OrderRejectionReason = "InvalidOrderReference"
	// Edit is not allowed
	OrderRejectionReasonEditNotAllowed OrderRejectionReason = "EditNotAllowed"
	// Order amend fail
	OrderRejectionReasonOrderAmendFailure OrderRejectionReason = "OrderAmendFailure"
	// Order does not exist
	OrderRejectionReasonOrderNotFound OrderRejectionReason = "OrderNotFound"
	// Party id is invalid
	OrderRejectionReasonInvalidPartyID OrderRejectionReason = "InvalidPartyId"
	// Market is closed
	OrderRejectionReasonMarketClosed OrderRejectionReason = "MarketClosed"
	// Margin check failed
	OrderRejectionReasonMarginCheckFailed OrderRejectionReason = "MarginCheckFailed"
	// Order missing general account
	OrderRejectionReasonMissingGeneralAccount OrderRejectionReason = "MissingGeneralAccount"
	// An internal error happend
	OrderRejectionReasonInternalError OrderRejectionReason = "InternalError"
	// Invalid size
	OrderRejectionReasonInvalidSize OrderRejectionReason = "InvalidSize"
	// Invalid persistence
	OrderRejectionReasonInvalidPersistence OrderRejectionReason = "InvalidPersistence"
	// Invalid type
	OrderRejectionReasonInvalidType OrderRejectionReason = "InvalidType"
	// Self trading
	OrderRejectionReasonSelfTrading OrderRejectionReason = "SelfTrading"
	// Insufficient funds to pay fees
	OrderRejectionReasonInsufficientFundsToPayFees OrderRejectionReason = "InsufficientFundsToPayFees"
	// Invalid Time In Force
	OrderRejectionReasonInvalidTimeInForce OrderRejectionReason = "InvalidTimeInForce"
)

var AllOrderRejectionReason = []OrderRejectionReason{
	OrderRejectionReasonInvalidMarketID,
	OrderRejectionReasonInvalidOrderID,
	OrderRejectionReasonOrderOutOfSequence,
	OrderRejectionReasonInvalidRemainingSize,
	OrderRejectionReasonTimeFailure,
	OrderRejectionReasonOrderRemovalFailure,
	OrderRejectionReasonInvalidExpirationTime,
	OrderRejectionReasonInvalidOrderReference,
	OrderRejectionReasonEditNotAllowed,
	OrderRejectionReasonOrderAmendFailure,
	OrderRejectionReasonOrderNotFound,
	OrderRejectionReasonInvalidPartyID,
	OrderRejectionReasonMarketClosed,
	OrderRejectionReasonMarginCheckFailed,
	OrderRejectionReasonMissingGeneralAccount,
	OrderRejectionReasonInternalError,
	OrderRejectionReasonInvalidSize,
	OrderRejectionReasonInvalidPersistence,
	OrderRejectionReasonInvalidType,
	OrderRejectionReasonSelfTrading,
	OrderRejectionReasonInsufficientFundsToPayFees,
	OrderRejectionReasonInvalidTimeInForce,
}

func (e OrderRejectionReason) IsValid() bool {
	switch e {
	case OrderRejectionReasonInvalidMarketID, OrderRejectionReasonInvalidOrderID, OrderRejectionReasonOrderOutOfSequence, OrderRejectionReasonInvalidRemainingSize, OrderRejectionReasonTimeFailure, OrderRejectionReasonOrderRemovalFailure, OrderRejectionReasonInvalidExpirationTime, OrderRejectionReasonInvalidOrderReference, OrderRejectionReasonEditNotAllowed, OrderRejectionReasonOrderAmendFailure, OrderRejectionReasonOrderNotFound, OrderRejectionReasonInvalidPartyID, OrderRejectionReasonMarketClosed, OrderRejectionReasonMarginCheckFailed, OrderRejectionReasonMissingGeneralAccount, OrderRejectionReasonInternalError, OrderRejectionReasonInvalidSize, OrderRejectionReasonInvalidPersistence, OrderRejectionReasonInvalidType, OrderRejectionReasonSelfTrading, OrderRejectionReasonInsufficientFundsToPayFees, OrderRejectionReasonInvalidTimeInForce:
		return true
	}
	return false
}

func (e OrderRejectionReason) String() string {
	return string(e)
}

func (e *OrderRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderRejectionReason", str)
	}
	return nil
}

func (e OrderRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
type OrderStatus string

const (
	// The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
	// Active does not necessarily mean it's still on the order book.
	OrderStatusActive OrderStatus = "Active"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
	OrderStatusExpired OrderStatus = "Expired"
	// The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
	OrderStatusCancelled OrderStatus = "Cancelled"
	// This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity.
	OrderStatusStopped OrderStatus = "Stopped"
	// This order is fully filled with remaining equals zero.
	OrderStatusFilled OrderStatus = "Filled"
	// This order was rejected while beeing processed in the core.
	OrderStatusRejected OrderStatus = "Rejected"
	// This order was partially filled.
	OrderStatusPartiallyFilled OrderStatus = "PartiallyFilled"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusActive,
	OrderStatusExpired,
	OrderStatusCancelled,
	OrderStatusStopped,
	OrderStatusFilled,
	OrderStatusRejected,
	OrderStatusPartiallyFilled,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusActive, OrderStatusExpired, OrderStatusCancelled, OrderStatusStopped, OrderStatusFilled, OrderStatusRejected, OrderStatusPartiallyFilled:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order types, these determine what happens when an order is added to the book
type OrderTimeInForce string

const (
	// The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
	OrderTimeInForceFok OrderTimeInForce = "FOK"
	// The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
	OrderTimeInForceIoc OrderTimeInForce = "IOC"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
	OrderTimeInForceGtc OrderTimeInForce = "GTC"
	// This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
	// NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
	OrderTimeInForceGtt OrderTimeInForce = "GTT"
	// This order is only accepted during an auction period
	OrderTimeInForceGfa OrderTimeInForce = "GFA"
	// This order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
	OrderTimeInForceGfn OrderTimeInForce = "GFN"
)

var AllOrderTimeInForce = []OrderTimeInForce{
	OrderTimeInForceFok,
	OrderTimeInForceIoc,
	OrderTimeInForceGtc,
	OrderTimeInForceGtt,
	OrderTimeInForceGfa,
	OrderTimeInForceGfn,
}

func (e OrderTimeInForce) IsValid() bool {
	switch e {
	case OrderTimeInForceFok, OrderTimeInForceIoc, OrderTimeInForceGtc, OrderTimeInForceGtt, OrderTimeInForceGfa, OrderTimeInForceGfn:
		return true
	}
	return false
}

func (e OrderTimeInForce) String() string {
	return string(e)
}

func (e *OrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTimeInForce", str)
	}
	return nil
}

func (e OrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderType string

const (
	// the default order type
	OrderTypeMarket OrderType = "MARKET"
	// mentioned in ticket, but as yet unused order type
	OrderTypeLimit OrderType = "LIMIT"
	// Used for distressed traders, an order placed by the network to close out distressed traders
	// similar to MARKET order, only no party is attached to the order.
	OrderTypeNetwork OrderType = "NETWORK"
)

var AllOrderType = []OrderType{
	OrderTypeMarket,
	OrderTypeLimit,
	OrderTypeNetwork,
}

func (e OrderType) IsValid() bool {
	switch e {
	case OrderTypeMarket, OrderTypeLimit, OrderTypeNetwork:
		return true
	}
	return false
}

func (e OrderType) String() string {
	return string(e)
}

func (e *OrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderType", str)
	}
	return nil
}

func (e OrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the proposal beeing rejected by the core node
type ProposalRejectionReason string

const (
	// The specified close time is too early based on network parameters
	ProposalRejectionReasonCloseTimeTooSoon ProposalRejectionReason = "CloseTimeTooSoon"
	// The specified close time is too late based on network parameters
	ProposalRejectionReasonCloseTimeTooLate ProposalRejectionReason = "CloseTimeTooLate"
	// The specified enactment time is too early based on network parameters
	ProposalRejectionReasonEnactTimeTooSoon ProposalRejectionReason = "EnactTimeTooSoon"
	// The specified enactment time is too late based on network parameters
	ProposalRejectionReasonEnactTimeTooLate ProposalRejectionReason = "EnactTimeTooLate"
	// The proposer for this proposal as insufficient token
	ProposalRejectionReasonInsufficientTokens ProposalRejectionReason = "InsufficientTokens"
	// The instrument quote name and base name were the same
	ProposalRejectionReasonInvalidInstrumentSecurity ProposalRejectionReason = "InvalidInstrumentSecurity"
	// The proposal has no product specified
	ProposalRejectionReasonNoProduct ProposalRejectionReason = "NoProduct"
	// The specified product is not supported
	ProposalRejectionReasonUnsupportedProduct ProposalRejectionReason = "UnsupportedProduct"
	// Invalid future maturity timestamp (expect RFC3339)
	ProposalRejectionReasonInvalidFutureMaturityTimestamp ProposalRejectionReason = "InvalidFutureMaturityTimestamp"
	// The product maturity is already in the past
	ProposalRejectionReasonProductMaturityIsPassed ProposalRejectionReason = "ProductMaturityIsPassed"
	// The proposal has no trading mode
	ProposalRejectionReasonNoTradingMode ProposalRejectionReason = "NoTradingMode"
	// The proposal has an unsupported trading mode
	ProposalRejectionReasonUnsupportedTradingMode ProposalRejectionReason = "UnsupportedTradingMode"
	// The proposal failed node validation
	ProposalRejectionReasonNodeValidationFailed ProposalRejectionReason = "NodeValidationFailed"
	// A builtin asset configuration is missing
	ProposalRejectionReasonMissingBuiltinAssetField ProposalRejectionReason = "MissingBuiltinAssetField"
	// The ERC20 contract address is missing from an ERC20 asset proposal
	ProposalRejectionReasonMissingERC20ContractAddress ProposalRejectionReason = "MissingERC20ContractAddress"
	// The specified asset for the market proposal is invalid
	ProposalRejectionReasonInvalidAsset ProposalRejectionReason = "InvalidAsset"
	// proposal terms timestamps are not compatible (Validation < Closing < Enactment)
	ProposalRejectionReasonIncompatibleTimestamps ProposalRejectionReason = "IncompatibleTimestamps"
)

var AllProposalRejectionReason = []ProposalRejectionReason{
	ProposalRejectionReasonCloseTimeTooSoon,
	ProposalRejectionReasonCloseTimeTooLate,
	ProposalRejectionReasonEnactTimeTooSoon,
	ProposalRejectionReasonEnactTimeTooLate,
	ProposalRejectionReasonInsufficientTokens,
	ProposalRejectionReasonInvalidInstrumentSecurity,
	ProposalRejectionReasonNoProduct,
	ProposalRejectionReasonUnsupportedProduct,
	ProposalRejectionReasonInvalidFutureMaturityTimestamp,
	ProposalRejectionReasonProductMaturityIsPassed,
	ProposalRejectionReasonNoTradingMode,
	ProposalRejectionReasonUnsupportedTradingMode,
	ProposalRejectionReasonNodeValidationFailed,
	ProposalRejectionReasonMissingBuiltinAssetField,
	ProposalRejectionReasonMissingERC20ContractAddress,
	ProposalRejectionReasonInvalidAsset,
	ProposalRejectionReasonIncompatibleTimestamps,
}

func (e ProposalRejectionReason) IsValid() bool {
	switch e {
	case ProposalRejectionReasonCloseTimeTooSoon, ProposalRejectionReasonCloseTimeTooLate, ProposalRejectionReasonEnactTimeTooSoon, ProposalRejectionReasonEnactTimeTooLate, ProposalRejectionReasonInsufficientTokens, ProposalRejectionReasonInvalidInstrumentSecurity, ProposalRejectionReasonNoProduct, ProposalRejectionReasonUnsupportedProduct, ProposalRejectionReasonInvalidFutureMaturityTimestamp, ProposalRejectionReasonProductMaturityIsPassed, ProposalRejectionReasonNoTradingMode, ProposalRejectionReasonUnsupportedTradingMode, ProposalRejectionReasonNodeValidationFailed, ProposalRejectionReasonMissingBuiltinAssetField, ProposalRejectionReasonMissingERC20ContractAddress, ProposalRejectionReasonInvalidAsset, ProposalRejectionReasonIncompatibleTimestamps:
		return true
	}
	return false
}

func (e ProposalRejectionReason) String() string {
	return string(e)
}

func (e *ProposalRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalRejectionReason", str)
	}
	return nil
}

func (e ProposalRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Varoius states a proposal can transition through:
//   Open ->
//       - Passed -> Enacted.
//       - Rejected.
//   Proposal can enter Failed state from any other state.
type ProposalState string

const (
	// Proposal became invalid and cannot be processed
	ProposalStateFailed ProposalState = "Failed"
	// Proposal is open for voting
	ProposalStateOpen ProposalState = "Open"
	// Proposal has gained enough support to be executed
	ProposalStatePassed ProposalState = "Passed"
	// Proposal didn't get enough votes
	ProposalStateDeclined ProposalState = "Declined"
	// Proposal has could not gain enough support to be executed
	ProposalStateRejected ProposalState = "Rejected"
	// Proposal has been executed and the changes under this proposal have now been applied
	ProposalStateEnacted ProposalState = "Enacted"
	// Proposal is waiting for the node to run validation
	ProposalStateWaitingForNodeVote ProposalState = "WaitingForNodeVote"
)

var AllProposalState = []ProposalState{
	ProposalStateFailed,
	ProposalStateOpen,
	ProposalStatePassed,
	ProposalStateDeclined,
	ProposalStateRejected,
	ProposalStateEnacted,
	ProposalStateWaitingForNodeVote,
}

func (e ProposalState) IsValid() bool {
	switch e {
	case ProposalStateFailed, ProposalStateOpen, ProposalStatePassed, ProposalStateDeclined, ProposalStateRejected, ProposalStateEnacted, ProposalStateWaitingForNodeVote:
		return true
	}
	return false
}

func (e ProposalState) String() string {
	return string(e)
}

func (e *ProposalState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalState", str)
	}
	return nil
}

func (e ProposalState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether the placer of an order is aiming to buy or sell on the market
type Side string

const (
	// The Placer of the order is aiming to buy
	SideBuy Side = "Buy"
	// The placer of the order is aiming to sell
	SideSell Side = "Sell"
)

var AllSide = []Side{
	SideBuy,
	SideSell,
}

func (e Side) IsValid() bool {
	switch e {
	case SideBuy, SideSell:
		return true
	}
	return false
}

func (e Side) String() string {
	return string(e)
}

func (e *Side) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Side(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Side", str)
	}
	return nil
}

func (e Side) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid trade types
type TradeType string

const (
	// Default trade type
	TradeTypeDefault TradeType = "Default"
	// Network close-out - good
	TradeTypeNetworkCloseOutGood TradeType = "NetworkCloseOutGood"
	// Network close-out - bad
	TradeTypeNetworkCloseOutBad TradeType = "NetworkCloseOutBad"
)

var AllTradeType = []TradeType{
	TradeTypeDefault,
	TradeTypeNetworkCloseOutGood,
	TradeTypeNetworkCloseOutBad,
}

func (e TradeType) IsValid() bool {
	switch e {
	case TradeTypeDefault, TradeTypeNetworkCloseOutGood, TradeTypeNetworkCloseOutBad:
		return true
	}
	return false
}

func (e TradeType) String() string {
	return string(e)
}

func (e *TradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeType", str)
	}
	return nil
}

func (e TradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteValue string

const (
	// NO reject a proposal
	VoteValueNo VoteValue = "NO"
	// YES accept a proposal
	VoteValueYes VoteValue = "YES"
)

var AllVoteValue = []VoteValue{
	VoteValueNo,
	VoteValueYes,
}

func (e VoteValue) IsValid() bool {
	switch e {
	case VoteValueNo, VoteValueYes:
		return true
	}
	return false
}

func (e VoteValue) String() string {
	return string(e)
}

func (e *VoteValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteValue", str)
	}
	return nil
}

func (e VoteValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a withdrawal
type WithdrawalStatus string

const (
	// The withdrawal is open and being processed by the network
	WithdrawalStatusOpen WithdrawalStatus = "Open"
	// The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	WithdrawalStatusCancelled WithdrawalStatus = "Cancelled"
	// The withdrawal was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts
	WithdrawalStatusFinalized WithdrawalStatus = "Finalized"
)

var AllWithdrawalStatus = []WithdrawalStatus{
	WithdrawalStatusOpen,
	WithdrawalStatusCancelled,
	WithdrawalStatusFinalized,
}

func (e WithdrawalStatus) IsValid() bool {
	switch e {
	case WithdrawalStatusOpen, WithdrawalStatusCancelled, WithdrawalStatusFinalized:
		return true
	}
	return false
}

func (e WithdrawalStatus) String() string {
	return string(e)
}

func (e *WithdrawalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WithdrawalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WithdrawalStatus", str)
	}
	return nil
}

func (e WithdrawalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
