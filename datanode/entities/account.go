// Copyright (c) 2022 Gobalsky Labs Limited
//
// Use of this software is governed by the Business Source License included
// in the LICENSE.DATANODE file and at https://www.mariadb.com/bsl11.
//
// Change Date: 18 months from the later of the date of the first publicly
// available Distribution of this version of the repository, and 25 June 2022.
//
// On the date above, in accordance with the Business Source License, use
// of this software will be governed by version 3 or later of the GNU General
// Public License.

package entities

import (
	"fmt"
	"time"

	"code.vegaprotocol.io/protos/vega"
)

const (
	noMarketStr     string = "!"
	noMarketByte    byte   = '!'
	systemOwnerStr  string = "*"
	systemOwnerByte byte   = '*'
)

type Account struct {
	ID       int64
	PartyID  PartyID
	AssetID  AssetID
	MarketID MarketID
	Type     vega.AccountType
	VegaTime time.Time
}

func (a Account) String() string {
	return fmt.Sprintf("{ID: %s}", a.AssetID)
}

func AccountFromProto(va *vega.Account) (Account, error) {
	account := Account{
		PartyID:  NewPartyID(va.Owner),
		AssetID:  NewAssetID(va.Asset),
		MarketID: NewMarketID(va.MarketId),
		Type:     va.Type,
	}
	return account, nil
}

// AccountFromAccountID takes an ID generated by vega core and uses the information in it to create
// an account struct. In vega core, account IDs are generated by concatenating (party id, market id,
// asset id, account type) with '!' indicating no market, and "*" indicating the system owner party.
// (see collateral/engine.go). It's a bit unfortunate that this internal detail leaks out of core,
// but it's required for now as it's the only way we can extract all the required account information
// out of an TransferResponse message.
func AccountFromAccountID(id string) (Account, error) {
	var a Account
	var offset int

	// Market ID is first, '!' indicates no market
	if id[offset] == noMarketByte {
		offset++
		a.MarketID = NewMarketID(noMarketStr)
	} else {
		if len(id) < 64 {
			return Account{}, fmt.Errorf("account id too short: %v", id)
		}
		a.MarketID = NewMarketID(id[0:64])
		if err := a.MarketID.Error(); err != nil {
			return Account{}, fmt.Errorf("account id: %w", err)
		}
		offset += 64
	}

	// Party ID is next, '*' indicates system owner
	if id[offset] == systemOwnerByte {
		a.PartyID = NewPartyID(systemOwnerStr)
		offset++
	} else {
		if len(id) < offset+64 {
			return Account{}, fmt.Errorf("party id to short %v", id)
		}

		a.PartyID = NewPartyID(id[offset : offset+64])
		if err := a.PartyID.Error(); err != nil {
			return Account{}, fmt.Errorf("party id: %w", err)
		}
		offset += 64
	}

	// Now Asset ID
	if offset >= (len(id) - 1) {
		return Account{}, fmt.Errorf("account id too short %v", id)
	}

	a.AssetID = NewAssetID(id[offset : len(id)-1])
	if err := a.AssetID.Error(); err != nil {
		return Account{}, fmt.Errorf("party id: %w", err)
	}
	a.Type = vega.AccountType(id[len(id)-1] - 48)
	return a, nil
}
