# VEGA - GraphQL schema

schema {
  query: Query
  subscription: Subscription
}

"Generic structure holding a key/value pair."
type Metadata {
  "Key of the metadata."
  key: String!
  "Value of the metadata."
  value: String!
}

"The result from processing a transaction"
type TransactionResult {
  "The party which submitted this transaction"
  partyId: String!
  "The hash of the transaction"
  hash: String!
  "Was the transaction successful or not?"
  status: Boolean!
  "The error emitted by the transaction, will be null if the transaction succeeded"
  error: String
}

"Create an order linked to an index rather than a price"
type PeggedOrder {
  "Index to link this order to"
  reference: PeggedReference!
  "Price offset from the peg"
  offset: String!
}

"Details of the iceberg order"
type IcebergOrder {
  "Size of the order that will be made visible if the iceberg order is replenished after trading"
  peakSize: String!
  "If the visible size of the order falls below this value, it will be replenished back to the peak size using the reserved amount"
  minimumVisibleSize: String!
  "Size of the order that is reserved and used to restore the iceberg's peak when it is refreshed"
  reservedRemaining: String!
}

"Subscriptions allow a caller to receive new information as it is available from the Vega network."
type Subscription {
  "Subscribe to the accounts updates"
  accounts(
    "ID of the market from which to receive accounts updates for"
    marketId: ID
    "ID of the party from which to receive accounts updates for"
    partyId: ID
    "Asset code"
    assetId: ID
    "Type of the account"
    type: AccountType
  ): [AccountUpdate!]!

  "Subscribe to event data from the event bus"
  busEvents(
    "The types to subscribe to has to be an array"
    types: [BusEventType!]!
    "Optional filter by market ID"
    marketId: ID
    "Optional filter by party ID"
    partyId: ID
    "Specifies the size that the client will receive events in. Using 0 results in a variable batch size being sent. The stream will be closed if the client fails to read a batch within 5 seconds"
    batchSize: Int!
  ): [BusEvent!]

  "Subscribe to the candles updates"
  candles(
    "ID of the market to listen to for candles"
    marketId: ID!
    "Interval of the candles to listen for"
    interval: Interval!
  ): Candle!

  "Subscribe to liquidity provisioning data"
  liquidityProvisions(
    "The party ID to subscribe for, empty if all"
    partyId: ID
    "The market ID to subscribe for, empty if all"
    marketId: ID
  ): [LiquidityProvisionUpdate!]

  "Subscribe to the margin changes"
  margins(
    "ID of the party you want to subscribe to for margin updates"
    partyId: ID!
    "ID of the market you want to listen to for margin updates (nil if you want updates for all markets)"
    marketId: ID
  ): MarginLevelsUpdate!

  "Subscribe to the mark price changes"
  marketsData(
    "ID of the market for which you want to subscribe to the market data changes"
    marketIds: [ID!]!
  ): [ObservableMarketData!]!

  "Subscribe to the market depths update"
  marketsDepth(
    "ID of the market you want to receive market depth updates for"
    marketIds: [ID!]!
  ): [ObservableMarketDepth!]!

  "Subscribe to price level market depth updates"
  marketsDepthUpdate(
    "ID of the market you want to receive market depth price level updates for"
    marketIds: [ID!]!
  ): [ObservableMarketDepthUpdate!]!

  "Subscribe to orders updates"
  orders("Filter orders" filter: OrderByMarketAndPartyIdsFilter): [OrderUpdate!]

  "Subscribe to the positions updates"
  positions(
    "ID of the party from you want updates for"
    partyId: ID
    "ID of the market from which you want position updates"
    marketId: ID
  ): [PositionUpdate!]!

  "Subscribe to proposals. Leave out all arguments to receive all proposals"
  proposals(
    "Optional party ID whose proposals are to be streamed"
    partyId: ID
  ): Proposal!

  "Subscribe to the trades updates"
  trades(
    "ID of the market from which you want trades updates"
    marketId: ID
    "ID of the party from which you want trades updates"
    partyId: ID
  ): [TradeUpdate!]
    @deprecated(
      reason: "Use tradesStream instead as it allows for filtering multiple markets and/or parties at once"
    )

  "Subscribe to the trades updates"
  tradesStream(
    "Filter to apply to trades"
    filter: TradesSubscriptionFilter!
  ): [TradeUpdate!]

  "Subscribe to votes, either by proposal ID or party ID"
  votes(
    "Optional proposal ID which votes are to be streamed"
    proposalId: ID
    "Optional party ID whose votes are to be streamed"
    partyId: ID
  ): ProposalVote!
}

"Margins for a given a party"
type MarginLevels {
  "Market in which the margin is required for this party"
  market: Market!
  "Asset for the current margins"
  asset: Asset!
  "The party for this margin"
  party: Party!
  "Minimal margin for the position to be maintained in the network (unsigned integer)"
  maintenanceLevel: String!
  "If the margin is between maintenance and search, the network will initiate a collateral search, expressed as unsigned integer"
  searchLevel: String!
  "This is the minimum margin required for a party to place a new order on the network, expressed as unsigned integer"
  initialLevel: String!
  "When in isolated margin, the required order margin level, otherwise, 0"
  orderMarginLevel: String!
  """
  If the margin of the party is greater than this level, then collateral will be released from the margin account into
  the general account of the party for the given asset.
  """
  collateralReleaseLevel: String!
  "RFC3339Nano time from at which this margin level was relevant"
  timestamp: Timestamp!

  "Margin mode of the party, cross margin or isolated margin"
  marginMode: MarginMode!

  "Margin factor, only relevant for isolated margin mode, else 0"
  marginFactor: String!
}

"Margins for a hypothetical position not related to any existing party"
type AbstractMarginLevels {
  "Market in which the margin is required for this party"
  market: Market!
  "Asset for the current margins"
  asset: Asset!
  "Minimal margin for the position to be maintained in the network (unsigned integer)"
  maintenanceLevel: String!
  "If the margin is between maintenance and search, the network will initiate a collateral search, expressed as unsigned integer"
  searchLevel: String!
  "This is the minimum margin required for a party to place a new order on the network, expressed as unsigned integer"
  initialLevel: String!
  "When in isolated margin, the required order margin level, otherwise, 0"
  orderMarginLevel: String!
  """
  If the margin of the party is greater than this level, then collateral will be released from the margin account into
  the general account of the party for the given asset.
  """
  collateralReleaseLevel: String!
  "Margin mode of the party, cross margin or isolated margin"
  marginMode: MarginMode!
  "Margin factor, only relevant for isolated margin mode, else 0"
  marginFactor: String!
}

enum MarginMode {
  "Margin mode is not specified."
  MARGIN_MODE_UNSPECIFIED
  "Party is in cross margin mode"
  MARGIN_MODE_CROSS_MARGIN
  "Party is in isolated margin mode"
  MARGIN_MODE_ISOLATED_MARGIN
}

"Margins for a given a party"
type MarginLevelsUpdate {
  "Market in which the margin is required for this party"
  marketId: ID!
  "Asset for the current margins"
  asset: ID!
  "The party for this margin"
  partyId: ID!
  "Minimal margin for the position to be maintained in the network (unsigned integer)"
  maintenanceLevel: String!
  "If the margin is between maintenance and search, the network will initiate a collateral search (unsigned integer)"
  searchLevel: String!
  "This is the minimum margin required for a party to place a new order on the network (unsigned integer)"
  initialLevel: String!
  "When in isolated margin, the required order margin level, otherwise, 0"
  orderMarginLevel: String!
  """
  If the margin of the party is greater than this level, then collateral will be released from the margin account into
  the general account of the party for the given asset.
  """
  collateralReleaseLevel: String!
  "RFC3339Nano time from at which this margin level was relevant"
  timestamp: Timestamp!

  "Margin mode of the party, cross margin or isolated margin"
  marginMode: MarginMode!

  "Margin factor, only relevant for isolated margin mode, else 0"
  marginFactor: String!
}

"Details of a  perpetual product."
type PerpetualData {
  "Funding payment for this period as the difference between the time-weighted average price of the external and internal data point."
  fundingPayment: String
  "Percentage difference between the time-weighted average price of the external and internal data point."
  fundingRate: String
  "Time-weighted average price calculated from data points for this period from the external data source."
  externalTwap: String
  "Time-weighted average price calculated from data points for this period from the internal data source."
  internalTwap: String
  "Funding period sequence number"
  seqNum: Int!
  "Time at which the funding period started"
  startTime: Timestamp!
  "Internal composite price used as input to the internal VWAP"
  internalCompositePrice: String!
  "The methodology used to calculated internal composite price for perpetual markets"
  internalCompositePriceType: CompositePriceType!
  "RFC3339Nano time indicating the next time internal composite price will be calculated for perpetual markets, where applicable"
  nextInternalCompositePriceCalc: String!
  "The last value from the external oracle"
  underlyingIndexPrice: String!
  "The internal state of the underlying internal composite price"
  internalCompositePriceState: CompositePriceState
}

type CompositePriceSource {
  "The current value of the composite source price"
  price: String!
  "The last time the price source was updated in RFC3339Nano"
  lastUpdated: Timestamp!
  "The source of the price"
  PriceSource: String!
}

type CompositePriceState {
  "Underlying state of the composite price"
  priceSources: [CompositePriceSource!]
}

union ProductData = PerpetualData

enum CompositePriceType {
  "Composite price is calculated as a weighted average of the underlying price sources"
  COMPOSITE_PRICE_TYPE_WEIGHTED
  "Composite price is calculated as a median of the underlying price sources"
  COMPOSITE_PRICE_TYPE_MEDIAN
  "Composite price is set to the last trade (legacy)"
  COMPOSITE_PRICE_TYPE_LAST_TRADE
}

"Live data of a Market"
type MarketData {
  "Market of the associated mark price"
  market: Market!
  "The mark price (an unsigned integer)"
  markPrice: String!
  "The methodology used for the calculation of the mark price"
  markPriceType: CompositePriceType!
  "The highest price level on an order book for buy orders."
  bestBidPrice: String!
  "The aggregated volume being bid at the best bid price."
  bestBidVolume: String!
  "The lowest price level on an order book for offer orders."
  bestOfferPrice: String!
  "The aggregated volume being offered at the best offer price."
  bestOfferVolume: String!
  "The highest price level on an order book for buy orders not including pegged orders."
  bestStaticBidPrice: String!
  "The aggregated volume being offered at the best static bid price, excluding pegged orders"
  bestStaticBidVolume: String!
  "The lowest price level on an order book for offer orders not including pegged orders."
  bestStaticOfferPrice: String!
  "The aggregated volume being offered at the best static offer price, excluding pegged orders."
  bestStaticOfferVolume: String!
  "The arithmetic average of the best bid price and best offer price."
  midPrice: String!
  "The arithmetic average of the best static bid price and best static offer price"
  staticMidPrice: String!
  "RFC3339Nano time at which this market price was relevant"
  timestamp: Timestamp!
  "The sum of the size of all positions greater than 0."
  openInterest: String!
  "RFC3339Nano time at which the auction will stop (null if not in auction mode)"
  auctionEnd: String
  "RFC3339Nano time at which the next auction will start (null if none is scheduled)"
  auctionStart: String
  "Indicative price if the auction ended now, 0 if not in auction mode"
  indicativePrice: String!
  "Indicative volume if the auction ended now, 0 if not in auction mode"
  indicativeVolume: String!
  "What mode the market is in (auction, continuous, etc)"
  marketTradingMode: MarketTradingMode!
  "Current state of the market"
  marketState: MarketState!
  "What triggered an auction (if an auction was started)"
  trigger: AuctionTrigger!
  "What extended the ongoing auction (if an auction was extended)"
  extensionTrigger: AuctionTrigger!
  "The amount of stake targeted for this market"
  targetStake: String
  "The supplied stake for the market"
  suppliedStake: String
  "The liquidity commitments for a given market"
  commitments: MarketDataCommitments!
  "A list of valid price ranges per associated trigger"
  priceMonitoringBounds: [PriceMonitoringBounds!]
  "The market value proxy"
  marketValueProxy: String!
  "The equity-like share of liquidity fee for each liquidity provider"
  liquidityProviderFeeShare: [LiquidityProviderFeeShare!]
  "SLA performance statistics"
  liquidityProviderSla: [LiquidityProviderSLA!]
  "RFC3339Nano time indicating the next time positions will be marked to market"
  nextMarkToMarket: String!
  "The market growth factor for the last market time window"
  marketGrowth: String!
  "The last traded price (an unsigned integer)"
  lastTradedPrice: String!
  "The current funding rate. This applies only to a perpetual market"
  productData: ProductData
  "RFC3339Nano time indicating the next time the network will attempt to close part of its position"
  nextNetworkCloseout: String!
  "State of the underlying internal composite price"
  markPriceState: CompositePriceState
}

"Live data of a Market"
type ObservableMarketData {
  "Market ID of the associated mark price"
  marketId: ID!
  "The mark price (an unsigned integer)"
  markPrice: String!
  "The highest price level on an order book for buy orders."
  bestBidPrice: String!
  "The aggregated volume being bid at the best bid price."
  bestBidVolume: String!
  "The lowest price level on an order book for offer orders."
  bestOfferPrice: String!
  "The aggregated volume being offered at the best offer price."
  bestOfferVolume: String!
  "The highest price level on an order book for buy orders not including pegged orders."
  bestStaticBidPrice: String!
  "The aggregated volume being offered at the best static bid price, excluding pegged orders"
  bestStaticBidVolume: String!
  "The lowest price level on an order book for offer orders not including pegged orders"
  bestStaticOfferPrice: String!
  "The aggregated volume being offered at the best static offer price, excluding pegged orders"
  bestStaticOfferVolume: String!
  "The arithmetic average of the best bid price and best offer price"
  midPrice: String!
  "The arithmetic average of the best static bid price and best static offer price"
  staticMidPrice: String!
  "RFC3339Nano time at which this market price was relevant"
  timestamp: Timestamp!
  "The sum of the size of all positions greater than 0"
  openInterest: String!
  "RFC3339Nano time at which the auction will stop (null if not in auction mode)"
  auctionEnd: String
  "RFC3339Nano time at which the next auction will start (null if none is scheduled)"
  auctionStart: String
  "Indicative price if the auction ended now, 0 if not in auction mode"
  indicativePrice: String!
  "Indicative volume if the auction ended now, 0 if not in auction mode"
  indicativeVolume: String!
  "What mode the market is in (auction, continuous etc)"
  marketTradingMode: MarketTradingMode!
  "Current state of the market"
  marketState: MarketState!
  "What triggered an auction (if an auction was started)"
  trigger: AuctionTrigger!
  "What extended the ongoing auction (if an auction was extended)"
  extensionTrigger: AuctionTrigger!
  "The amount of stake targeted for this market"
  targetStake: String
  "The supplied stake for the market"
  suppliedStake: String
  "A list of valid price ranges per associated trigger"
  priceMonitoringBounds: [PriceMonitoringBounds!]
  "The market value proxy"
  marketValueProxy: String!
  "The equity-like share of liquidity fee for each liquidity provider"
  liquidityProviderFeeShare: [ObservableLiquidityProviderFeeShare!]
  "SLA performance statistics"
  liquidityProviderSla: [ObservableLiquidityProviderSLA!]
  "RFC3339Nano time indicating the next time positions will be marked to market"
  nextMarkToMarket: String!
  "The market growth factor for the last market time window"
  marketGrowth: String!
  "The last traded price (an unsigned integer)"
  lastTradedPrice: String!
  "The current funding rate. This applies only to a perpetual market"
  productData: ProductData
  "The methodology used to calculated mark price"
  markPriceType: CompositePriceType!
  "State of the underlying internal composite price"
  markPriceState: CompositePriceState
}

"Timestamps for when the market changes state"
type MarketTimestamps {
  "RFC3339Nano time when the market is first proposed"
  proposed: Timestamp
  "RFC3339Nano time when the market has been voted in and waiting to be created"
  pending: Timestamp!
  "RFC3339Nano time when the market is open and ready to accept trades"
  open: Timestamp!
  "RFC3339Nano time when the market is closed"
  close: Timestamp!
}

"The equity-like share of liquidity fee for each liquidity provider"
type LiquidityProviderFeeShare {
  "The liquidity provider party ID"
  party: Party!
  "The share owned by this liquidity provider"
  equityLikeShare: String!
  "The average entry valuation of the liquidity provider for the market"
  averageEntryValuation: String!
  "The average liquidity score"
  averageScore: String!
  "The virtual stake for this liquidity provider"
  virtualStake: String!
}

"The equity-like share of liquidity fee for each liquidity provider"
type ObservableLiquidityProviderFeeShare {
  "The liquidity provider party ID"
  partyId: ID!
  "The share owned by this liquidity provider (float)"
  equityLikeShare: String!
  "The average entry valuation of the liquidity provider for the market"
  averageEntryValuation: String!
  "The average liquidity score"
  averageScore: String!
}

"The SLA statistics for each liquidity provider"
type LiquidityProviderSLA {
  "The liquidity provider party ID"
  party: Party!
  "Indicates how often LP meets the commitment during the current epoch."
  currentEpochFractionOfTimeOnBook: String!
  "Indicates how often LP met the commitment in the previous epoch."
  lastEpochFractionOfTimeOnBook: String!
  "Indicates the fee penalty amount applied in the previous epoch."
  lastEpochFeePenalty: String!
  "Indicates the bond penalty amount applied in the previous epoch."
  lastEpochBondPenalty: String!
  "Determines how the fee penalties from past epochs affect future fee revenue."
  hysteresisPeriodFeePenalties: [String!]
  "Represents the total amount of funds LP must supply. The amount to be supplied is in the market’s settlement currency, spread on both buy and sell sides of the order book within a defined range."
  requiredLiquidity: String!
  "Notional volume of orders within the range provided on the buy side of the book."
  notionalVolumeBuys: String!
  "Notional volume of orders within the range provided on the sell side of the book."
  notionalVolumeSells: String!
}

"The SLA statistics for each liquidity provider"
type ObservableLiquidityProviderSLA {
  "The liquidity provider party ID"
  party: ID!
  "Indicates how often LP meets the commitment during the current epoch."
  currentEpochFractionOfTimeOnBook: String!
  "Indicates how often LP meets the commitment during last epoch."
  lastEpochFractionOfTimeOnBook: String!
  "Indicates the fee penalty amount applied in the previous epoch."
  lastEpochFeePenalty: String!
  "Indicates the bond penalty amount applied in the previous epoch."
  lastEpochBondPenalty: String!
  "Determines how the fee penalties from past epochs affect future fee revenue."
  hysteresisPeriodFeePenalties: [String!]
  "Represents the total amount of funds LP must supply. The amount to be supplied is in the market’s settlement currency, spread on both buy and sell sides of the order book within a defined range."
  requiredLiquidity: String!
  "Notional volume of orders within the range provided on the buy side of the book."
  notionalVolumeBuys: String!
  "Notional volume of orders within the range provided on the sell side of the book."
  notionalVolumeSells: String!
}

"The liquidity commitments for this market"
type MarketDataCommitments {
  "A set of liquidity sell orders to meet the liquidity provision obligation."
  sells: [LiquidityOrderReference!]
  "A set of liquidity buy orders to meet the liquidity provision obligation."
  buys: [LiquidityOrderReference!]
}

type TransactionSubmitted {
  success: Boolean!
}

"Filter input for historical balance queries"
input AccountFilter {
  "Restrict accounts to those holding balances in this asset ID."
  assetId: ID
  "Restrict accounts to those owned by the parties in this list. Pass an empty list for no filter."
  partyIds: [ID!]
  "Restrict accounts to those connected to the markets in this list. Pass an empty list for no filter."
  marketIds: [ID!]
  "Restrict accounts to those connected to any of the types in this list. Pass an empty list for no filter."
  accountTypes: [AccountType!]
}

"Filter for historical entry ledger queries, you must provide at least one party in FromAccountFilter, or ToAccountFilter"
input LedgerEntryFilter {
  """
  Determines whether an entry must have accounts matching both the account_from_filter
  and the account_to_filter. If set to 'true', entries must have matches in both filters.
  If set to `false`, entries matching only the account_from_filter or the account_to_filter will also be included.
  """
  CloseOnAccountFilters: Boolean
  "Used to set values for filtering sender accounts. Party must be provided in this filter or to_account_filter, or both."
  FromAccountFilter: AccountFilter
  "Used to set values for filtering receiver accounts. Party must be provided in this filter or from_account_filter, or both."
  ToAccountFilter: AccountFilter
  "List of transfer types that is used for filtering sender and receiver accounts."
  TransferTypes: [TransferType]
  "Optional transfer ID to filter by. If provided, all other filters are ignored."
  TransferId: ID
}

"Filter for historical reward summary queries"
input RewardSummaryFilter {
  assetIds: [ID!]
  marketIds: [ID!]
  fromEpoch: Int
  toEpoch: Int
}

"Queries allow a caller to read data and filter data via GraphQL."
type Query {
  "An asset which is used in the vega network"
  asset("ID of the asset" id: ID!): Asset

  "The list of all assets in use in the Vega network or the specified asset if ID is provided"
  assetsConnection(id: ID, pagination: Pagination): AssetsConnection

  "Get historical balances for an account within the given date range"
  balanceChanges(
    "Optional filter to restrict queried accounts to those of a specific asset, party, market or type"
    filter: AccountFilter
    """
    Date range to retrieve historical balances from/to.
    Start and end time should be expressed as an integer value of Unix nanoseconds.
    If a cursor is not provided in the pagination controls,
    the date range must be provided with a start or end date, or both.
    The date range is inclusive of the start date and exclusive of the end date.
    The date range must be no more than 1 year in duration.
    Dates before 2020-01-01 will not be accepted.
    """
    dateRange: DateRange
    "Optional pagination information"
    pagination: Pagination
  ): AggregatedBalanceConnection!

  "Get the current referral program"
  currentReferralProgram: CurrentReferralProgram

  "Get the current volume discount program"
  currentVolumeDiscountProgram: VolumeDiscountProgram

  "List core snapshots"
  coreSnapshots(pagination: Pagination): CoreSnapshotConnection

  "Find a deposit using its ID"
  deposit("ID of the Deposit" id: ID!): Deposit

  "Fetch all deposits"
  deposits(
    "Date range to fetch deposits between"
    dateRange: DateRange
    "Pagination options"
    pagination: Pagination
  ): DepositsConnection

  "Fetch all entities for a given transaction hash"
  entities(txHash: String!): Entities!

  "Get data for a specific epoch, if ID omitted it gets the current epoch. If the string is 'next', fetch the next epoch"
  epoch(id: ID, block: String): Epoch!

  "List reward summary per epoch by asset, market, reward type"
  epochRewardSummaries(
    filter: RewardSummaryFilter
    pagination: Pagination
  ): EpochRewardSummaryConnection

  "Get the signatures bundle to allowlist an ERC20 token in the collateral bridge"
  erc20ListAssetBundle("ID of the asset" assetId: ID!): Erc20ListAssetBundle

  "Get the signature bundle to add a particular validator to the signer list of the multisig contract"
  erc20MultiSigSignerAddedBundles(
    "The node ID of the validator of which a signature bundle is required"
    nodeId: ID!
    "The ethereum address of the submitter"
    submitter: String
    "The epoch that generated the bundle i.e the epoch in which the node was promoted to tendermint validator"
    epochSeq: String
    "Pagination"
    pagination: Pagination
  ): ERC20MultiSigSignerAddedConnection!

  "Get the signatures bundle to remove a particular validator from signer list of the multisig contract"
  erc20MultiSigSignerRemovedBundles(
    "The node ID of the validator of which a signature bundle is required"
    nodeId: ID!
    "The ethereum address of the validator that will submit the bundle"
    submitter: String
    "The epoch that generated the bundle i.e the epoch in which the node was demoted from a tendermint validator"
    epochSeq: String
    "Pagination"
    pagination: Pagination
  ): ERC20MultiSigSignerRemovedConnection!

  "Get the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge"
  erc20SetAssetLimitsBundle(
    "ID of the proposal to update an asset"
    proposalId: ID!
  ): ERC20SetAssetLimitsBundle!

  "Find an erc20 withdrawal approval using its withdrawal ID"
  erc20WithdrawalApproval(
    "ID of the withdrawal"
    withdrawalId: ID!
  ): Erc20WithdrawalApproval

  "Return an estimation of the potential cost for a new order"
  estimateOrder(
    "ID of the market to place the order"
    marketId: ID!
    "ID of the party placing the order"
    partyId: ID!
    "Price of the asset"
    price: String
    "Size of the order"
    size: String!
    "Side of the order (Buy or Sell)"
    side: Side!
    "TimeInForce of the order"
    timeInForce: OrderTimeInForce!
    "RFC3339Nano expiration time of the order"
    expiration: Timestamp
    "Type of the order"
    type: OrderType!
  ): OrderEstimate!
    @deprecated(reason: "Use estimateFees and estimatePosition instead")

  "Return an estimation of the potential cost for a new order"
  estimateFees(
    "ID of the market to place the order on"
    marketId: ID!
    "ID of the party placing the order"
    partyId: ID!
    "Price of the asset"
    price: String
    "Size of the order"
    size: String!
    "Side of the order (buy or sell)"
    side: Side!
    "Time in force of the order"
    timeInForce: OrderTimeInForce!
    "RFC3339Nano expiration time of the order"
    expiration: Timestamp
    "Type of the order"
    type: OrderType!
  ): FeeEstimate!

  "Return a margin range for the specified position and liquidation price range if available collateral is supplied"
  estimatePosition(
    "ID of the market to place the order on"
    marketId: ID!
    "Open volume - negative for short position (int64)"
    openVolume: String!
    "Average entry price corresponding to the open volume. The price is an unsigned integer. For example `123456` is a correctly formatted price of `1.23456` assuming market configured to 5 decimal places"
    averageEntryPrice: String!
    "Open and/or hypothetical orders"
    orders: [OrderInfo!]
    "Margin account balance. Needs to be provided scaled to asset decimal places"
    marginAccountBalance: String!
    "General account balance. Needs to be provided scaled to asset decimal places"
    generalAccountBalance: String!
    "Order margin account balance. Needs to be provided scaled to asset decimal places"
    orderMarginAccountBalance: String!
    "Margin mode for the party, cross margin or isolated margin"
    marginMode: MarginMode!
    "Margin factor to be used along with isolated margin mode"
    marginFactor: String
    "Optional argument specifying if the estimated position margin increase should be included in available collateral for liquidation price calculation in isolated margin mode."
    includeRequiredPositionMarginInAvailableCollateral: Boolean
    "Optional argument specifying if liquidation price estimates should be scaled to market decimal places, returned in asset decimal places by default"
    scaleLiquidationPriceToMarketDecimals: Boolean
  ): PositionEstimate

  "Query for historic ethereum key rotations"
  ethereumKeyRotations(nodeId: ID): EthereumKeyRotationsConnection!

  "Estimate transfer fee"
  estimateTransferFee(
    "Sender's public key."
    fromAccount: ID!
    "Type of account sent from."
    fromAccountType: AccountType!
    "Receiver's public key."
    toAccount: ID!
    "Amount to be transferred."
    amount: String!
    "Asset ID for the asset used in the transaction."
    assetId: String!
  ): EstimatedTransferFee

  "Get fees statistics"
  feesStats(
    "Optional market ID to filter for. If omitted, asset ID must be provided."
    marketId: ID
    "Optional asset ID to filter for. If omitted, market ID must be provided."
    assetId: ID
    "Optional epoch to filter for. If omitted, the most recent epoch's data is returned."
    epoch: Int
    "Optional party ID to filter for"
    partyId: ID
  ): FeesStats

  "Get fees statistics for a given party"
  feesStatsForParty(
    "Party ID to filter for"
    partyId: ID!
    "Optional asset ID to filter for. If omitted, statistics for each asset are returned."
    assetId: ID
    "Optional epoch to filter from (included). If omitted, `toEpoch` must not be set. If both omitted, the most recent epoch's data is returned."
    fromEpoch: Int
    "Optional epoch to filter to (included). If omitted, the range goes from `fromEpoch` to the most recent epoch."
    toEpoch: Int
  ): [FeesStatsForParty]

  """
  Funding payment for perpetual markets.
  """
  fundingPayments(
    "ID of the party"
    partyId: ID!
    "ID of the perpetual market to get funding periods for"
    marketId: ID
    "Pagination control"
    pagination: Pagination
  ): FundingPaymentConnection!

  "Funding periods for perpetual markets"
  fundingPeriods(
    "ID of the perpetual market to get funding periods for"
    marketId: ID!
    """
    Optional: Date range to retrieve funding periods from/to.
    The funding period start time will be used to determine whether to include the funding period in the results.
    Start and end time should be expressed as an integer value of Unix nanoseconds.
    """
    dateRange: DateRange
    "Pagination control"
    pagination: Pagination
  ): FundingPeriodConnection!

  """
  Funding period data points for a perpetual market. The data points within a funding period are used to calculate the
  time-weighted average price (TWAP), funding rate and funding payments for each funding period.
  """
  fundingPeriodDataPoints(
    "ID of the perpetual market to get funding periods for"
    marketId: ID!
    """
    Optional date range to filter funding period data points from/to.
    The funding period's start date will be used to determine if the funding period's data points should be included in the results.
    Start and end time should be expressed as an integer value of Unix nanoseconds.
    """
    dateRange: DateRange
    "Optional filter to only return data points from a specific data source. If omitted, no filtering is applied."
    source: FundingPeriodDataPointSource
    "Pagination control"
    pagination: Pagination
  ): FundingPeriodDataPointConnection!

  "Get a list of games and their metrics."
  games(
    "Optional game ID to filter for"
    gameId: ID
    "Start epoch to return the results from (inclusive), if not provided the most recent epoch will be used."
    epochFrom: Int
    "End epoch to return the results to (inclusive), if not provided the most recent epoch will be used."
    epochTo: Int
    "Entity scope to filter for, i.e. individual or team. If not provided games for both individuals and teams will be returned."
    entityScope: EntityScope
    "Team ID to filter for. This filter will only be applied if entity scope is not specified in the request, or the entity scope is set to teams."
    teamId: ID
    "Party ID to filter for. This filter will apply regardless of the entity scope. If the entity scope filter is teams, then the party ID filter will apply to team members."
    partyId: ID
    "Pagination control"
    pagination: Pagination
  ): GamesConnection!

  "Get market data history for a specific market. If no dates are given, the latest snapshot will be returned. If only the start date is provided all history from the given date will be provided, and if only the end date is provided, all history from the start up to and including the end date will be provided."
  getMarketDataHistoryConnectionByID(
    id: ID!
    """
    Optional RFC3339Nano start date time for the historic data query.
    If both the start and end date is not provided, only the latest snapshot will be returned.
    If only the start date is provided, all market data for the market from the start date forward will be returned.
    """
    start: Timestamp
    """
    Optional RFC3339Nano end date time for the historic data query.
    If both the start and end date is not provided, only the latest snapshot will be returned.
    If only the end date is provided, all market data for the market up to and including the end date will be returned.
    """
    end: Timestamp
    "Optional Pagination"
    pagination: Pagination
  ): MarketDataConnection

  "Query for historic key rotations"
  keyRotationsConnection(id: ID, pagination: Pagination): KeyRotationConnection!

  """
  Get a list of ledger entries within the given date range. The date range is restricted to a maximum of 5 days.
  This query requests and sums the number of ledger entries from a given subset of accounts, specified via the 'filter' argument.
  It returns a time series - implemented as a list of AggregateLedgerEntry structs - with a row for every time
  the summed ledger entries of the set of specified accounts changes.
  Each account filter must contain no more than one party ID.
  At least one party ID must be specified in the from or to account filter.

  Entries can be filtered by:
  - the sending account (market ID, asset ID, account type)
  - receiving account (market ID, asset ID, account type)
  - sending AND receiving account
  - transfer type either in addition to the above filters or as a standalone option

  Note: The date range is restricted to any 5 days.
  If no start or end date is provided, only ledger entries from the last 5 days will be returned.
  If a start and end date are provided, but the end date is more than 5 days after the start date, only data up to 5 days after the start date will be returned.
  If a start date is provided but no end date, the end date will be set to 5 days after the start date.
  If no start date is provided, but the end date is, the start date will be set to 5 days before the end date.
  """
  ledgerEntries(
    "Filter to apply when querying the ledger. At least one party in the 'from' account filter, or 'to' account filter must be provided."
    filter: LedgerEntryFilter
    """
    Date range filter to apply to the ledger entries.
    """
    dateRange: DateRange
    "Optional pagination control"
    pagination: Pagination
  ): AggregatedLedgerEntriesConnection!

  "List all active liquidity providers for a specific market"
  liquidityProviders(
    "Party ID of the liquidity provider"
    partyId: ID
    "Market ID to retrieve liquidity providers for"
    marketId: ID
    "Optional Pagination"
    pagination: Pagination
  ): LiquidityProviderConnection

  "The last block process by the blockchain"
  lastBlockHeight: String!

  "An instrument that is trading on the Vega network"
  market("Optional ID of a market" id: ID!): Market

  "One or more instruments that are trading on the Vega network"
  marketsConnection(
    "Optional ID of a market"
    id: ID
    "Optional pagination information"
    pagination: Pagination
    "Whether to include markets that have settled (defaults to true)"
    includeSettled: Boolean
  ): MarketConnection

  "The most recent history segment"
  mostRecentHistorySegment: HistorySegment!

  "Current network limits"
  networkLimits: NetworkLimits

  "Return a single network parameter"
  networkParameter(
    "key of the network parameter"
    key: String!
  ): NetworkParameter

  "Return the full list of network parameters"
  networkParametersConnection(
    pagination: Pagination
  ): NetworkParametersConnection!

  "Specific node in network"
  node("required ID of node" id: ID!): Node

  "Returns information about nodes"
  nodeData: NodeData

  "All known network nodes"
  nodesConnection(pagination: Pagination): NodesConnection!

  "Return a list of aggregated node signature for a given resource ID"
  nodeSignaturesConnection(
    resourceId: ID!
    pagination: Pagination
  ): NodeSignaturesConnection

  "All oracle data for a given oracle spec ID"
  oracleDataBySpecConnection(
    "ID for an oracle spec"
    oracleSpecId: ID!
    "Pagination"
    pagination: Pagination
  ): OracleDataConnection

  "All registered oracle specs"
  oracleDataConnection(
    "Pagination"
    pagination: Pagination
  ): OracleDataConnection

  "An oracle spec for a given oracle spec ID"
  oracleSpec("ID for an oracle spec" oracleSpecId: ID!): OracleSpec

  "All registered oracle specs"
  oracleSpecsConnection(
    "Pagination"
    pagination: Pagination
  ): OracleSpecsConnection

  "An order in the Vega network found by orderID"
  orderByID(
    "ID for an order"
    id: ID!

    "Order version number, starting at 1 for the original order and incrementing by 1 for each successful amendment; omitted for the most recent version."
    version: Int
  ): Order!

  "An order in the Vega network found by referenceID"
  orderByReference("Reference for an order" reference: String!): Order!

  "Order versions (created via amendments if any) found by orderID"
  orderVersionsConnection(
    "ID for an order"
    orderId: ID
    "Pagination information"
    pagination: Pagination
  ): OrderConnection

  "List statistics about paid liquidity fees"
  paidLiquidityFees(
    "Optional market ID to filter for."
    marketId: ID
    "Optional asset ID to filter for."
    assetId: ID
    "Optional epoch to filter for. If omitted, the most recent epoch's data is returned."
    epoch: Int
    "Optional party IDs to filter for"
    partyIDs: [String!]
  ): PaidLiquidityFeesConnection

  "One or more entities that are trading on the Vega network"
  partiesConnection(
    "Optional ID of a party to retrieve"
    id: ID
    "Optional pagination information"
    pagination: Pagination
  ): PartyConnection

  "List parties' profiles by their IDs. If no ID is set, all profiles are returned."
  partiesProfilesConnection(
    "Restrict the returned parties' profiles to only the given party IDs. If not set, all profiles will be returned."
    ids: [ID!]
    "Optional pagination information"
    pagination: Pagination
  ): PartiesProfilesConnection

  "An entity that is trading on the Vega network"
  party("ID of a party" id: ID!): Party

  "Fetch all positions"
  positions(filter: PositionsFilter, pagination: Pagination): PositionConnection

  "A governance proposal located by either its ID or reference. If both are set, ID is used."
  proposal(
    "Optionally, locate proposal by its ID"
    id: ID
    "Optionally, locate proposal by its reference. If ID is set, this parameter is ignored."
    reference: String
  ): ProposalNode

  "All governance proposals in the Vega network"
  proposalsConnection(
    "Optional type of proposal to retrieve data for"
    proposalType: ProposalType
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
    "Optional Pagination information"
    pagination: Pagination
  ): ProposalsConnection

  "Flag indicating whether the data-node is ready to begin the protocol upgrade"
  protocolUpgradeStatus: ProtocolUpgradeStatus

  "List protocol upgrade proposals, optionally filtering on status or approver"
  protocolUpgradeProposals(
    inState: ProtocolUpgradeProposalStatus
    approvedBy: String
    pagination: Pagination
  ): ProtocolUpgradeProposalConnection

  "List referral sets"
  referralSets(
    "Optional referral set ID to fetch information for"
    id: ID
    "Optional referrer party ID to filter for. If referral set ID is provided, this parameter is ignored."
    referrer: ID
    "Optional referee party ID to filter for. If referral set ID, or referrer is provided, this parameter is ignored."
    referee: ID
    "Optional pagination information"
    pagination: Pagination
  ): ReferralSetConnection!

  referralSetReferees(
    "Optional referral set ID to fetch referees for"
    id: ID
    "Optional referrer party ID to filter for. If referral set ID is provided, this parameter is ignored."
    referrer: ID
    "Optional referee party ID to filter for. If referral set ID, or referrer is provided, this parameter is ignored."
    referee: ID
    "Optional pagination information"
    pagination: Pagination
    "Optional number of epochs to aggregate referee volume and reward statistics for. If omitted, the default is 30 epochs."
    aggregationEpochs: Int
  ): ReferralSetRefereeConnection!

  "Get referral set statistics"
  referralSetStats(
    "Optional referral set ID to fetch stats for"
    setId: ID
    "Optional epoch to get statistics from. If not provided, the latest statistics are returned"
    epoch: Int
    "Optional party ID. If not provided all parties for the epoch are returned"
    partyId: ID
    "Optional pagination information"
    pagination: Pagination
  ): ReferralSetStatsConnection!

  "Get statistics about the Vega node"
  statistics: Statistics!

  "Get stop order by ID"
  stopOrder(id: ID!): StopOrder

  "Get a list of stop orders. If provided, the filter will be applied to the list of stop orders to restrict the results."
  stopOrders(
    "Optional filter to restrict the results of the list."
    filter: StopOrderFilter
    "Optional pagination information"
    pagination: Pagination
  ): StopOrderConnection

  "List markets in a succession line"
  successorMarkets(
    "Market ID of any market in the succession line"
    marketId: ID!
    """
    Flag indicating whether to include the full succession line or not.
    If not specified, the default is false.
    When false, only the requested market and its children are returned.
    """
    fullHistory: Boolean
    "Optional pagination information"
    pagination: Pagination
  ): SuccessorMarketConnection

  """
  List information about all teams or filter for a specific team ID or referrer, or referee's party ID
  If no filter is provided all teams will be listed.
  If a team ID is provided, only the team with that ID will be returned
  If a party ID is provided, the team whose referrer party ID or a referee's party ID matches will be return
  If both team ID and party ID is provided, only the team ID will be used.
  """
  teams(
    "Optional team ID to filter for"
    teamId: ID
    "Optional referrer, or team referee to filter for"
    partyId: ID
    "Optional pagination information"
    pagination: Pagination
  ): TeamConnection

  """
  List teams statistics
  Get the statistics of all teams, or for a specific team by using team ID, over a number of epochs.
  If a team does not have at least the number of epochs worth of data, it is ignored.
  """
  teamsStatistics(
    "Optional team ID to filter for"
    teamId: ID
    "Optional number of epochs to aggregate referee volume and reward statistics for. If omitted, the default is 10 epochs."
    aggregationEpochs: Int
    "Optional pagination information"
    pagination: Pagination
  ): TeamsStatisticsConnection

  """
  List team members' statistics for a given team
  Get the statistics of all team members for a given team ID, or for a specific member by using party ID, over a number of epochs.
  If a team does not have at least the number of epochs worth of data, it is ignored.
  """
  teamMembersStatistics(
    "Team ID to filter for"
    teamId: ID!
    "Optional party ID to filter for"
    partyId: ID
    "Optional number of epochs to aggregate referee volume and reward statistics for. If omitted, the default is 10 epochs."
    aggregationEpochs: Int
    "Optional pagination information"
    pagination: Pagination
  ): TeamMembersStatisticsConnection

  "List all referees for a team"
  teamReferees(
    "ID of the team to list referees for"
    teamId: ID!
    "Optional pagination information"
    pagination: Pagination
  ): TeamRefereeConnection

  "List a referee's team history"
  teamRefereeHistory(
    "ID of the referee to list team history for"
    referee: ID!
    "Optional pagination information"
    pagination: Pagination
  ): TeamRefereeHistoryConnection

  "Time weighted notional position is a metric used to determine if a reward should be paid to a party"
  timeWeightedNotionalPosition(
    "Settlement asset for the position"
    assetId: ID!
    "Party holding the position"
    partyId: ID!
    "Game to filter for"
    gameId: ID!
    "Optional epoch to filter for. If no epoch is specified, the time weighted notional position from the end of the most recently completed epoch is returned."
    epochSeq: Int
  ): TimeWeightedNotionalPosition

  "Get total transfer fee discount available"
  totalTransferFeeDiscount(
    "ID of party eligible for the discount."
    partyId: String!
    "ID of the asset that the discount relates to."
    assetId: String!
  ): TotalTransferFeeDiscount

  "Get a list of all trades and apply any given filters to the results"
  trades(
    filter: TradesFilter
    "Optional Pagination information"
    pagination: Pagination
    "Date range to fetch trades between"
    dateRange: DateRange
  ): TradeConnection

  "Get a list of all transfers for a public key"
  transfersConnection(
    "The public key to look for"
    partyId: ID
    "Direction of the transfer with respect to the public key"
    direction: TransferDirection
    "Pagination information"
    pagination: Pagination
    "Filter for reward transfers only. Direction must be 'From' if a public key is used"
    isReward: Boolean
    "Optional epoch to filter from (included). If omitted, the range goes from the oldest epoch to the `to epoch`."
    fromEpoch: Int
    "Optional epoch to filter to (included). If omitted, the range goes from `from epoch` to the most recent epoch."
    toEpoch: Int
    "Optional status to filter on."
    status: TransferStatus
    "Optional dispatch strategy's scope to filter for."
    scope: TransferScope
    "Optional game ID to filter for"
    gameId: ID
    "Optional from account type to filter for"
    fromAccountType: AccountType
    "Optional to account type to filter for"
    toAccountType: AccountType
  ): TransferConnection

  "Find a transfer using its ID"
  transfer("ID of the transfer" id: ID!): TransferNode

  "Get volume discount statistics"
  volumeDiscountStats(
    "Optional epoch to get statistics from. If not provided, the latest statistics are returned"
    epoch: Int
    "Optional party ID"
    partyId: ID
    "Optional pagination information"
    pagination: Pagination
  ): VolumeDiscountStatsConnection!

  "Find a withdrawal using its ID"
  withdrawal("ID of the withdrawal" id: ID!): Withdrawal

  "Fetch all withdrawals"
  withdrawals(
    "Date range to fetch withdrawals between"
    dateRange: DateRange
    "Pagination options"
    pagination: Pagination
  ): WithdrawalsConnection

  """
  List margin modes per party per market

  Get a list of all margin modes, or for a specific market ID, or party ID.
  """
  partyMarginModes(
    "Optional team ID to filter for"
    marketId: ID
    "Optional referrer, or team referee to filter for"
    partyId: ID
    "Optional pagination information"
    pagination: Pagination
  ): PartyMarginModesConnection
}

"Defines the types of a dispatch strategy's scope the API can filter on."
enum TransferScope {
  "Matches transfers that have dispatch strategy scope of individual set."
  SCOPE_INDIVIDUAL
  "Matches transfers that have dispatch strategy scope of team set."
  SCOPE_TEAM
}

"All the states a transfer can transition between"
enum TransferStatus {
  "Indicates a transfer still being processed"
  STATUS_PENDING
  "Indicates a transfer accepted by the Vega network"
  STATUS_DONE
  "Indicates a transfer rejected by the Vega network"
  STATUS_REJECTED
  """
  Indicates a transfer stopped by the Vega network
  e.g: no funds left to cover the transfer
  """
  STATUS_STOPPED
  "Indication of a transfer cancelled by the user"
  STATUS_CANCELLED
}

"A user initiated transfer"
type Transfer {
  "ID of this transfer"
  id: ID!

  "The public key of the sender in this transfer"
  from: String!

  "The account type from which funds have been sent"
  fromAccountType: AccountType!

  "The public key of the recipient of the funds"
  to: String!

  "The account type that has received the funds"
  toAccountType: AccountType!

  "The asset"
  asset: Asset

  "The amount sent"
  amount: String!

  "An optional reference"
  reference: String

  "The status of this transfer"
  status: TransferStatus!

  "The RFC3339Nano time at which the transfer was submitted"
  timestamp: Timestamp!

  "The type of transfer being made, i.e. a one-off or recurring transfer"
  kind: TransferKind!

  "An optional reason explaining the status of the transfer"
  reason: String

  "An optional game ID to filter for transfers that are made for rewarding participation in games"
  gameId: ID
}

union TransferKind =
    OneOffTransfer
  | RecurringTransfer
  | OneOffGovernanceTransfer
  | RecurringGovernanceTransfer

"The specific details for a one-off governance transfer"
type OneOffGovernanceTransfer {
  "An optional RFC3339Nano time when the transfer should be delivered"
  deliverOn: Timestamp
}

"The specific details for a recurring governance transfer"
type RecurringGovernanceTransfer {
  "The epoch at which this recurring transfer will start"
  startEpoch: Int!
  "An optional epoch at which this transfer will stop"
  endEpoch: Int
  "An optional dispatch strategy for the recurring transfer"
  dispatchStrategy: DispatchStrategy
}

"The specific details for a one-off transfer"
type OneOffTransfer {
  "An optional RFC3339Nano time when the transfer should be delivered"
  deliverOn: Timestamp
}

"The specific details for a recurring transfer"
type RecurringTransfer {
  "The epoch at which this recurring transfer will start"
  startEpoch: Int!
  "An optional epoch at which this transfer will stop"
  endEpoch: Int
  "The factor of the initial amount to be distributed"
  factor: String!
  "An optional dispatch strategy for the recurring transfer"
  dispatchStrategy: DispatchStrategy
}

"The type of metric to use for a reward dispatch strategy"
enum DispatchMetric {
  "Dispatch metric that uses the total maker fees paid in the market"
  DISPATCH_METRIC_MAKER_FEES_PAID
  "Dispatch metric that uses the total maker fees received in the market"
  DISPATCH_METRIC_MAKER_FEES_RECEIVED
  "Dispatch metric that uses the total LP fees received in the market"
  DISPATCH_METRIC_LP_FEES_RECEIVED
  "Dispatch metric that uses the total value of the market if above the required threshold and not paid given proposer bonus yet"
  DISPATCH_METRIC_MARKET_VALUE
  "Dispatch metric that uses the time weighted position of the party in the market"
  DISPATCH_METRIC_AVERAGE_POSITION
  "Dispatch metric that uses the relative PNL of the party in the market"
  DISPATCH_METRIC_RELATIVE_RETURN
  "Dispatch metric that uses return volatility of the party in the market"
  DISPATCH_METRIC_RETURN_VOLATILITY
  "Dispatch metric that uses the validator ranking of the validator as metric"
  DISPATCH_METRIC_VALIDATOR_RANKING
}

enum EntityScope {
  "Rewards must be distributed directly to eligible parties"
  ENTITY_SCOPE_INDIVIDUALS
  "Rewards must be distributed directly to eligible teams, and then amongst team members"
  ENTITY_SCOPE_TEAMS
}

enum IndividualScope {
  "All parties on the network are within the scope of this reward"
  INDIVIDUAL_SCOPE_ALL
  "All parties that are part of a team are within the scope of this reward"
  INDIVIDUAL_SCOPE_IN_TEAM
  "All parties that are not part of a team are within the scope of this reward"
  INDIVIDUAL_SCOPE_NOT_IN_TEAM
}

enum DistributionStrategy {
  "Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric scaled by any active multipliers that party has"
  DISTRIBUTION_STRATEGY_PRO_RATA
  "Rewards funded using the rank strategy"
  DISTRIBUTION_STRATEGY_RANK
}

"Dispatch strategy for a recurring transfer"
type DispatchStrategy {
  "Defines the data that will be used to compare markets so as to distribute rewards appropriately"
  dispatchMetric: DispatchMetric!

  "The asset to use for measuring contribution to the metric"
  dispatchMetricAssetId: ID!

  "Scope the dispatch to this market only under the metric asset"
  marketIdsInScope: [ID!]

  "The type of entities eligible for this strategy"
  entityScope: EntityScope!

  "If entity scope is individuals then this defines the scope for individuals"
  individualScope: IndividualScope

  "The teams in scope for the reward, if the entity is teams"
  teamScope: [ID]

  "The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if scope is team"
  nTopPerformers: String

  "Minimum number of governance tokens, e.g. VEGA, staked for a party to be considered eligible"
  stakingRequirement: String!

  "Minimum notional time-weighted averaged position required for a party to be considered eligible"
  notionalTimeWeightedAveragePositionRequirement: String!

  "Number of epochs to evaluate the metric on"
  windowLength: Int!

  "Number of epochs after distribution to delay vesting of rewards by"
  lockPeriod: Int!

  "Controls how the reward is distributed between qualifying parties"
  distributionStrategy: DistributionStrategy!

  "Ascending order list of start rank and corresponding share ratio"
  rankTable: [RankTable]

  "Optional multiplier on taker fees used to cap the rewards a party may receive in an epoch"
  capRewardFeeMultiple: String
}

type RankTable {
  startRank: Int!
  shareRatio: Int!
}

"Validating status of a node, i.e. validator or non-validator"
enum NodeStatus {
  "The node is non-validating"
  NODE_STATUS_NON_VALIDATOR

  "The node is validating"
  NODE_STATUS_VALIDATOR
}

"Describes in both human readable and block time when an epoch spans."
type EpochTimestamps {
  "RFC3339 timestamp - Vega time of epoch start, null if not started"
  start: Timestamp
  "RFC3339 timestamp - Vega time of epoch expiry"
  expiry: Timestamp
  "RFC3339 timestamp - Vega time of epoch end, null if not ended"
  end: Timestamp
  "Height of first block in the epoch, null if not started"
  firstBlock: String!
  "Height of last block in the epoch, null if not ended"
  lastBlock: String
}

"A node's key rotation event"
type KeyRotation {
  "ID of node where rotation took place"
  nodeId: ID!
  "Old public key rotated from"
  oldPubKey: String!
  "New public key rotated to"
  newPubKey: String!
  "Block height when the rotation took place"
  blockHeight: String!
}

"An Ethereum key rotation record that is returned in a paginated Ethereum key rotation connection"
type EthereumKeyRotationEdge {
  node: EthereumKeyRotation!
  cursor: String
}

"A paginated type for returning Ethereum key rotation records"
type EthereumKeyRotationsConnection {
  "The ethereum key rotations in this connection"
  edges: [EthereumKeyRotationEdge!]!
  "The pagination information"
  pageInfo: PageInfo
}

"Describes the ethereum key rotations of nodes on the vega network"
type EthereumKeyRotation {
  "ID of node where rotation took place"
  nodeId: ID!
  "Old ethereum address"
  oldAddress: String!
  "New ethereum address"
  newAddress: String!
  "Block height when the rotation took place"
  blockHeight: String!
}

"Epoch describes a specific period of time in the Vega network"
type Epoch {
  "Numeric sequence number used to identify the epoch"
  id: ID!

  "Timestamps for start and end of epochs"
  timestamps: EpochTimestamps!

  "Validators that participated in this epoch"
  validatorsConnection(pagination: Pagination): NodesConnection

  "Delegations data for this epoch"
  delegationsConnection(
    "Optional party ID to filter on"
    partyId: ID
    "Optional node ID to filter on"
    nodeId: ID
    "Pagination information"
    pagination: Pagination
  ): DelegationsConnection
}

"Details on the collection of nodes for particular validator status"
type NodeSet {
  "Total number of nodes in the node set"
  total: Int!

  "Number of nodes in the node set that had a performance score of 0 at the end of the last epoch"
  inactive: Int!

  "IDs of the nodes that were promoted into this node set at the start of the epoch"
  promoted: [String!]

  "IDs of the nodes that were demoted into this node set at the start of the epoch"
  demoted: [String!]

  "Total number of nodes allowed in the node set"
  maximum: Int
}

"Summary of data across all nodes"
type NodeData {
  "Total staked amount across all nodes"
  stakedTotal: String!

  "Total number of nodes across all node sets"
  totalNodes: Int!

  "Total number of nodes that had a performance score of 0 at the end of the last epoch"
  inactiveNodes: Int!

  "Details on the set of consensus nodes in the network"
  tendermintNodes: NodeSet!

  "Details on the set of ersatz (standby) nodes in the network"
  ersatzNodes: NodeSet

  "Details on the set of pending nodes in the network"
  pendingNodes: NodeSet

  # @TODO allow to query based on number of epochs uptime(epochs: Int)
  "Total uptime for all epochs across all nodes. Or specify a number of epochs"
  uptime: Float!
}

"Summary of a node's rewards for a given epoch"
type EpochParticipation {
  epoch: Epoch

  "RFC3339 timestamp"
  offline: Timestamp

  "RFC3339 timestamp"
  online: Timestamp

  "Total amount rewarded for participation in the given epoch"
  totalRewards: Float
}

"Summary of all epochs for a node"
type EpochData {
  "Total number of epochs since node was created"
  total: Int!

  "Total number of offline epochs since node was created"
  offline: Int!

  "Total number of online epochs since node was created"
  online: Int!
}

"Information available for a node"
type Node {
  "The node URL eg n01.vega.xyz"
  id: ID!

  "Public key of the node operator"
  pubkey: String!

  "Tendermint public key of the node"
  tmPubkey: String!

  "Ethereum public key of the node"
  ethereumAddress: String!

  "URL from which you can get more info about the node."
  infoUrl: String!

  "Country code for the location of the node"
  location: String!

  "The amount of stake the node has put up themselves"
  stakedByOperator: String!

  "The amount of stake that has been delegated by token holders"
  stakedByDelegates: String!

  "Total amount staked on node"
  stakedTotal: String!

  # "Max amount of (wanted) stake, is this a network param or a node param"
  # @TODO - add this field
  # maxIntendedStake: String!

  "Amount of stake on the next epoch"
  pendingStake: String!

  "Summary of epoch data across all nodes"
  epochData: EpochData

  # @TODO implement this filter
  # epochs(last: Int, since: String): [EpochParticipation!]!

  "Validator status of the node"
  status: NodeStatus!

  "All delegation for a node by a given party if specified, or all delegations."
  delegationsConnection(
    partyId: ID
    pagination: Pagination
  ): DelegationsConnection

  "Reward scores for the current epoch for the validator"
  rewardScore: RewardScore

  "Ranking scores and status for the validator for the current epoch"
  rankingScore: RankingScore!
  # The name of the node
  name: String!

  # The URL of an avatar
  avatarUrl: String
}

type NodeBasic {
  "The node URL, for example n01.vega.xyz"
  id: ID!
  "Public key of the node operator"
  pubkey: String!
  "Tendermint public key of the node"
  tmPubkey: String!
  "Ethereum public key of the node"
  ethereumAddress: String!
  "URL that provides more information about the node"
  infoUrl: String!
  "Country code for the location of the node"
  location: String!
  "Validator status of the node"
  status: NodeStatus!
  "The name of the node operator"
  name: String!
  "The URL of an avatar"
  avatarUrl: String
}

type RewardScore {
  "The stake based validator score with anti-whaling"
  rawValidatorScore: String!
  "The performance score of the validator"
  performanceScore: String!
  "The multisig score of the validator"
  multisigScore: String!
  "The composite score of the validator"
  validatorScore: String!
  "The normalised score of the validator"
  normalisedScore: String!
  "The status of the validator for this score"
  validatorStatus: ValidatorStatus!
}

type RankingScore {
  "The current validation status of the validator"
  status: ValidatorStatus!
  "The former validation status of the validator"
  previousStatus: ValidatorStatus!
  "The ranking score of the validator"
  rankingScore: String!
  "The stake based score of the validator (no anti-whaling)"
  stakeScore: String!
  "The performance score of the validator"
  performanceScore: String!
  "The Tendermint voting power of the validator (uint32)"
  votingPower: String!
}

"Status of a validator node"
enum ValidatorStatus {
  "The node is taking part in Tendermint consensus"
  VALIDATOR_NODE_STATUS_TENDERMINT
  "The node is a candidate to become a Tendermint validator if a slot is made available"
  VALIDATOR_NODE_STATUS_ERSATZ
  "The node is pending promotion to ersatz (standby), if a slot is available and if the node fulfils the requirements"
  VALIDATOR_NODE_STATUS_PENDING
}

type Delegation {
  "Amount delegated"
  amount: String!

  "Party that is delegating"
  party: Party!

  "URL of node you are delegating to"
  node: Node!

  "Epoch of delegation"
  epoch: Int!
}

"Status of an asset that has been proposed to be added to the network"
enum AssetStatus {
  "Asset is proposed to be added to the network"
  STATUS_PROPOSED
  "Asset has been rejected"
  STATUS_REJECTED
  "Asset is pending listing on the ethereum bridge"
  STATUS_PENDING_LISTING
  "Asset can be used on the Vega network"
  STATUS_ENABLED
}

"Represents an asset in Vega"
type Asset {
  "The ID of the asset"
  id: ID!

  "The full name of the asset (e.g: Great British Pound)"
  name: String!

  "The symbol of the asset (e.g: GBP)"
  symbol: String!

  "The precision of the asset. Should match the decimal precision of the asset on its native chain, e.g: for ERC20 assets, it is often 18"
  decimals: Int!

  "The minimum economically meaningful amount in the asset"
  quantum: String!

  "The origin source of the asset (e.g: an ERC20 asset)"
  source: AssetSource!

  "The status of the asset in the Vega network"
  status: AssetStatus!

  "The infrastructure fee account for this asset"
  infrastructureFeeAccount: AccountBalance

  "The staking reward pool account for this asset"
  globalRewardPoolAccount: AccountBalance

  "The global insurance account for this asset"
  globalInsuranceAccount: AccountBalance
  "The network treasury account for this asset"
  networkTreasuryAccount: AccountBalance
  "The taker fee reward account for this asset"
  takerFeeRewardAccount: AccountBalance
  "The maker fee reward account for this asset"
  makerFeeRewardAccount: AccountBalance
  "The liquidity provision reward account for this asset"
  lpFeeRewardAccount: AccountBalance
  "The market proposer reward account for this asset"
  marketProposerRewardAccount: AccountBalance
}

"One of the possible asset sources"
union AssetSource = BuiltinAsset | ERC20

"One of the possible asset sources for update assets proposals"
union UpdateAssetSource = UpdateERC20

"An asset originated from an Ethereum ERC20 Token"
type ERC20 {
  "The address of the ERC20 contract"
  contractAddress: String!
  """
  The lifetime limits deposit per address
  Note: this is a temporary measure that can be changed by governance
  """
  lifetimeLimit: String!
  """
  The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
  There is no limit on the size of a withdrawal
  Note: this is a temporary measure that can be changed by governance
  """
  withdrawThreshold: String!
}

"An asset originated from an Ethereum ERC20 Token"
type UpdateERC20 {
  """
  The lifetime limits deposit per address
  Note: this is a temporary measure that can be changed by governance
  """
  lifetimeLimit: String!
  """
  The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
  There is no limit on the size of a withdrawal
  Note: this is a temporary measure that can be changed by governance
  """
  withdrawThreshold: String!
}

"A Vega builtin asset, mostly for testing purpose"
type BuiltinAsset {
  "Maximum amount that can be requested by a party through the built-in asset faucet at a time"
  maxFaucetAmountMint: String!
}

"Represents a signature for the approval of a resource from a validator"
type NodeSignature {
  "The ID of the resource being signed for"
  id: ID!

  "The signature, as base64 encoding"
  signature: String

  "The kind of signature this is (e.g: withdrawal, new asset, etc)"
  kind: NodeSignatureKind
}

"Represents the type of signature provided by a node"
enum NodeSignatureKind {
  "A signature for proposing a new asset into the network"
  NODE_SIGNATURE_KIND_ASSET_NEW

  "A signature for allowing funds withdrawal"
  NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL

  "A signature to add a new validator to the ERC20 bridge"
  NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED

  "A signature to remove a validator from the ERC20 bridge"
  NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED

  "A signature to update limits of an ERC20 asset"
  NODE_SIGNATURE_KIND_ASSET_UPDATE
}

"Statistics about the node"
type Statistics {
  "Current block number"
  blockHeight: String!

  "Current block hash"
  blockHash: String!

  "Number of items in the backlog"
  backlogLength: String!

  "Total number of peers on the Vega network"
  totalPeers: String!

  "RFC3339Nano genesis time of the chain"
  genesisTime: Timestamp!

  "RFC3339Nano current time (real)"
  currentTime: Timestamp!

  "RFC3339Nano uptime of the node"
  upTime: String!

  "RFC3339Nano current time of the chain (decided through consensus)"
  vegaTime: Timestamp!

  "Status of the Vega application connection with the chain"
  status: String!

  "Number of transaction processed per block"
  txPerBlock: String!

  "Average size of the transactions"
  averageTxBytes: String!

  "Average number of orders added per blocks"
  averageOrdersPerBlock: String!

  "Number of the trades per seconds"
  tradesPerSecond: String!

  "Number of orders per seconds"
  ordersPerSecond: String!

  "Total number of markets"
  totalMarkets: String!

  "Total number of amended orders"
  totalAmendOrder: String!

  "Total number of cancelled orders"
  totalCancelOrder: String!

  "Total number of orders created"
  totalCreateOrder: String!

  "Total number of orders"
  totalOrders: String!

  "Total number of trades"
  totalTrades: String!

  "Total number of events on the last block"
  eventCount: String!

  "The number of events per second on the last block"
  eventsPerSecond: String!

  "Version commit hash of the Vega node"
  appVersionHash: String!

  "Version of the Vega node (semver)"
  appVersion: String!

  "Version of the chain (semver)"
  chainVersion: String!

  "Duration of the last block, in nanoseconds"
  blockDuration: String!

  "Current chain ID"
  chainId: ID!
}

"A mode where Vega tries to execute orders as soon as they are received"
type ContinuousTrading {
  "Size of an increment in price in terms of the quote currency"
  tickSize: String!
}

"Frequent batch auctions trading mode"
type DiscreteTrading {
  "Duration of the discrete trading batch in nanoseconds. Maximum 1 month."
  duration: Int!
  "Size of an increment in price in terms of the quote currency"
  tickSize: String!
}

"Parameters for the log normal risk model"
type LogNormalModelParams {
  "Mu parameter, annualised growth rate of the underlying asset"
  mu: Float!
  "R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number"
  r: Float!
  "Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number"
  sigma: Float!
}

"Parameters for the simple risk model"
type SimpleRiskModelParams {
  "Risk factor for long"
  factorLong: Float!
  "Risk factor for short"
  factorShort: Float!
}

"A type of risk model for futures trading"
type LogNormalRiskModel {
  "Lambda parameter of the risk model, probability confidence level used in expected shortfall calculation when obtaining the maintenance margin level, must be strictly greater than 0 and strictly smaller than 1"
  riskAversionParameter: Float!
  "Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall calculation to obtain the maintenance margin, must be a strictly non-negative real number"
  tau: Float!
  "Parameters for the log normal risk model"
  params: LogNormalModelParams!
}

"A type of simple/dummy risk model where you can specify the risk factor long and short in params"
type SimpleRiskModel {
  "Params for the simple risk model"
  params: SimpleRiskModelParams!
}

union RiskModel = LogNormalRiskModel | SimpleRiskModel

"A set of metadata to associate to an instrument"
type InstrumentMetadata {
  "An arbitrary list of tags to associated to associate to the Instrument (string list)"
  tags: [String!]
}

"An Ethereum data source"
type EthereumEvent {
  "The ID of the ethereum contract to use (string)"
  contractId: ID!

  "Name of the Ethereum event to listen to. (string)"
  event: String!
}

union Oracle = EthereumEvent

"A Future product"
type Future {
  "The name of the asset (string)"
  settlementAsset: Asset!

  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!

  "The data source specification that describes the data of interest for settlement."
  dataSourceSpecForSettlementData: DataSourceSpec!

  "The data source specification that describes the data-source data of interest for trading termination."
  dataSourceSpecForTradingTermination: DataSourceSpec!

  "The binding between the data source specification and the settlement data"
  dataSourceSpecBinding: DataSourceSpecToFutureBinding!
}

"Spot FX product"
type Spot {
  "Underlying base asset for the spot product"
  baseAsset: Asset!
  "Underlying quote asset for the spot product"
  quoteAsset: Asset!
  "Name of the instrument"
  name: String!
}

"Perpetual future product"
type Perpetual {
  "Underlying asset for the perpetual instrument"
  settlementAsset: Asset!
  "Quote name of the instrument"
  quoteName: String!
  "Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]"
  marginFundingFactor: String!
  "Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]"
  interestRate: String!
  "Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]"
  clampLowerBound: String!
  "Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]"
  clampUpperBound: String!
  "Data source specification describing the data source for settlement schedule"
  dataSourceSpecForSettlementSchedule: DataSourceSpec!
  "Data source specification describing the data source for settlement"
  dataSourceSpecForSettlementData: DataSourceSpec!
  "Binding between the data source spec and the settlement data"
  dataSourceSpecBinding: DataSourceSpecPerpetualBinding!
  "Factor applied to funding-rates. This scales the impact that spot price deviations have on funding payments"
  fundingRateScalingFactor: String
  "Lower bound for the funding-rate such that the funding-rate will never be lower than this value"
  fundingRateLowerBound: String
  "Upper bound for the funding-rate such that the funding-rate will never be higher than this value"
  fundingRateUpperBound: String
  "Optional configuration driving the internal composite price calculation for perpetual product"
  internalCompositePriceConfig: CompositePriceConfiguration
}

"""
Bindings to describe which property of the data source data is to be used as settlement data
and which is to be used as the trading termination trigger.
"""
type DataSourceSpecPerpetualBinding {
  """
  Name of the property in the source data that should be used as settlement data.
  For example, if it is set to "prices.BTC.value", then the perpetual market will use the value of this property
  as settlement data.
  """
  settlementDataProperty: String!
  """
  Name of the property in the source data that should be used as settlement schedule.
  For example, if it is set to "prices.BTC.timestamp", then the perpetual market will use the value of this property
  """
  settlementScheduleProperty: String!
}

"""
Describes which property of the data source data should be
used as composite price source.
"""
type SpecBindingForCompositePrice {
  priceSourceProperty: String!
}

"""
DataSourceSpecToFutureBinding tells on which property data source data should be
used as settlement data and trading termination.
"""
type DataSourceSpecToFutureBinding {
  settlementDataProperty: String!
  tradingTerminationProperty: String!
}

"""
An data source specification describes the data source data that a product (or a risk model)
wants to get from the oracle engine.
"""
type DataSourceSpec {
  "ID is a hash generated from the DataSourceSpec data."
  id: ID!
  "RFC3339Nano creation date time"
  createdAt: Timestamp!
  "RFC3339Nano last updated timestamp"
  updatedAt: Timestamp

  data: DataSourceDefinition!

  "Status describes the status of the data source spec"
  status: DataSourceSpecStatus!
}

"""
externalDataSourceSpec is the type that wraps the DataSourceSpec type in order to be further used/extended
by the OracleSpec
"""
type ExternalDataSourceSpec {
  spec: DataSourceSpec!
}

type OracleSpec {
  dataSourceSpec: ExternalDataSourceSpec!
  "Data lists all the oracle data broadcast to this spec"
  dataConnection(pagination: Pagination): OracleDataConnection!
}

"Describes the status of the data spec"
enum DataSourceSpecStatus {
  "Describes an active data spec"
  STATUS_ACTIVE
  """
  Describes a data spec that is not listening to data
  anymore
  """
  STATUS_DEACTIVATED
}

"""
Signer is the authorized signature used for the data.
"""
type Signer {
  signer: SignerKind!
}

union SignerKind = ETHAddress | PubKey

type ETHAddress {
  address: String
}

type PubKey {
  key: String
}

"""
Filter describes the conditions under which oracle data is considered of
interest or not.
"""
type Filter {
  "key is the data source data property key targeted by the filter."
  key: PropertyKey!
  """
  The conditions that should be matched by the data to be
  considered of interest.
  """
  conditions: [Condition!]
}

"PropertyKey describes the property key contained in a source data."
type PropertyKey {
  "The name of the property."
  name: String
  "The type of the property."
  type: PropertyKeyType!
  """
  An optional decimal place to be applied on the provided value.
  Valid only for PropertyType of type DECIMAL, INTEGER.
  """
  numberDecimalPlaces: Int
}

"""
Type describes the type of properties that are supported by the data source
engine.
"""
enum PropertyKeyType {
  "Any type."
  TYPE_EMPTY
  "Integer type."
  TYPE_INTEGER
  "String type."
  TYPE_STRING
  "Boolean type."
  TYPE_BOOLEAN
  "Any floating point decimal type."
  TYPE_DECIMAL
  "Timestamp date type."
  TYPE_TIMESTAMP
}

"""
Condition describes the condition that must be validated by the data source engine
"""
type Condition {
  "The type of comparison to make on the value."
  operator: ConditionOperator!
  "The value to compare against."
  value: String
}

"Comparator describes the type of comparison."
enum ConditionOperator {
  "Verify if the property values are strictly equal or not."
  OPERATOR_EQUALS
  "Verify if the data source data value is greater than the Condition value."
  OPERATOR_GREATER_THAN
  """
  Verify if the data source data value is greater than or equal to the Condition
  value.
  """
  OPERATOR_GREATER_THAN_OR_EQUAL
  " Verify if the data source data value is less than the Condition value."
  OPERATOR_LESS_THAN
  """
  Verify if the oracle data value is less or equal to than the Condition
  value.
  """
  OPERATOR_LESS_THAN_OR_EQUAL
}

"A data source contains the data sent by a data source"
type Data {
  "signers is the list of public keys/ETH addresses that signed the data"
  signers: [Signer!]
  "properties contains all the properties sent by a data source"
  data: [Property!]

  metaData: [Property]

  """
  List of all the data specs that matched this source data.
  When the array is empty, it means no data spec matched this source data.
  """
  matchedSpecIds: [ID!]
  """
  RFC3339Nano formatted date and time for when the data was broadcast to the markets
  with a matching data spec.
  It has no value when the source data does not match any data spec.
  """
  broadcastAt: Timestamp!
}

type ExternalData {
  data: Data!
}

"An oracle data contains the data sent by an oracle"
type OracleData {
  externalData: ExternalData!
}

"A property associates a name to a value"
type Property {
  "Name of the property"
  name: String!
  "Value of the property"
  value: String!
}

union Product = Future | Spot | Perpetual

"Describes something that can be traded on Vega"
type Instrument {
  "Uniquely identifies an instrument across all instruments available on Vega (string)"
  id: ID!

  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)"
  code: String!

  "Full and fairly descriptive name for the instrument"
  name: String!

  "Metadata for this instrument"
  metadata: InstrumentMetadata!

  "A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)"
  product: Product!
}

type MarginCalculator {
  "The scaling factors that will be used for margin calculation"
  scalingFactors: ScalingFactors!
}

type ScalingFactors {
  "The scaling factor that determines the margin level at which Vega has to search for more money"
  searchLevel: Float!

  "The scaling factor that determines the optimal margin level"
  initialMargin: Float!

  "The scaling factor that determines the overflow margin level"
  collateralRelease: Float!
}

"A tradable instrument is a combination of an instrument and a risk model"
type TradableInstrument {
  "An instance of, or reference to, a fully specified instrument."
  instrument: Instrument!

  "A reference to a risk model that is valid for the instrument"
  riskModel: RiskModel!

  "Margin calculation info, currently only the scaling factors (search, initial, release) for this tradable instrument"
  marginCalculator: MarginCalculator
}

"The factors applied to calculate the fees"
type FeeFactors {
  "The factor applied to calculate MakerFees, a non-negative float"
  makerFee: String!
  "The factor applied to calculate InfrastructureFees, a non-negative float"
  infrastructureFee: String!
  "The factor applied to calculate LiquidityFees, a non-negative float"
  liquidityFee: String!
}

enum LiquidityFeeMethod {
  METHOD_UNSPECIFIED
  "Fee is smallest value of all bids, such that liquidity providers with nominated fees less than or equal to this value still have sufficient commitment to fulfil the market's target stake."
  METHOD_MARGINAL_COST
  "Fee is the weighted average of all liquidity providers' nominated fees, weighted by their commitment"
  METHOD_WEIGHTED_AVERAGE
  "Fee is set by the market to a constant value irrespective of any liquidity provider's nominated fee"
  METHOD_CONSTANT
}

"Market settings that describe how the liquidity fee is calculated"
type LiquidityFeeSettings {
  "Method used to calculate the market's liquidity fee"
  method: LiquidityFeeMethod!
  "Constant liquidity fee used when using the constant fee method"
  feeConstant: String
}

"The fees applicable to a market"
type Fees {
  "The factors used to calculate the different fees"
  factors: FeeFactors!
  "Liquidity fee settings for the market describing how the fee was calculated"
  liquidityFeeSettings: LiquidityFeeSettings
}

"""
An auction duration is used to configure 3 auction periods:
1. `duration > 0`, `volume == 0`:
The auction will last for at least N seconds.
2. `duration == 0`, `volume > 0`:
The auction will end once the given volume will match at uncrossing.
3. `duration > 0`, `volume > 0`:
The auction will take at least N seconds, but can end sooner if the market can trade a certain volume.
"""
type AuctionDuration {
  "Duration of the auction in seconds"
  durationSecs: Int!
  "Target uncrossing trading volume"
  volume: Int!
}

"""
PriceMonitoringParameters holds a list of triggers
"""
type PriceMonitoringParameters {
  "The list of triggers for this price monitoring"
  triggers: [PriceMonitoringTrigger!]
}

"""
PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration
"""
type PriceMonitoringTrigger {
  "Price monitoring projection horizon τ in seconds (> 0)."
  horizonSecs: Int!
  "Price monitoring probability level p. (>0 and < 1)"
  probability: Float!
  """
  Price monitoring auction extension duration in seconds should the price
  breach its theoretical level over the specified horizon at the specified
  probability level (> 0)
  """
  auctionExtensionSecs: Int!
}

"Configuration of a market price monitoring auctions triggers"
type PriceMonitoringSettings {
  "Specified a set of PriceMonitoringParameters to be use for price monitoring purposes"
  parameters: PriceMonitoringParameters
}

"Range of valid prices and the associated price monitoring trigger"
type PriceMonitoringBounds {
  "Minimum price that isn't currently breaching the specified price monitoring trigger"
  minValidPrice: String!
  "Maximum price that isn't currently breaching the specified price monitoring trigger"
  maxValidPrice: String!
  "Price monitoring trigger associated with the bounds"
  trigger: PriceMonitoringTrigger!
  "Reference price used to calculate the valid price range"
  referencePrice: String!
}

"TargetStakeParameters contains parameters used in target stake calculation"
type TargetStakeParameters {
  "Specifies length of time window expressed in seconds for target stake calculation"
  timeWindow: Int!

  "Specifies scaling factors used in target stake calculation"
  scalingFactor: Float!
}

"Configuration of a market liquidity monitoring parameters"
type LiquidityMonitoringParameters {
  "Specifies parameters related to target stake calculation"
  targetStakeParameters: TargetStakeParameters!
}

"Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history"
type Market {
  "Market ID"
  id: ID!

  "Fees related data"
  fees: Fees!

  "An instance of, or reference to, a tradable instrument."
  tradableInstrument: TradableInstrument!

  """
  The number of decimal places that an integer must be shifted by in order to get a correct
  number denominated in the currency of the market. (uint64)

  Examples:
  Currency     Balance  decimalPlaces  Real Balance
  GBP              100              0       GBP 100
  GBP              100              2       GBP   1.00
  GBP              100              4       GBP   0.01
  GBP                1              4       GBP   0.0001   (  0.01p  )

  GBX (pence)      100              0       GBP   1.00     (100p     )
  GBX (pence)      100              2       GBP   0.01     (  1p     )
  GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
  GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
  """
  decimalPlaces: Int!

  """
  The number of decimal places that an integer must be shifted in order to get a correct size (uint64).
  i.e. 0 means there are no fractional orders for the market, and order sizes are always whole sizes.
  2 means sizes given as 10^2 * desired size, e.g. a desired size of 1.23 is represented as 123 in this market.
  This sets how big the smallest order / position on the market can be.
  """
  positionDecimalPlaces: Int!

  """
  Auction duration specifies how long the opening auction will run (minimum
  duration and optionally a minimum traded volume).
  """
  openingAuction: AuctionDuration!

  "Price monitoring settings for the market"
  priceMonitoringSettings: PriceMonitoringSettings!

  "Liquidity monitoring parameters for the market"
  liquidityMonitoringParameters: LiquidityMonitoringParameters!

  "Current mode of execution of the market"
  tradingMode: MarketTradingMode!

  "Current state of the market"
  state: MarketState!

  "The proposal that initiated this market"
  proposal: Proposal @deprecated(reason: "Use marketProposal")

  "The proposal that initiated this market"
  marketProposal: ProposalNode

  "Orders on a market"
  ordersConnection(
    "Pagination information"
    pagination: Pagination
    "Filter orders"
    filter: OrderByPartyIdsFilter
  ): OrderConnection

  "Get account for a party or market"
  accountsConnection(
    "ID of the party to get the margin account for"
    partyId: ID
    "Pagination information"
    pagination: Pagination
  ): AccountsConnection

  tradesConnection(
    "Date range to retrieve trades from/to. Start and end time should be expressed as an integer value of Unix nanoseconds"
    dateRange: DateRange
    "Pagination information"
    pagination: Pagination
  ): TradeConnection
    @deprecated(
      reason: "Simplify and consolidate trades query and remove nesting. Use trades query instead"
    )

  "Current depth on the order book for this market"
  depth(
    "Maximum market order book depth (returns whole order book if omitted)"
    maxDepth: Int
  ): MarketDepth!

  "Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by parameters using cursor based pagination"
  candlesConnection(
    "RFC3339Nano encoded time to get candles from"
    since: String!
    "Optional: RFC3339Nano encoded time to get candles to"
    to: String
    "Interval of the candles"
    interval: Interval!
    "Pagination information"
    pagination: Pagination
  ): CandleDataConnection

  "marketData for the given market"
  data: MarketData

  "The list of the liquidity provision commitments for this market"
  liquidityProvisions(
    "An optional party ID"
    partyId: ID
    "An optional live flag to determine whether to list only live LPs or not"
    live: Boolean
    "Pagination information"
    pagination: Pagination
  ): LiquidityProvisionsWithPendingConnection

  "The list of the liquidity provision commitments for this market"
  liquidityProvisionsConnection(
    "An optional party ID"
    partyId: ID
    "An optional live flag to determine whether to list only live LPs or not"
    live: Boolean
    "Pagination information"
    pagination: Pagination
  ): LiquidityProvisionsConnection
    @deprecated(reason: "Use liquidityProvisions instead")

  "Timestamps for state changes in the market"
  marketTimestamps: MarketTimestamps!

  "Risk factors for the market"
  riskFactors: RiskFactor

  "Linear slippage factor is used to cap the slippage component of maintainence margin - it is applied to the slippage volume"
  linearSlippageFactor: String!

  "Quadratic slippage factor is used to cap the slippage component of maintainence margin - it is applied to the square of the slippage volume"
  quadraticSlippageFactor: String!
    @deprecated(reason: "This field will be removed in a future release")

  """
  Optional: Parent market ID. A market can be a successor to another market. If this market is a successor to a previous market,
  this field will be populated with the ID of the previous market.
  """
  parentMarketID: ID

  """
  Optional: When a successor market is created, a fraction of the parent market's insurance pool can be transferred to the successor market
  """
  insurancePoolFraction: String

  "Optional: Market ID of the successor to this market if one exists"
  successorMarketID: ID

  "Optional: Liquidity SLA parameters for the market"
  liquiditySLAParameters: LiquiditySLAParameters

  "Optional: Liquidation strategy for the market"
  liquidationStrategy: LiquidationStrategy

  "Configuration driving the mark price for the market"
  markPriceConfiguration: CompositePriceConfiguration!

  "The market minimum tick size"
  tickSize: String!
}

"""
Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
The depth of market measure provides an indication of the liquidity and depth for the instrument.
"""
type MarketDepth {
  "Market"
  market: Market!

  "Buy side price levels (if available)"
  buy: [PriceLevel!]

  "Sell side price levels (if available)"
  sell: [PriceLevel!]

  "Last trade for the given market (if available)"
  lastTrade: Trade

  "Sequence number for the current snapshot of the market depth"
  sequenceNumber: String!
}

"""
Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
The depth of market measure provides an indication of the liquidity and depth for the instrument.
"""
type ObservableMarketDepth {
  "Market ID"
  marketId: ID!

  "Buy side price levels (if available)"
  buy: [PriceLevel!]

  "Sell side price levels (if available)"
  sell: [PriceLevel!]

  "Last trade for the given market (if available)"
  lastTrade: MarketDepthTrade!

  "Sequence number for the current snapshot of the market depth"
  sequenceNumber: String!
}

type MarketDepthTrade {
  "ID of the trade for the given market (if available)"
  id: ID!

  "Price of the trade"
  price: String!

  "Size of the trade"
  size: String!
}

"""
Market Depth Update is a delta to the current market depth which can be used to update the
market depth structure to keep it correct
"""
type MarketDepthUpdate {
  "Market"
  market: Market!

  "Buy side price levels (if available)"
  buy: [PriceLevel!]

  "Sell side price levels (if available)"
  sell: [PriceLevel!]

  "Sequence number for the current snapshot of the market depth. It is always increasing but not monotonic."
  sequenceNumber: String!

  "Sequence number of the last update sent; useful for checking that no updates were missed."
  previousSequenceNumber: String!
}

"""
Market Depth Update is a delta to the current market depth which can be used to update the
market depth structure to keep it correct
"""
type ObservableMarketDepthUpdate {
  "Market ID"
  marketId: ID!

  "Buy side price levels (if available)"
  buy: [PriceLevel!]

  "Sell side price levels (if available)"
  sell: [PriceLevel!]

  "Sequence number for the current snapshot of the market depth. It is always increasing but not monotonic."
  sequenceNumber: String!

  "Sequence number of the last update sent; useful for checking that no updates were missed."
  previousSequenceNumber: String!
}

"Represents a price on either the buy or sell side and all the orders at that price"
type PriceLevel {
  "The price of all the orders at this level (uint64)"
  price: String!

  "The total remaining size of all orders at this level (uint64)"
  volume: String!

  "The number of orders at this price level (uint64)"
  numberOfOrders: String!
}

"Candle stick representation of trading"
type Candle {
  "RFC3339Nano formatted date and time for the candle start time"
  periodStart: Timestamp!

  "RFC3339Nano formatted date and time for the candle end time, or last updated time if the candle is still open"
  lastUpdateInPeriod: Timestamp!

  "High price (uint64)"
  high: String!

  "Low price (uint64)"
  low: String!

  "Open price (uint64)"
  open: String!

  "Close price (uint64)"
  close: String!

  "Volume price (uint64)"
  volume: String!

  "Total notional value of trades (uint64)"
  notional: String!
}

"Represents a party on Vega, could be an ethereum wallet address in the future"
type Party {
  "Party identifier"
  id: ID!

  "Orders relating to a party"
  ordersConnection(
    "Pagination information"
    pagination: Pagination
    "Filter orders"
    filter: OrderByMarketIdsFilter
  ): OrderConnection

  tradesConnection(
    "ID of the market you want to get trades for"
    marketId: ID
    "Date range to retrieve trades from/to. Start and end time should be expressed as an integer value of Unix nanoseconds"
    dataRange: DateRange
    "Pagination information"
    pagination: Pagination
  ): TradeConnection
    @deprecated(
      reason: "Simplify and consolidate trades query and remove nesting. Use trades query instead"
    )

  "Collateral accounts relating to a party"
  accountsConnection(
    "Market ID - specify what market accounts for the party to return"
    marketId: ID
    "Asset ID"
    assetId: ID
    "Filter accounts by type (General account, margin account, etc...)"
    type: AccountType
    "Cursor pagination information"
    pagination: Pagination
  ): AccountsConnection

  "Trading positions relating to a party"
  positionsConnection(market: ID, pagination: Pagination): PositionConnection
    @deprecated(reason: "Use root positions query instead of sub-query")

  "Margin levels for a market"
  marginsConnection(
    "market ID for the requested margin levels, nil if all markets"
    marketId: ID
    "Optional Pagination information"
    pagination: Pagination
  ): MarginConnection

  "All governance proposals in the Vega network"
  proposalsConnection(
    "Optional type of proposal to retrieve data for"
    proposalType: ProposalType
    "Returns only proposals in the specified state. Leave out to get all proposals"
    inState: ProposalState
    "Optional Pagination information"
    pagination: Pagination
  ): ProposalsConnection

  "All votes on proposals in the Vega network by the given party"
  votesConnection(
    "Optional Pagination information"
    pagination: Pagination
  ): ProposalVoteConnection

  "The list of all withdrawals initiated by the party"
  withdrawalsConnection(
    "Date range to retrieve withdrawals from/to. Start and end time should be expressed as an integer value of Unix nanoseconds"
    dateRange: DateRange
    "Optional Pagination information"
    pagination: Pagination
  ): WithdrawalsConnection

  "The list of all deposits for a party by the party"
  depositsConnection(
    "Date range to retrieve deposits from/to. Start and end time should be expressed as an integer value Unix nanoseconds"
    dateRange: DateRange
    "Optional Pagination information"
    pagination: Pagination
  ): DepositsConnection

  "The list of the liquidity provision commitments for this party"
  liquidityProvisions(
    "An optional market ID"
    marketId: ID
    "An optional reference"
    reference: String
    "An optional live flag to determine whether to list only live LPs or not"
    live: Boolean
    "Optional Pagination information"
    pagination: Pagination
  ): LiquidityProvisionsWithPendingConnection

  "The list of the liquidity provision commitment for this party"
  liquidityProvisionsConnection(
    "An optional market ID"
    marketId: ID
    "An optional reference"
    reference: String
    "An optional live flag to determine whether to list only live LPs or not"
    live: Boolean
    "Optional Pagination information"
    pagination: Pagination
  ): LiquidityProvisionsConnection
    @deprecated(reason: "Use liquidityProvisions instead")

  # All delegations for a party to a given node if node is specified, or all delegations if not
  delegationsConnection(
    "Optional node ID"
    nodeId: ID
    "Pagination information"
    pagination: Pagination
  ): DelegationsConnection

  "The staking information for this Party"
  stakingSummary(pagination: Pagination): StakingSummary!

  "Rewards information for the party"
  rewardsConnection(
    "An asset ID (optional)"
    assetId: ID
    "Optional pagination information"
    pagination: Pagination
    "Optionally only return rewards >= this epoch"
    fromEpoch: Int
    "Optionally only return rewards <= this epoch"
    toEpoch: Int
    "Optionally filter for rewards earned by the party for team participation."
    teamId: ID
    "Optionally filter for rewards earned for the given game ID"
    gameId: ID
  ): RewardsConnection

  "Return net reward information"
  rewardSummaries("An asset ID (optional)" assetId: ID): [RewardSummary]

  "All transfers for a public key"
  transfersConnection(
    "direction of the transfer with respect to the public key"
    direction: TransferDirection
    "Pagination information"
    pagination: Pagination
    "Filter for reward transfers only. Direction must be 'From'"
    isReward: Boolean
    "Optional epoch to filter from (included). If omitted, the range goes from the oldest epoch to the `to epoch`."
    fromEpoch: Int
    "Optional epoch to filter to (included). If omitted, the range goes from `from epoch` to the most recent epoch."
    toEpoch: Int
    "Optional status to filter on."
    status: TransferStatus
    "Optional dispatch strategy's scope to filter for."
    scope: TransferScope
    "Optional game ID to filter for"
    gameId: ID
    "Optional from account type to filter for"
    fromAccountType: AccountType
    "Optional to account type to filter for"
    toAccountType: AccountType
  ): TransferConnection

  "The activity streak"
  activityStreak("An optional epoch" epoch: Int): PartyActivityStreak

  "The current reward vesting summary of the party for the last epoch"
  vestingBalancesSummary(
    "An optional asset ID"
    assetId: ID
  ): PartyVestingBalancesSummary!

  "The current statistics about a party's vesting rewards for the last epoch"
  vestingStats: PartyVestingStats
}

"""
Statistics about a party's vesting rewards
"""
type PartyVestingStats {
  "Epoch for which the statistics are valid"
  epochSeq: Int!
  "The reward bonus multiplier"
  rewardBonusMultiplier: String!
  "The balance of the party, in quantum."
  quantumBalance: String!
}

"""
A party reward locked balance.
"""
type PartyLockedBalance {
  "The asset locked"
  asset: Asset!
  "The amount locked"
  balance: String!
  "Epoch in which the funds will be moved to the vesting balance"
  untilEpoch: Int!
}

"""
A party's reward vesting balance.
"""
type PartyVestingBalance {
  "The asset being vested"
  asset: Asset!
  "The amount locked"
  balance: String!
}

"""
Summary of a party's reward vesting balances.
"""
type PartyVestingBalancesSummary {
  "The epoch for which this summary is valid"
  epoch: Int
  "The party vesting balances"
  vestingBalances: [PartyVestingBalance!]
  "The party's vesting balances"
  lockedBalances: [PartyLockedBalance!]
}

"""
The activity streak for a party.
"""
type PartyActivityStreak {
  "The number of epochs the party has been active in a row"
  activeFor: Int!
  "The number of epochs the party has been inactive in a row"
  inactiveFor: Int!
  "If the party is considered as active, and thus eligible for rewards multipliers"
  isActive: Boolean!
  "The rewards distribution multiplier for the party"
  rewardDistributionMultiplier: String!
  "The rewards vesting multiplier for the party"
  rewardVestingMultiplier: String!
  "The epoch for which this information is relevant"
  epoch: Int!
  "The traded volume for that party in the given epoch"
  tradedVolume: String!
  "The open volume for the party in the given epoch"
  openVolume: String!
}

"""
All staking information related to a Party.
Contains the current recognised balance by the network and
all the StakeLink/Unlink seen by the network
"""
type PartyStake {
  "The stake currently available for the party"
  currentStakeAvailable: String!
  "The list of all stake link/unlink for the party"
  linkings: [StakeLinking!]
}

"""
All staking information related to a Party.
Contains the current recognised balance by the network and
all the StakeLink/Unlink seen by the network
"""
type StakingSummary {
  "The stake currently available for the party"
  currentStakeAvailable: String!
  "The list of all stake link/unlink for the party"
  linkings(pagination: Pagination): StakesConnection!
}

"The type of stake linking"
enum StakeLinkingType {
  "The stake is being linked (deposited) to a Vega stake account"
  TYPE_LINK
  "The stake is being unlinked (removed) from a Vega stake account"
  TYPE_UNLINK
}

"The status of the stake linking"
enum StakeLinkingStatus {
  """
  The stake linking is pending in the Vega network. This means that
  the Vega network have seen a stake linking, but is still to confirm
  it's valid on the ethereum chain and accepted by all nodes of the network
  """
  STATUS_PENDING
  "The stake linking has been accepted and processed fully (balance updated) by the network"
  STATUS_ACCEPTED
  "The Vega network has rejected this stake linking"
  STATUS_REJECTED
}

"A stake linking represent the intent from a party to deposit / remove stake on their account"
type StakeLinking {
  id: ID!
  "Type of linking: link|unlink"
  type: StakeLinkingType!
  "The RFC3339Nano time at which the request happened on ethereum"
  timestamp: Timestamp!
  "The party initiating the stake linking"
  party: Party!
  "The amount linked or unlinked"
  amount: String!
  "The status of the linking"
  status: StakeLinkingStatus!
  "The RFC3339Nano time at which the stake linking was fully processed by the Vega network, null until defined"
  finalizedAt: Timestamp
  "The transaction hash (ethereum) which initiated the link/unlink"
  txHash: String!
  "The (ethereum) block height of the link/unlink"
  blockHeight: String!
}

"Position status can change if a position is distressed"
enum PositionStatus {
  "The position is either healthy, or if closed out, was closed out normally"
  POSITION_STATUS_UNSPECIFIED
  "The position was distressed, but removing open orders from the book brought the margin level back to a point where the open position could be maintained"
  POSITION_STATUS_ORDERS_CLOSED
  "The position was distressed, and had to be closed out entirely - orders were removed from the book, and the open volume was closed out by the network"
  POSITION_STATUS_CLOSED_OUT
  "The position was distressed, but could not be closed out - orders were removed from the book, and the open volume will be closed out once there is sufficient volume on the book"
  POSITION_STATUS_DISTRESSED
}

"""
An individual party at any point in time is considered net long or net short. This refers to their Open Volume,
calculated using FIFO. This volume is signed as either negative for LONG positions and positive for SHORT positions. A
single trade may end up "splitting" with some of its volume matched into closed volume and some of its volume
remaining as open volume. This is why we don't refer to positions being comprised of trades, rather of volume.
"""
type Position {
  "Market relating to this position"
  market: Market!

  "The party holding this position"
  party: Party!

  "Open volume (int64)"
  openVolume: String!

  "Realised Profit and Loss (int64)"
  realisedPNL: String!

  "Unrealised Profit and Loss (int64)"
  unrealisedPNL: String!

  "Average entry price for this position"
  averageEntryPrice: String!

  "The total amount of profit and loss that was not transferred due to loss socialisation"
  lossSocializationAmount: String!

  "Enum set if the position was closed out or orders were removed because party was distressed"
  positionStatus: PositionStatus!

  "Margins of the party for the given position"
  marginsConnection(pagination: Pagination): MarginConnection

  "RFC3339Nano time the position was updated"
  updatedAt: Timestamp
}

"""
An individual party at any point in time is considered net long or net short. This refers to their Open Volume,
calculated using FIFO. This volume is signed as either negative for LONG positions and positive for SHORT positions. A
single trade may end up "splitting" with some of its volume matched into closed volume and some of its volume
remaining as open volume. This is why we don't refer to positions being comprised of trades, rather of volume.
"""
type PositionUpdate {
  "Market relating to this position"
  marketId: ID!

  "The party holding this position"
  partyId: ID!

  "Open volume (int64)"
  openVolume: String!

  "Realised Profit and Loss (int64)"
  realisedPNL: String!

  "Unrealised Profit and Loss (int64)"
  unrealisedPNL: String!

  "Average entry price for this position"
  averageEntryPrice: String!

  "RFC3339Nano time the position was updated"
  updatedAt: Timestamp

  "The total amount of profit and loss that was not transferred due to loss socialisation"
  lossSocializationAmount: String!

  "Enum set if the position was closed out or orders were removed because party was distressed"
  positionStatus: PositionStatus!
}

"Basic description of an order"
input OrderInfo {
  "Whether the order is to buy or sell"
  side: Side!
  "Price for the order"
  price: String!
  "Number of units remaining of the total that have not yet been bought or sold (uint64)"
  remaining: String!
  "Boolean indicating a market order"
  isMarketOrder: Boolean!
}

"An order in Vega, if active it will be on the order book for the market"
type Order {
  "Hash of the order data"
  id: ID!

  "The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)"
  price: String!

  "The timeInForce of order (determines how and if it executes, and whether it persists on the book)"
  timeInForce: OrderTimeInForce!

  "Whether the order is to buy or sell"
  side: Side!

  "The market the order is trading on (probably stored internally as a hash of the market details)"
  market: Market!

  "Total number of units that may be bought or sold (immutable) (uint64)"
  size: String!

  "Number of units remaining of the total that have not yet been bought or sold (uint64)"
  remaining: String!

  "The party that placed the order (probably stored internally as the party's public key)"
  party: Party!

  "RFC3339Nano formatted date and time for when the order was created (timestamp)"
  createdAt: Timestamp!

  "RFC3339Nano expiration time of this order"
  expiresAt: Timestamp

  "The status of an order, for example 'Active'"
  status: OrderStatus!

  "The external reference (if available) for the order"
  reference: String!

  "Trades relating to this order"
  tradesConnection(
    "Date range to retrieve trades from/to. Start and end time should be expressed as an integer value Unix nanoseconds"
    dateRange: DateRange
    pagination: Pagination
  ): TradeConnection
    @deprecated(
      reason: "Simplify and consolidate trades query and remove nesting. Use trades query instead"
    )

  "The order type"
  type: OrderType

  "Why the order was rejected"
  rejectionReason: OrderRejectionReason

  "Version of this order, counts the number of amends"
  version: String!

  "RFC3339Nano time the order was altered"
  updatedAt: Timestamp

  "PeggedOrder contains the details about a pegged order"
  peggedOrder: PeggedOrder

  "The liquidity provision this order was created from"
  liquidityProvision: LiquidityProvision

  "Is this a post only order"
  postOnly: Boolean

  "Is this a reduce only order"
  reduceOnly: Boolean

  "Details of an iceberg order"
  icebergOrder: IcebergOrder
}

union StopOrderTrigger = StopOrderPrice | StopOrderTrailingPercentOffset

"Price at which a stop order will trigger"
type StopOrderPrice {
  price: String!
}

"Percentage movement in the price at which a stop order will trigger."
type StopOrderTrailingPercentOffset {
  trailingPercentOffset: String!
}

"Why the order was rejected by the core node"
enum StopOrderRejectionReason {
  "Trading is not allowed yet"
  REJECTION_REASON_TRADING_NOT_ALLOWED
  "Expiry of the stop order is in the past"
  REJECTION_REASON_EXPIRY_IN_THE_PAST
  "Stop orders submission must be reduce only"
  REJECTION_REASON_MUST_BE_REDUCE_ONLY
  "Party has reached the maximum stop orders allowed for this market"
  REJECTION_REASON_MAX_STOP_ORDERS_PER_PARTY_REACHED
  "Stop orders are not allowed without a position"
  REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_WITHOUT_A_POSITION
  "This stop order does not close the position"
  REJECTION_REASON_STOP_ORDER_NOT_CLOSING_THE_POSITION
  "Stop orders are not allowed during the opening auction"
  REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_DURING_OPENING_AUCTION
  "Stop order cannot have matching OCO expiry times"
  REJECTION_REASON_STOP_ORDER_CANNOT_MATCH_OCO_EXPIRY_TIMES
}

"Stop order size override settings"
enum StopOrderSizeOverrideSetting {
  "The size override has not been specified, this should never happen!"
  SIZE_OVERRIDE_SETTING_UNSPECIFIED
  "No size override, the size within the contained normal order submission will be used"
  SIZE_OVERRIDE_SETTING_NONE
  "Use the total position of the trader"
  SIZE_OVERRIDE_SETTING_POSITION
}

"A stop order in Vega"
type StopOrder {
  "Hash of the stop order data"
  id: ID!
  "If OCO (one-cancels-other) order, the ID of the associated order."
  ocoLinkId: ID
  "RFC3339Nano time at which the order will expire if an expiry time is set."
  expiresAt: Timestamp
  "If an expiry is set, what should the stop order do when it expires."
  expiryStrategy: StopOrderExpiryStrategy
  "Direction the price is moving to trigger the stop order."
  triggerDirection: StopOrderTriggerDirection!
  "Status of the stop order"
  status: StopOrderStatus!
  "RFC3339Nano time the stop order was created."
  createdAt: Timestamp!
  "RFC3339Nano time the stop order was last updated."
  updatedAt: Timestamp
  "Party that submitted the stop order."
  partyId: ID!
  "Market the stop order is for."
  marketId: ID!
  "Price movement that will trigger the stop order"
  trigger: StopOrderTrigger!
  "Order to submit when the stop order is triggered."
  submission: OrderSubmission!
  "The order that was created when triggered."
  order: Order
  "Optional rejection reason for an order"
  rejectionReason: StopOrderRejectionReason
  "Size override setting"
  sizeOverrideSetting: StopOrderSizeOverrideSetting!
  "Size override value"
  sizeOverrideValue: String
}

"Details of the order that will be submitted when the stop order is triggered."
type OrderSubmission {
  "Market the order is for."
  marketId: ID!
  "The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)"
  price: String!
  "Total number of units that may be bought or sold (immutable) (uint64)"
  size: String!
  "Whether the order is to buy or sell"
  side: Side!
  "The timeInForce of order (determines how and if it executes, and whether it persists on the book)"
  timeInForce: OrderTimeInForce!
  "RFC3339Nano expiration time of this order"
  expiresAt: Timestamp!
  "The order type"
  type: OrderType!
  "The external reference (if available) for the order"
  reference: String
  "PeggedOrder contains the details about a pegged order"
  peggedOrder: PeggedOrder
  "Is this a post only order"
  postOnly: Boolean
  "Is this a reduce only order"
  reduceOnly: Boolean
  "Details of an iceberg order"
  icebergOrder: IcebergOrder
}

"An order update in Vega, if active it will be on the order book for the market"
type OrderUpdate {
  "Hash of the order data"
  id: ID!

  "The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)"
  price: String!

  "The timeInForce of order (determines how and if it executes, and whether it persists on the book)"
  timeInForce: OrderTimeInForce!

  "Whether the order is to buy or sell"
  side: Side!

  "The market the order is trading on (probably stored internally as a hash of the market details)"
  marketId: ID!

  "Total number of units that may be bought or sold (immutable) (uint64)"
  size: String!

  "Number of units remaining of the total that have not yet been bought or sold (uint64)"
  remaining: String!

  "The party that placed the order (probably stored internally as the party's public key)"
  partyId: ID!

  "RFC3339Nano formatted date and time for when the order was created (timestamp)"
  createdAt: Timestamp!

  "RFC3339Nano expiration time of this order"
  expiresAt: Timestamp

  "The status of an order, for example 'Active'"
  status: OrderStatus!

  "The external reference (if available) for the order"
  reference: String!

  "The order type"
  type: OrderType

  "Why the order was rejected"
  rejectionReason: OrderRejectionReason

  "Version of this order, counts the number of amends"
  version: String!

  "RFC3339Nano time the order was altered"
  updatedAt: Timestamp

  "PeggedOrder contains the details about a pegged order"
  peggedOrder: PeggedOrder

  "The liquidity provision this order was created from"
  liquidityProvisionId: ID

  "Details of an iceberg order"
  icebergOrder: IcebergOrder
}

"Response for the estimate of the margin level and, if available, collateral was provided in the request, liquidation price for the specified position"
type PositionEstimate {
  "Margin level range estimate for the specified position"
  margin: MarginEstimate!
  "Estimated margin account balance increase"
  collateralIncreaseEstimate: CollateralIncreaseEstimate!
  "Liquidation price range estimate for the specified position. Only populated if available collateral was specified in the request"
  liquidation: LiquidationEstimate
}

"Margin level estimate for both worst and best case possible"
type MarginEstimate {
  "Margin level estimate assuming slippage cap is applied"
  worstCase: AbstractMarginLevels!
  "Margin level estimate assuming no slippage"
  bestCase: AbstractMarginLevels!
}

"Collateral increase estimate for the additional funds needed to support the specified position"
type CollateralIncreaseEstimate {
  "Estimate assuming slippage cap is applied"
  worstCase: String!
  "Estimate assuming no slippage"
  bestCase: String!
}

"Liquidation estimate for both worst and best case possible"
type LiquidationEstimate {
  "Liquidation price estimate assuming slippage cap is applied"
  worstCase: LiquidationPrice!
  "Liquidation price estimate assuming no slippage"
  bestCase: LiquidationPrice!
}

"Liquidation price estimate for either only the current open volume and position given some or all buy orders get filled, or position given some or all sell orders get filled"
type LiquidationPrice {
  "Liquidation price for current open volume ignoring any active orders"
  open_volume_only: String!
  "Liquidation price assuming buy orders start getting filled"
  including_buy_orders: String!
  "Liquidation price assuming sell orders start getting filled"
  including_sell_orders: String!
}

"An estimate of the fee to be paid by the order"
type OrderEstimate {
  "The estimated fee if the order was to trade"
  fee: TradeFee!

  "The total estimated amount of fee if the order was to trade"
  totalFeeAmount: String!

  "The margin requirement for this order"
  marginLevels: MarginLevels!
}

"An estimate of the fee to be paid for the order"
type FeeEstimate {
  "The estimated fees if the order was to trade"
  fees: TradeFee!

  "The total estimated amount of fees if the order was to trade"
  totalFeeAmount: String!
}

"A trade on Vega, the result of two orders being 'matched' in the market"
type Trade {
  "The hash of the trade data"
  id: ID!

  "The market the trade occurred on"
  market: Market!

  "The order that bought"
  buyOrder: String!

  "The order that sold"
  sellOrder: String!

  "The party that bought"
  buyer: Party!

  "The party that sold"
  seller: Party!

  "The aggressor indicates whether this trade was related to a BUY or SELL"
  aggressor: Side!

  "The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)"
  price: String!

  "The number of units traded, will always be <= the remaining size of both orders immediately before the trade (uint64)"
  size: String!

  "RFC3339Nano time for when the trade occurred"
  createdAt: Timestamp!

  "The type of trade"
  type: TradeType!

  "The fee paid by the buyer side of the trade"
  buyerFee: TradeFee!

  "The fee paid by the seller side of the trade"
  sellerFee: TradeFee!

  "The batch in which the buyer order was submitted (applies only for auction modes)"
  buyerAuctionBatch: Int

  "The batch in which the seller order was submitted (applies only for auction modes)"
  sellerAuctionBatch: Int
}

"A trade on Vega, the result of two orders being 'matched' in the market"
type TradeUpdate {
  "The hash of the trade data"
  id: ID!

  "The market the trade occurred on"
  marketId: ID!

  "The order that bought"
  buyOrder: String!

  "The order that sold"
  sellOrder: String!

  "The party that bought"
  buyerId: ID!

  "The party that sold"
  sellerId: ID!

  "The aggressor indicates whether this trade was related to a BUY or SELL"
  aggressor: Side!

  "The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)"
  price: String!

  "The number of units traded, will always be <= the remaining size of both orders immediately before the trade (uint64)"
  size: String!

  "RFC3339Nano time for when the trade occurred"
  createdAt: Timestamp!

  "The type of trade"
  type: TradeType!

  "The fee paid by the buyer side of the trade"
  buyerFee: TradeFee!

  "The fee paid by the seller side of the trade"
  sellerFee: TradeFee!

  "The batch in which the buyer order was submitted (applies only for auction modes)"
  buyerAuctionBatch: Int

  "The batch in which the seller order was submitted (applies only for auction modes)"
  sellerAuctionBatch: Int
}

"The fee paid by the party when a trade occurs"
type TradeFee {
  "The maker fee, paid by the aggressive party to the other party (the one who had an order in the book)"
  makerFee: String!

  "The infrastructure fee, a fee paid to the validators to maintain the Vega network"
  infrastructureFee: String!

  "The fee paid to the liquidity providers that committed liquidity to the market"
  liquidityFee: String!

  "Referral discount on maker fees for the trade"
  makerFeeReferralDiscount: String

  "Volume discount on maker fees for the trade"
  makerFeeVolumeDiscount: String

  "Referral discount on infrastructure fees for the trade"
  infrastructureFeeReferralDiscount: String

  "Volume discount on infrastructure fees for the trade"
  infrastructureFeeVolumeDiscount: String

  "Referral discount on liquidity fees for the trade"
  liquidityFeeReferralDiscount: String

  "Volume discount on liquidity fees for the trade"
  liquidityFeeVolumeDiscount: String
}

"Valid trade types"
enum TradeType {
  "Default trade type"
  TYPE_DEFAULT

  "Network close-out - good"
  TYPE_NETWORK_CLOSE_OUT_BAD

  "Network close-out - bad"
  TYPE_NETWORK_CLOSE_OUT_GOOD
}

"An account record"
type AccountBalance {
  "Balance as string - current account balance (approx. as balances can be updated several times per second)"
  balance: String!
  "Asset, the 'currency'"
  asset: Asset!
  "Account type (General, Margin, etc)"
  type: AccountType!
  "Market (only relevant to margin accounts)"
  market: Market
  "Owner of the account"
  party: Party
}

"An account record"
type AccountEvent {
  "Balance as string - current account balance (approx. as balances can be updated several times per second)"
  balance: String!
  "Asset, the 'currency'"
  asset: Asset!
  "Account type (General, Margin, etc)"
  type: AccountType!
  "Market (only relevant to margin accounts)"
  market: Market
  "Owner of the account"
  party: Party
}

"An account record"
type AccountDetails {
  "Asset, the 'currency'"
  assetId: ID!
  "Account type (General, Margin, etc)"
  type: AccountType!
  "Market (only relevant to margin accounts)"
  marketId: ID
  "Owner of the account"
  partyId: ID
}

"An account record used for subscriptions"
type AccountUpdate {
  "Balance as string - current account balance (approx. as balances can be updated several times per second)"
  balance: String!
  "Asset id, the 'currency'"
  assetId: ID!
  "Account type (General, Margin, etc)"
  type: AccountType!
  "Market id (only relevant to margin accounts)"
  marketId: ID
  "The party owning the account"
  partyId: ID!
}

"All the data related to the approval of a withdrawal from the network"
type Erc20WithdrawalApproval {
  "The source asset in the ethereum network"
  assetSource: String!
  "The amount to be withdrawn"
  amount: String!
  "The nonce to be used in the request"
  nonce: String!
  """
  Signature aggregate from the nodes, in the following format:
  0x + sig1 + sig2 + ... + sigN
  """
  signatures: String!
  "The target address that will receive the funds"
  targetAddress: String!
  "RFC3339Nano timestamp at which the withdrawal was created"
  creation: String!
}

"Response for the signature bundle to add a particular validator to the signer list of the multisig contract"
type ERC20MultiSigSignerAddedConnection {
  edges: [ERC20MultiSigSignerAddedBundleEdge]
  pageInfo: PageInfo
}

type ERC20MultiSigSignerAddedBundleEdge {
  node: ERC20MultiSigSignerAddedBundle!
  cursor: String!
}

type ERC20MultiSigSignerAddedBundle {
  "The ethereum address of the signer to be added"
  newSigner: String!
  "The ethereum address of the submitter"
  submitter: String!
  "The nonce used in the signing operation"
  nonce: String!
  "Unix-nano timestamp for when the validator was added"
  timestamp: String!
  "The bundle of signatures from current validators to sign in the new signer"
  signatures: String!
  "The epoch in which the validator was added"
  epochSeq: String!
}

"Response for the signature bundle to remove a particular validator from the signer list of the multisig contract"
type ERC20MultiSigSignerRemovedConnection {
  "The list of signer bundles for that validator"
  edges: [ERC20MultiSigSignerRemovedBundleEdge]
  "The pagination information"
  pageInfo: PageInfo
}

type ERC20MultiSigSignerRemovedBundleEdge {
  node: ERC20MultiSigSignerRemovedBundle!
  cursor: String!
}

type ERC20MultiSigSignerRemovedBundle {
  "The ethereum address of the signer to be removed"
  oldSigner: String!
  "The ethereum address of the submitter"
  submitter: String!
  "The nonce used in the signing operation"
  nonce: String!
  "Unix-nano timestamp for when the validator was added"
  timestamp: String!
  "The bundle of signatures from current validators to sign in the new signer"
  signatures: String!
  "The epoch in which the validator was removed"
  epochSeq: String!
}

"Response for the signature bundle to allowlist an ERC20 token in the collateral bridge"
type Erc20ListAssetBundle {
  "The source asset in the ethereum network"
  assetSource: String!
  "The ID of the vega asset"
  vegaAssetId: String!
  "The nonce to be used in the request"
  nonce: String!
  """
  Signature aggregate from the nodes, in the following format:
  0x + sig1 + sig2 + ... + sigN
  """
  signatures: String!
}

"Response for the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge"
type ERC20SetAssetLimitsBundle {
  "The address of the asset on ethereum"
  assetSource: String!
  "The ID of the vega asset"
  vegaAssetId: String!
  "The nonce, which is actually the internal reference for the proposal"
  nonce: String!
  "The lifetime limit deposit for this asset"
  lifetimeLimit: String!
  "The threshold withdraw for this asset"
  threshold: String!
  """
  The signatures bundle as hex encoded data, forward by 0x
  e.g: 0x + sig1 + sig2 + ... + sixN
  """
  signatures: String!
}

"The details of a withdrawal processed by Vega"
type Withdrawal {
  "The Vega internal ID of the withdrawal"
  id: ID!
  "The Party initiating the withdrawal"
  party: Party!
  "The amount to be withdrawn"
  amount: String!
  "The asset to be withdrawn"
  asset: Asset!
  "The current status of the withdrawal"
  status: WithdrawalStatus!
  "A reference the foreign chain can use to refer to when processing the withdrawal"
  ref: String!
  "RFC3339Nano time at which the withdrawal was created"
  createdTimestamp: Timestamp!
  "RFC3339Nano time at which the withdrawal was finalised"
  withdrawnTimestamp: Timestamp
  "Hash of the transaction on the foreign chain"
  txHash: String
  "Foreign chain specific details about the withdrawal"
  details: WithdrawalDetails
}

union WithdrawalDetails = Erc20WithdrawalDetails

"Specific details for an erc20 withdrawal"
type Erc20WithdrawalDetails {
  "The ethereum address of the receiver of the asset funds"
  receiverAddress: String!
}

"The status of a withdrawal"
enum WithdrawalStatus {
  "The withdrawal is open and being processed by the network"
  STATUS_OPEN
  "The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain"
  STATUS_REJECTED
  "The withdrawal was finalised, it was valid, the foreign chain has executed it and the network updated all accounts"
  STATUS_FINALIZED
}

"The details of a deposit processed by Vega"
type Deposit {
  "The Vega internal ID of the deposit"
  id: ID!
  "The Party initiating the deposit"
  party: Party!
  "The amount to be withdrawn"
  amount: String!
  "The asset to be withdrawn"
  asset: Asset!
  "The current status of the deposit"
  status: DepositStatus!
  "RFC3339Nano time at which the deposit was created"
  createdTimestamp: Timestamp!
  "RFC3339Nano time at which the deposit was finalised"
  creditedTimestamp: Timestamp
  "Hash of the transaction on the foreign chain"
  txHash: String
}

"The status of a deposit"
enum DepositStatus {
  "The deposit is open and being processed by the network"
  STATUS_OPEN
  "The deposit have been cancelled by the network, either because it expired, could not be verified, or something went wrong with the foreign chain"
  STATUS_CANCELLED
  "The deposit was finalised, it was valid, the foreign chain has executed it and the network updated all accounts"
  STATUS_FINALIZED
  "The deposit was rejected as a duplicate transaction"
  STATUS_DUPLICATE_REJECTED
}

"Valid order types, these determine what happens when an order is added to the book"
enum OrderTimeInForce {
  "Fill or Kill: The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade"
  TIME_IN_FORCE_FOK

  "Immediate or Cancel: The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)"
  TIME_IN_FORCE_IOC

  "Good 'til Cancelled: This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled"
  TIME_IN_FORCE_GTC

  """
  Good 'til Time: This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
  NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
  """
  TIME_IN_FORCE_GTT

  "Good for Auction: This order is only accepted during an auction period"
  TIME_IN_FORCE_GFA

  "Good for Normal: This order is only accepted during normal trading (continuous trading or frequent batched auctions)"
  TIME_IN_FORCE_GFN
}

"Valid references used for pegged orders."
enum PeggedReference {
  "Peg the order against the mid price of the order book"
  PEGGED_REFERENCE_MID
  "Peg the order against the best bid price of the order book"
  PEGGED_REFERENCE_BEST_BID
  "Peg the order against the best ask price of the order book"
  PEGGED_REFERENCE_BEST_ASK
}

"Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order."
enum OrderStatus {
  """
  The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
  Active does not necessarily mean it's still on the order book.
  """
  STATUS_ACTIVE

  "This order trades any amount and as much as possible and remains on the book until it either trades completely or expires."
  STATUS_EXPIRED

  "The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining."
  STATUS_CANCELLED

  "This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity."
  STATUS_STOPPED

  "This order is fully filled with remaining equalling zero."
  STATUS_FILLED

  "This order was rejected while being processed."
  STATUS_REJECTED

  "This order was partially filled."
  STATUS_PARTIALLY_FILLED

  "This order has been removed from the order book because the market is in auction, the reference price doesn't exist, or the order needs to be repriced and can't. Applies to pegged orders only"
  STATUS_PARKED
}

"Valid stop order statuses, these determine several states for a stop order that cannot be expressed with other fields in StopOrder."
enum StopOrderStatus {
  "Stop order has been submitted to the network but does not have a status yet"
  STATUS_UNSPECIFIED
  "Stop order is pending. This means the stop order has been accepted in the network, but the trigger conditions have not been met."
  STATUS_PENDING
  "Stop order has been cancelled. This could be by the trader or by the network."
  STATUS_CANCELLED
  "Stop order has been stopped. This means the trigger conditions have been met, but the stop order was not executed, and stopped."
  STATUS_STOPPED
  "Stop order has been triggered. This means the trigger conditions have been met, and the stop order was executed."
  STATUS_TRIGGERED
  "Stop order has expired. This means the trigger conditions have not been met and the stop order has expired."
  STATUS_EXPIRED
  "Stop order has been rejected. This means the stop order was not accepted by the network."
  STATUS_REJECTED
}

"Valid stop order expiry strategies. The expiry strategy determines what happens to a stop order when it expires."
enum StopOrderExpiryStrategy {
  "The stop order expiry strategy has not been specified by the trader."
  EXPIRY_STRATEGY_UNSPECIFIED
  "The stop order will be cancelled when it expires."
  EXPIRY_STRATEGY_CANCELS
  "The stop order will be submitted when the expiry time is reached."
  EXPIRY_STRATEGY_SUBMIT
}

"Valid stop order trigger direction. The trigger direction determines whether the price should rise above or fall below the stop order trigger."
enum StopOrderTriggerDirection {
  "The price should rise above the trigger."
  TRIGGER_DIRECTION_RISES_ABOVE
  "The price should fall below the trigger."
  TRIGGER_DIRECTION_FALLS_BELOW
}

"Why the proposal was rejected by the core node"
enum ProposalRejectionReason {
  "The specified close time is too early based on network parameters"
  PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON
  "The specified close time is too late based on network parameters"
  PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE
  "The specified enactment time is too early based on network parameters"
  PROPOSAL_ERROR_ENACT_TIME_TOO_SOON
  "The specified enactment time is too late based on network parameters"
  PROPOSAL_ERROR_ENACT_TIME_TOO_LATE
  "The proposer for this proposal has insufficient tokens"
  PROPOSAL_ERROR_INSUFFICIENT_TOKENS
  "The instrument quote name and base name were the same"
  PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY
  "The proposal has no product specified"
  PROPOSAL_ERROR_NO_PRODUCT
  "The specified product is not supported"
  PROPOSAL_ERROR_UNSUPPORTED_PRODUCT
  "The proposal has no trading mode"
  PROPOSAL_ERROR_NO_TRADING_MODE
  "The proposal has an unsupported trading mode"
  PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE
  "The proposal failed node validation"
  PROPOSAL_ERROR_NODE_VALIDATION_FAILED
  "A builtin asset configuration is missing"
  PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD
  "The ERC20 contract address is missing from an ERC20 asset proposal"
  PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS
  "The specified asset for the market proposal is invalid"
  PROPOSAL_ERROR_INVALID_ASSET
  "Proposal terms timestamps are not compatible (Validation < Closing < Enactment)"
  PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS
  "Risk parameters are missing from the market proposal"
  PROPOSAL_ERROR_NO_RISK_PARAMETERS
  "Invalid key in update network parameter proposal"
  PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_KEY
  "Invalid value in update network parameter proposal"
  PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_VALUE
  "Validation failed for network parameter proposal"
  PROPOSAL_ERROR_NETWORK_PARAMETER_VALIDATION_FAILED
  "Opening auction duration is less than the network minimum opening auction time"
  PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_SMALL
  "Opening auction duration is more than the network minimum opening auction time"
  PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_LARGE
  "Market proposal is missing a liquidity commitment"
  PROPOSAL_ERROR_MARKET_MISSING_LIQUIDITY_COMMITMENT
  "Market could not be created"
  PROPOSAL_ERROR_COULD_NOT_INSTANTIATE_MARKET
  "Market proposal market contained invalid product definition"
  PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT
  "Market proposal is missing commitment amount"
  PROPOSAL_ERROR_MISSING_COMMITMENT_AMOUNT
  "Market proposal has invalid fee amount"
  PROPOSAL_ERROR_INVALID_FEE_AMOUNT
  "Market proposal has one or more invalid liquidity shapes"
  PROPOSAL_ERROR_INVALID_SHAPE
  "Market proposal uses an invalid risk parameter"
  PROPOSAL_ERROR_INVALID_RISK_PARAMETER
  "Proposal declined because the majority threshold was not reached"
  PROPOSAL_ERROR_MAJORITY_THRESHOLD_NOT_REACHED
  "Proposal declined because the participation threshold was not reached"
  PROPOSAL_ERROR_PARTICIPATION_THRESHOLD_NOT_REACHED
  "Asset details are invalid"
  PROPOSAL_ERROR_INVALID_ASSET_DETAILS
  "Too many price monitoring triggers specified in market"
  PROPOSAL_ERROR_TOO_MANY_PRICE_MONITORING_TRIGGERS
  "Too many decimal places specified in market"
  PROPOSAL_ERROR_TOO_MANY_MARKET_DECIMAL_PLACES
  "The market is invalid"
  PROPOSAL_ERROR_INVALID_MARKET
  "The proposal is rejected because the party does not have enough equity-like share in the market"
  PROPOSAL_ERROR_INSUFFICIENT_EQUITY_LIKE_SHARE
  "Unknown proposal type"
  PROPOSAL_ERROR_UNKNOWN_TYPE
  "Unknown risk parameters"
  PROPOSAL_ERROR_UNKNOWN_RISK_PARAMETER_TYPE
  "Freeform proposal is invalid"
  PROPOSAL_ERROR_INVALID_FREEFORM
  "The ERC-20 address specified by this proposal is already in use by another asset"
  PROPOSAL_ERROR_ERC20_ADDRESS_ALREADY_IN_USE
  "The governance transfer proposal is invalid"
  PROPOSAL_ERROR_GOVERNANCE_TRANSFER_PROPOSAL_INVALID
  "The governance transfer proposal has failed"
  PROPOSAL_ERROR_GOVERNANCE_TRANSFER_PROPOSAL_FAILED
  "The proposal for cancellation of an active governance transfer has failed"
  PROPOSAL_ERROR_GOVERNANCE_CANCEL_TRANSFER_PROPOSAL_INVALID
  "Validation of spot market proposal failed"
  PROPOSAL_ERROR_INVALID_SPOT
  "Spot trading is disabled"
  PROPOSAL_ERROR_SPOT_PRODUCT_DISABLED
  "Validation of successor market has failed"
  PROPOSAL_ERROR_INVALID_SUCCESSOR_MARKET
  "Validation of market state update has failed"
  PROPOSAL_ERROR_INVALID_MARKET_STATE_UPDATE
  "Validation of liquidity provision SLA parameters has failed"
  PROPOSAL_ERROR_MISSING_SLA_PARAMS
  "Mandatory liquidity provision SLA parameters are missing from the proposal"
  PROPOSAL_ERROR_INVALID_SLA_PARAMS
  "Perpetual market proposal contained invalid product definition"
  PROPOSAL_ERROR_INVALID_PERPETUAL_PRODUCT
}

"Why the order was rejected by the core node"
enum OrderRejectionReason {
  "Market ID is invalid"
  ORDER_ERROR_INVALID_MARKET_ID

  "Order ID is invalid"
  ORDER_ERROR_INVALID_ORDER_ID

  "Order is out of sequence"
  ORDER_ERROR_OUT_OF_SEQUENCE

  "Remaining size in the order is invalid"
  ORDER_ERROR_INVALID_REMAINING_SIZE

  "Time has failed us"
  ORDER_ERROR_TIME_FAILURE

  "Unable to remove the order"
  ORDER_ERROR_REMOVAL_FAILURE

  "Expiration time is invalid"
  ORDER_ERROR_INVALID_EXPIRATION_DATETIME

  "Order reference is invalid"
  ORDER_ERROR_INVALID_ORDER_REFERENCE

  "Edit is not allowed"
  ORDER_ERROR_EDIT_NOT_ALLOWED

  "Amending the order failed"
  ORDER_ERROR_AMEND_FAILURE

  "Order does not exist"
  ORDER_ERROR_NOT_FOUND

  "Party ID is invalid"
  ORDER_ERROR_INVALID_PARTY_ID

  "Market is closed"
  ORDER_ERROR_MARKET_CLOSED

  "Margin check failed - not enough available margin"
  ORDER_ERROR_MARGIN_CHECK_FAILED

  "Order missing general account"
  ORDER_ERROR_MISSING_GENERAL_ACCOUNT

  "An internal error happened"
  ORDER_ERROR_INTERNAL_ERROR

  "Invalid size"
  ORDER_ERROR_INVALID_SIZE

  "Invalid persistence"
  ORDER_ERROR_INVALID_PERSISTENCE

  "Invalid type"
  ORDER_ERROR_INVALID_TYPE

  "Order cannot be filled because it would require self trading"
  ORDER_ERROR_SELF_TRADING

  "Insufficient funds to pay fees"
  ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES

  "Invalid Time In Force"
  ORDER_ERROR_INVALID_TIME_IN_FORCE

  "Attempt to amend order to Good til Time without expiry time"
  ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT

  "Attempt to amend expiry time to a value before time order was created"
  ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT

  "Attempt to amend to Good till Cancelled without an expiry time"
  ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT

  "Amending to Fill or Kill, or Immediate or Cancel is invalid"
  ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC

  "Amending to Good for Auction or Good for Normal is invalid"
  ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN

  "Amending from Good for Auction or Good for Normal is invalid"
  ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN

  "Good for Normal order received during an auction"
  ORDER_ERROR_CANNOT_SEND_GFN_ORDER_DURING_AN_AUCTION

  "Good for Auction order received during continuous trading"
  ORDER_ERROR_CANNOT_SEND_GFA_ORDER_DURING_CONTINUOUS_TRADING

  "Cannot send IOC orders during an auction"
  ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION

  "Cannot send FOK orders during an auction"
  ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION

  "Pegged orders must be limit orders"
  ORDER_ERROR_MUST_BE_LIMIT_ORDER

  "Pegged orders can only have a time in force of Good til Cancelled or Good til Time"
  ORDER_ERROR_MUST_BE_GTT_OR_GTC

  "Pegged order must have a reference price"
  ORDER_ERROR_WITHOUT_REFERENCE_PRICE

  "Buy pegged order cannot reference best ask price"
  ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE

  "Pegged order offset must be >= 0"
  ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO

  "Sell pegged order cannot reference best bid price"
  ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE

  "Pegged order offset must be > zero"
  ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO

  "Insufficient balance to submit the order (no deposit made)"
  ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE

  "Cannot change pegged order fields on a non pegged order"
  ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER

  "Unable to reprice a pegged order"
  ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER

  "Unable to amend pegged order price"
  ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER

  "Non-persistent order exceeds price bounds"
  ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS

  "Order was submitted with an incorrect or invalid market type"
  ORDER_ERROR_INCORRECT_MARKET_TYPE

  "Unable to submit pegged order, temporarily too many pegged orders across all markets"
  ORDER_ERROR_TOO_MANY_PEGGED_ORDERS

  "A reduce-ony order would not reduce the party's position and thus it has been rejected"
  ORDER_ERROR_REDUCE_ONLY_ORDER_WOULD_NOT_REDUCE

  "A post-only order would produce an aggressive trade and thus it has been rejected"
  ORDER_ERROR_POST_ONLY_ORDER_WOULD_TRADE

  "Party has insufficient funds to cover for the order margin for the new or amended order"
  ORDER_ERROR_ISOLATED_MARGIN_CHECK_FAILED

  "Pegged orders are not allowed for a party in isolated margin mode"
  ORDER_ERROR_PEGGED_ORDERS_NOT_ALLOWED_IN_ISOLATED_MARGIN_MODE
}

"Types of orders"
enum OrderType {
  "An order to buy or sell at the market's current best available price"
  TYPE_MARKET

  "Order that uses a pre-specified price to buy or sell"
  TYPE_LIMIT

  """
  Used for distressed parties, an order placed by the network to close out distressed parties
  similar to market order, only no party is attached to the order.
  """
  TYPE_NETWORK
}

"The current state of a market"
enum MarketState {
  "The governance proposal valid and accepted"
  STATE_PROPOSED
  "Outcome of governance votes is to reject the market"
  STATE_REJECTED
  "Governance vote passes/wins"
  STATE_PENDING
  """
  Market triggers cancellation condition or governance
  votes to close before market becomes Active
  """
  STATE_CANCELLED
  "Enactment date reached and usual auction exit checks pass"
  STATE_ACTIVE
  "Price monitoring or liquidity monitoring trigger"
  STATE_SUSPENDED
  "Market suspended via governance"
  STATE_SUSPENDED_VIA_GOVERNANCE
  "Governance vote (to close)"
  STATE_CLOSED
  """
  Defined by the product (i.e. from a product parameter,
  specified in market definition, giving close date/time)
  """
  STATE_TRADING_TERMINATED
  "Settlement triggered and completed as defined by product"
  STATE_SETTLED
}

"What market trading mode is the market in"
enum MarketTradingMode {
  "Continuous trading where orders are processed and potentially matched on arrival"
  TRADING_MODE_CONTINUOUS

  "Auction trading where orders are uncrossed at the end of the opening auction period"
  TRADING_MODE_OPENING_AUCTION

  "Auction as normal trading mode for the market, where orders are uncrossed periodically"
  TRADING_MODE_BATCH_AUCTION

  "Auction triggered by price/liquidity monitoring"
  TRADING_MODE_MONITORING_AUCTION

  "No trading allowed"
  TRADING_MODE_NO_TRADING

  "Special auction mode triggered via governance market suspension"
  TRADING_MODE_SUSPENDED_VIA_GOVERNANCE
}

"Whether the placer of an order is aiming to buy or sell on the market"
enum Side {
  "Unspecified is only used for trades at the end of an auction, where neither party acts as the aggressor."
  SIDE_UNSPECIFIED
  "The placer of the order is aiming to buy"
  SIDE_BUY

  "The placer of the order is aiming to sell"
  SIDE_SELL
}

"The interval for trade candles when subscribing via Vega GraphQL, default is I15M"
enum Interval {
  "The block interval is not a fixed amount of time, rather it used to indicate grouping of events that occur in a single block. It is usually about a second."
  INTERVAL_BLOCK
  "1 minute interval"
  INTERVAL_I1M
  "5 minute interval"
  INTERVAL_I5M
  "15 minute interval (default)"
  INTERVAL_I15M
  "30 minute interval"
  INTERVAL_I30M
  "1 hour interval"
  INTERVAL_I1H
  "4 hour interval"
  INTERVAL_I4H
  "6 hour interval"
  INTERVAL_I6H
  "8 hour interval"
  INTERVAL_I8H
  "12 hour interval"
  INTERVAL_I12H
  "1 day interval"
  INTERVAL_I1D
  "7 day interval"
  INTERVAL_I7D
}

"The various account types in Vega (used by collateral)"
enum AccountType {
  "Insurance pool account - only for 'system' party"
  ACCOUNT_TYPE_INSURANCE
  "Global insurance pool account for an asset"
  ACCOUNT_TYPE_GLOBAL_INSURANCE
  "Settlement - only for 'system' party"
  ACCOUNT_TYPE_SETTLEMENT
  """
  Margin - The leverage account for parties, contains funds set aside for the margin needed to support
  a party's open positions. Each party will have a margin account for each market they have traded in.
  The required initial margin is allocated to each market from the general account, and it cannot be withdrawn
  or used as margin on another market until it's released back into the general account.
  The protocol uses an internal accounting system to segregate funds held as margin from other funds
  to ensure they are never lost or 'double spent'
  """
  ACCOUNT_TYPE_MARGIN
  "General account - the account containing 'unused' collateral for parties"
  ACCOUNT_TYPE_GENERAL
  "Infrastructure fee account - the account where all infrastructure fees are collected"
  ACCOUNT_TYPE_FEES_INFRASTRUCTURE
  "Liquidity fee account - the account contains fees earned by providing liquidity"
  ACCOUNT_TYPE_FEES_LIQUIDITY
  "Market maker fee account - holds fees paid to the passive side when a trade matches"
  ACCOUNT_TYPE_FEES_MAKER
  "Bond - an account use to maintain liquidity commitments"
  ACCOUNT_TYPE_BOND
  "External - an account use to refer to external account"
  ACCOUNT_TYPE_EXTERNAL
  "GlobalReward - a global account for the reward pool"
  ACCOUNT_TYPE_GLOBAL_REWARD
  "PendingTransfers - a global account for the pending transfers pool"
  ACCOUNT_TYPE_PENDING_TRANSFERS
  "RewardMakerPaidFees - an account holding rewards for maker paid fees"
  ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES
  "RewardMakerReceivedFees - an account holding rewards for maker received fees"
  ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES
  "RewardLpReceivedFees - an account holding rewards for a liquidity provider's received fees"
  ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES
  "RewardMarketProposers - an account holding rewards for market proposers"
  ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS
  "AccountTypeHolding - an account for holding funds covering for active unfilled orders"
  ACCOUNT_TYPE_HOLDING
  "Per liquidity provider, per market account for holding LPs' fees before distribution"
  ACCOUNT_TYPE_LP_LIQUIDITY_FEES
  "Network treasury, per-asset treasury controlled by the network"
  ACCOUNT_TYPE_NETWORK_TREASURY
  "Vesting reward account is a per party per asset account for locked reward funds waiting to be vested"
  ACCOUNT_TYPE_VESTING_REWARDS
  "Vested reward account is a per party per asset account for vested reward funds"
  ACCOUNT_TYPE_VESTED_REWARDS
  "Average position reward account is a per asset per market account for average position reward funds"
  ACCOUNT_TYPE_REWARD_AVERAGE_POSITION
  "Relative return reward account is a per asset per market account for relative return reward funds"
  ACCOUNT_TYPE_REWARD_RELATIVE_RETURN
  "Return volatility reward account is a per asset per market account for return volatility reward funds"
  ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY
  "Validator ranking reward account is a per asset account for validator ranking reward funds"
  ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING
  "Holds pending rewards to be paid to the referrer of a party out of fees paid by the taker"
  ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD
  "Per asset market account for party in isolated margin mode"
  ACCOUNT_TYPE_ORDER_MARGIN
}

"Types that describe why a transfer has been made"
enum TransferType {
  "Default value, always invalid"
  TRANSFER_TYPE_UNSPECIFIED
  "Funds deducted after final settlement loss"
  TRANSFER_TYPE_LOSS
  "Funds added to general account after final settlement gain"
  TRANSFER_TYPE_WIN
  "Funds deducted from margin account after mark to market loss"
  TRANSFER_TYPE_MTM_LOSS
  "Funds added to margin account after mark to market gain"
  TRANSFER_TYPE_MTM_WIN
  "Funds transferred from general account to meet margin requirement"
  TRANSFER_TYPE_MARGIN_LOW
  "Excess margin amount returned to general account"
  TRANSFER_TYPE_MARGIN_HIGH
  "Margin confiscated from margin account to fulfil closeout"
  TRANSFER_TYPE_MARGIN_CONFISCATED
  "Maker fee paid from general account"
  TRANSFER_TYPE_MAKER_FEE_PAY
  "Maker fee received into general account"
  TRANSFER_TYPE_MAKER_FEE_RECEIVE
  "Infrastructure fee paid from general account"
  TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY
  "Infrastructure fee received into general account"
  TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE
  "Liquidity fee paid from general account"
  TRANSFER_TYPE_LIQUIDITY_FEE_PAY
  "Liquidity fee received into general account"
  TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE
  "Bond account funded from general account to meet required bond amount"
  TRANSFER_TYPE_BOND_LOW
  "Bond returned to general account after liquidity commitment was reduced"
  TRANSFER_TYPE_BOND_HIGH
  "Funds withdrawn from general account"
  TRANSFER_TYPE_WITHDRAW
  "Funds deposited to general account"
  TRANSFER_TYPE_DEPOSIT
  "Bond account penalised when liquidity commitment not met"
  TRANSFER_TYPE_BOND_SLASHING
  "Reward payout received"
  TRANSFER_TYPE_REWARD_PAYOUT
  "A network internal instruction for the collateral engine to move funds from a user's general account into the pending transfers pool"
  TRANSFER_TYPE_TRANSFER_FUNDS_SEND
  "A network internal instruction for the collateral engine to move funds from the pending transfers pool account into the destination account"
  TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE
  "Market-related accounts emptied because market has closed"
  TRANSFER_TYPE_CLEAR_ACCOUNT
  "Balances are being restored to the user's account following a checkpoint restart of the network"
  TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE
  "Spot trade delivery"
  TRANSFER_TYPE_SPOT
  "An internal instruction to transfer a quantity corresponding to an active spot order from a general account into a party holding account"
  TRANSFER_TYPE_HOLDING_LOCK
  "An internal instruction to transfer an excess quantity corresponding to an active spot order from a holding account into a party general account"
  TRANSFER_TYPE_HOLDING_RELEASE
  "Insurance pool fraction transfer from parent to successor market."
  TRANSFER_TYPE_SUCCESSOR_INSURANCE_FRACTION
  "Allocates liquidity fee earnings to each liquidity provider's network controlled liquidity fee account."
  TRANSFER_TYPE_LIQUIDITY_FEE_ALLOCATE
  "Distributes net fee earnings from liquidity provider's fee account to their general account."
  TRANSFER_TYPE_LIQUIDITY_FEE_NET_DISTRIBUTE
  "Applies SLA penalty by moving funds from party's bond account to market's insurance pool."
  TRANSFER_TYPE_SLA_PENALTY_BOND_APPLY
  "Applies SLA penalty by moving funds from the liquidity provider's fee account to market insurance pool."
  TRANSFER_TYPE_SLA_PENALTY_LP_FEE_APPLY
  "Collects penalties from the liquidity provider's fee account before the fee revenue is paid, and transfers it to the market's bonus distribution account."
  TRANSFER_TYPE_LIQUIDITY_FEE_UNPAID_COLLECT
  "Distributes performance bonus from market bonus to liquidity provider's general account."
  TRANSFER_TYPE_SLA_PERFORMANCE_BONUS_DISTRIBUTE
  "Funds deducted from margin account after a perpetuals funding loss."
  TRANSFER_TYPE_PERPETUALS_FUNDING_LOSS
  "Funds added to margin account after a perpetuals funding gain."
  TRANSFER_TYPE_PERPETUALS_FUNDING_WIN
  "Funds moved from the vesting account to the vested account once the vesting period is reached."
  TRANSFER_TYPE_REWARDS_VESTED
  "Funds moved from general account to order margin account."
  TRANSFER_TYPE_ORDER_MARGIN_LOW
  "Funds released from order margin account to general."
  TRANSFER_TYPE_ORDER_MARGIN_HIGH
  "Funds moved from order margin account to margin account."
  TRANSFER_TYPE_ISOLATED_MARGIN_LOW
}

union ProductConfiguration = FutureProduct | SpotProduct | PerpetualProduct

type FutureProduct {
  "Product asset"
  settlementAsset: Asset!
  "String representing the quote (e.g. BTCUSD -> USD is quote)"
  quoteName: String!
  """
  Describes the data source data that an instrument wants to get from the data source engine for settlement data.
  """
  dataSourceSpecForSettlementData: DataSourceDefinition!
  """
  Describes the source data that an instrument wants to get from the data source engine for trading termination.
  """
  dataSourceSpecForTradingTermination: DataSourceDefinition!
  """
  DataSourceSpecToFutureBinding tells on which property source data should be
  used as settlement data.
  """
  dataSourceSpecBinding: DataSourceSpecToFutureBinding!
}

type SpotProduct {
  "Underlying base asset for the spot product"
  baseAsset: Asset!
  "Underlying quote asset for the spot product"
  quoteAsset: Asset!
  "Name of the instrument"
  name: String!
}

type PerpetualProduct {
  "Underlying asset for the perpetual instrument"
  settlementAsset: Asset!
  "Quote name of the instrument"
  quoteName: String!
  "Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]"
  marginFundingFactor: String!
  "Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]"
  interestRate: String!
  "Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]"
  clampLowerBound: String!
  "Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]"
  clampUpperBound: String!
  "Data source specification describing the data source for settlement schedule"
  dataSourceSpecForSettlementSchedule: DataSourceDefinition!
  "Data source specification describing the data source for settlement"
  dataSourceSpecForSettlementData: DataSourceDefinition!
  "Binding between the data source spec and the settlement data"
  dataSourceSpecBinding: DataSourceSpecPerpetualBinding!
  "Factor applied to funding-rates. This scales the impact that spot price deviations have on funding payments."
  fundingRateScalingFactor: String
  "Lower bound for the funding-rate such that the funding-rate will never be lower than this value"
  fundingRateLowerBound: String
  "Upper bound for the funding-rate such that the funding-rate will never be higher than this value"
  fundingRateUpperBound: String
}

"""
DataSourceSpecConfiguration describes the source data that an instrument wants to get from the
sourcing engine.
"""
type DataSourceSpecConfiguration {
  """
  Signers is the list of authorized signatures that signed the data for this
  data source. All the public keys in the data should be contained in this
  list.
  """
  signers: [Signer!]

  """
  Filters describes which source data are considered of interest or not for
  the product (or the risk model).
  """
  filters: [Filter!]
}

"""
EthCallTrigger is the type of trigger used to make calls to Ethereum network.
"""
type EthCallTrigger {
  trigger: TriggerKind!
}

union TriggerKind = EthTimeTrigger

"""
Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.
"""
type EthTimeTrigger {
  "Trigger when the Ethereum time is greater or equal to this time, in Unix seconds."
  initial: Timestamp
  """
  Repeat the call every n seconds after the initial call. If no time for
  initial call was specified, begin repeating immediately.
  """
  every: Int
  """
  If repeating, stop once Ethereum time is greater than this time, in Unix
  seconds. If not set, then repeat indefinitely.
  """
  until: Timestamp
}

"""
Normaliser to convert the data returned from the contract method
into a standard format.
"""
type Normaliser {
  name: String!
  expression: String!
}

"""
Specifies a data source that derives its content from calling a read method
on an Ethereum contract.
"""
type EthCallSpec {
  "Ethereum address of the contract to call."
  address: String!
  "The ABI of that contract."
  abi: [String!]
  "Name of the method on the contract to call."
  method: String!
  """
  List of arguments to pass to method call.
  Protobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum
  type according to the ABI.
  """
  args: [String!]
  "Conditions for determining when to call the contract method."
  trigger: EthCallTrigger!
  "Number of confirmations required before the query is considered verified."
  requiredConfirmations: Int!
  """
  Normalisers are used to convert the data returned from the contract method
  into a standard format.
  """
  normalisers: [Normaliser!]
  "Filters the data returned from the contract method."
  filters: [Filter!]
  "The ID of the EVM based chain which is to be used to source the oracle data."
  sourceChainId: Int!
}

type InstrumentConfiguration {
  "Full and fairly descriptive name for the instrument"
  name: String!
  "A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)"
  code: String!
  "Future product specification"
  futureProduct: FutureProduct
  "Product specification"
  product: ProductConfiguration
}

type NewMarket {
  "New market instrument configuration"
  instrument: InstrumentConfiguration!
  "Decimal places used for the new market, sets the smallest price increment on the book"
  decimalPlaces: Int!
  "New market risk configuration"
  riskParameters: RiskModel!
  "Metadata for this instrument, tags"
  metadata: [String!]
  "Price monitoring parameters"
  priceMonitoringParameters: PriceMonitoringParameters!
  "Liquidity monitoring parameters"
  liquidityMonitoringParameters: LiquidityMonitoringParameters!
  "Decimal places for order sizes, sets what size the smallest order / position on the market can be"
  positionDecimalPlaces: Int!
  "Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume"
  linearSlippageFactor: String!
  "Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume"
  quadraticSlippageFactor: String!
    @deprecated(reason: "This field will be removed in a future release")
  "Successor market configuration. If this proposed market is meant to succeed a given market, then this needs to be set."
  successorConfiguration: SuccessorConfiguration
  "Liquidity SLA Parameters"
  liquiditySLAParameters: LiquiditySLAParameters
  "Specifies how the liquidity fee for the market will be calculated"
  liquidityFeeSettings: LiquidityFeeSettings
  "Liquidation strategy for the market"
  liquidationStrategy: LiquidationStrategy
  "Configuration for mark price calculation for the market"
  markPriceConfiguration: CompositePriceConfiguration!
  "The market minimum tick size"
  tickSize: String!
}

type CompositePriceConfiguration {
  "Decay weight used in calculating time weight for a given trade"
  decayWeight: String!
  "Decay power used in calculating time weight for a given trade"
  decayPower: Int!
  "Cash amount used in calculating mark price from the order book"
  cashAmount: String!
  "Weights for each given price source, first entry is price from trade, then price from book, then first oracle, next oracle, etc. And last entry is for median price"
  SourceWeights: [String!]
  "Staleness tolerance duration for each given price sources in the order mentioned above"
  SourceStalenessTolerance: [String!]!
  "Composite price calculation methodology"
  CompositePriceType: CompositePriceType!
  "Oracle configuration for external composite price sources"
  dataSourcesSpec: [DataSourceDefinition]
  "Spec bindings for external composite price sources"
  dataSourcesSpecBinding: [SpecBindingForCompositePrice]
}

type SuccessorConfiguration {
  "ID of the market this proposal will succeed"
  parentMarketId: String!
  "Decimal value between 0 and 1, specifying the fraction of the insurance pool balance is carried over from the parent market to the successor."
  insurancePoolFraction: String!
}

"""
Incomplete change definition for governance proposal terms
TODO: complete the type
"""
type UpdateMarket {
  marketId: ID!
  updateMarketConfiguration: UpdateMarketConfiguration!
}

type UpdateMarketConfiguration {
  "Updated futures market instrument configuration."
  instrument: UpdateInstrumentConfiguration!
  "Optional futures market metadata, tags."
  metadata: [String]
  "Price monitoring parameters."
  priceMonitoringParameters: PriceMonitoringParameters!
  "Liquidity monitoring parameters."
  liquidityMonitoringParameters: LiquidityMonitoringParameters!
  "Updated futures market risk model parameters."
  riskParameters: UpdateMarketRiskParameters!
  "Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume."
  linearSlippageFactor: String!
  "Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume."
  quadraticSlippageFactor: String!
    @deprecated(reason: "This field will be removed in a future release")
  "Liquidity SLA Parameters."
  liquiditySLAParameters: LiquiditySLAParameters
  "Specifies how the liquidity fee for the market will be calculated"
  liquidityFeeSettings: LiquidityFeeSettings
  "Liquidation strategy for the market"
  liquidationStrategy: LiquidationStrategy
  "Configuration for mark price calculation for the market"
  markPriceConfiguration: CompositePriceConfiguration
  "The market minimum tick size"
  tickSize: String!
}

type UpdateInstrumentConfiguration {
  code: String!
  name: String!
  product: UpdateProductConfiguration!
}

union UpdateProductConfiguration = UpdateFutureProduct | UpdatePerpetualProduct

type UpdateFutureProduct {
  quoteName: String!
  dataSourceSpecForSettlementData: DataSourceDefinition!
  dataSourceSpecForTradingTermination: DataSourceDefinition!
  dataSourceSpecBinding: DataSourceSpecToFutureBinding!
}

type UpdatePerpetualProduct {
  "Quote name of the instrument"
  quoteName: String!
  "Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]"
  marginFundingFactor: String!
  "Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]"
  interestRate: String!
  "Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]"
  clampLowerBound: String!
  "Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]"
  clampUpperBound: String!
  "Data source specification describing the data source for settlement schedule"
  dataSourceSpecForSettlementSchedule: DataSourceDefinition!
  "Data source specification describing the data source for settlement"
  dataSourceSpecForSettlementData: DataSourceDefinition!
  "Binding between the data source spec and the settlement data"
  dataSourceSpecBinding: DataSourceSpecPerpetualBinding!
  "Factor applied to funding-rates. This scales the impact that spot price deviations have on funding payments."
  fundingRateScalingFactor: String
  "Lower bound for the funding-rate such that the funding-rate will never be lower than this value"
  fundingRateLowerBound: String
  "Upper bound for the funding-rate such that the funding-rate will never be higher than this value"
  fundingRateUpperBound: String
}

union UpdateMarketRiskParameters =
    UpdateMarketSimpleRiskModel
  | UpdateMarketLogNormalRiskModel

type UpdateMarketSimpleRiskModel {
  simple: SimpleRiskModelParams
}

type UpdateMarketLogNormalRiskModel {
  logNormal: LogNormalRiskModel
}

"A new asset proposal change"
type NewAsset {
  "The full name of the asset (e.g: Great British Pound)"
  name: String!

  "The symbol of the asset (e.g: GBP)"
  symbol: String!

  "The precision of the asset"
  decimals: Int!

  "The minimum economically meaningful amount of this specific asset"
  quantum: String!

  "The source of the new asset"
  source: AssetSource!
}

"A proposal to update an asset's details"
type UpdateAsset {
  "The minimum economically meaningful amount of this specific asset"
  quantum: String!

  "The source of the updated asset"
  source: UpdateAssetSource!

  "The asset to update"
  assetId: ID!
}

"""
A new freeform proposal change. It has no properties on purpose. Use proposal
rationale, instead.
"""
type NewFreeform {
  "A placeholder to please graphQL"
  _doNotUse: Boolean
}

enum GovernanceTransferType {
  "Default value, always invalid"
  GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED
  "Transfers the specified amount or does not transfer anything"
  GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING
  "Transfers the specified amount or the max allowable amount if this is less than the specified amount"
  GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT
}

type NewTransfer {
  "The source account"
  source: String!
  "The type of source account"
  sourceType: AccountType!
  "The destination account"
  destination: String!
  "The type of destination account"
  destinationType: AccountType!
  "The asset to transfer"
  asset: Asset!
  "The fraction of the balance to be transferred"
  fraction_of_balance: String!
  "The maximum amount to be transferred"
  amount: String!
  "The type of the governance transfer"
  transferType: GovernanceTransferType!
  "The type of governance transfer being made, i.e. a one-off or recurring transfer"
  kind: GovernanceTransferKind!
}

union GovernanceTransferKind =
    OneOffGovernanceTransfer
  | RecurringGovernanceTransfer

"Allows for cancellation of an existing governance transfer"
type CancelTransfer {
  "The governance transfer to cancel"
  transferId: ID!
}

"Allows submitting a proposal for changing network parameters"
type UpdateNetworkParameter {
  networkParameter: NetworkParameter!
}

enum MarketUpdateType {
  "Default value, always invalid"
  MARKET_STATE_UPDATE_TYPE_UNSPECIFIED
  "Terminate the market"
  MARKET_STATE_UPDATE_TYPE_TERMINATE
  "Suspend the market"
  MARKET_STATE_UPDATE_TYPE_SUSPEND
  "Resume a suspended market"
  MARKET_STATE_UPDATE_TYPE_RESUME
}

type UpdateMarketState {
  "The market for which to update the state"
  market: Market!
  "The type of update"
  updateType: MarketUpdateType!
  "Optional settlement price for terminating and settling futures market. Must be empty for other types of updates and other types of markets"
  price: String
}

type UpdateReferralProgram {
  "Defined tiers in increasing order. First element will give Tier 1, second element will give Tier 2, etc."
  benefitTiers: [BenefitTier!]!
  "Timestamp as Unix time in nanoseconds, after which when the current epoch ends, the program will end and benefits will be disabled."
  endOfProgramTimestamp: Timestamp!
  "Number of epochs over which to evaluate a referral set's running volume."
  windowLength: Int!
  """
  Defined staking tiers in increasing order. First element will give Tier 1,
  second element will give Tier 2, and so on. Determines the level of
  benefit a party can expect based on their staking.
  """
  stakingTiers: [StakingTier!]!
}

type BenefitTier {
  "The minimum number of epochs the party needs to be in the referral set to be eligible for the benefit"
  minimumEpochs: Int!
  "The minimum running notional for the given benefit tier"
  minimumRunningNotionalTakerVolume: String!
  "The proportion of the referee's taker fees to be discounted"
  referralDiscountFactor: String!
  "The proportion of the referee's taker fees to be rewarded to the referrer"
  referralRewardFactor: String!
}

type StakingTier {
  "Required number of governance tokens ($VEGA) a referrer must have staked to receive the multiplier"
  minimumStakedTokens: String!
  "Multiplier applied to the referral reward factor when calculating referral rewards due to the referrer"
  referralRewardMultiplier: String!
}

type UpdateVolumeDiscountProgram {
  "The benefit tiers for the program"
  benefitTiers: [VolumeBenefitTier!]!
  "Timestamp as Unix time in nanoseconds, after which program ends."
  endOfProgramTimestamp: Timestamp!
  "The window length to consider for the volume discount program"
  windowLength: Int!
}

type VolumeBenefitTier {
  "The minimum running notional for the given benefit tier"
  minimumRunningNotionalTakerVolume: String!
  "Discount given to those in this benefit tier"
  volumeDiscountFactor: String!
}

"Configuration for a new spot market on Vega"
type NewSpotMarket {
  "New spot market instrument configuration"
  instrument: InstrumentConfiguration!
  "Decimal places used for the new market, sets the smallest price increment on the book"
  decimal_places: Int!
  "Optional spot market metadata tags"
  metadata: [String!]!
  "Price monitoring parameters"
  priceMonitoringParameters: PriceMonitoringParameters!
  "Specifies parameters related to liquidity target stake calculation"
  targetStakeParameters: TargetStakeParameters!
  "New spot market risk model parameters"
  riskParameters: RiskModel
  "Decimal places for order sizes, sets what size the smallest order / position on the spot market can be"
  positionDecimalPlaces: Int!
  "Specifies the liquidity provision SLA parameters"
  liquiditySLAParams: LiquiditySLAParameters!
  "Specifies how the liquidity fee for the market will be calculated"
  liquidityFeeSettings: LiquidityFeeSettings
  "The market minimum tick size"
  tickSize: String!
}

"Update an existing spot market on Vega"
type UpdateSpotMarket {
  "Market ID the update is for"
  marketId: ID!
  "Updated configuration of the spot market"
  updateSpotMarketConfiguration: UpdateSpotMarketConfiguration!
}

type UpdateSpotMarketConfiguration {
  "Optional spot market metadata tags"
  metadata: [String!]!
  "Price monitoring parameters"
  priceMonitoringParameters: PriceMonitoringParameters!
  "Specifies parameters related to target stake calculation"
  targetStakeParameters: TargetStakeParameters!
  "Update spot market risk model parameters"
  riskParameters: RiskModel!
  "Specifies the liquidity provision SLA parameters"
  liquiditySLAParams: LiquiditySLAParameters!
  "Specifies how the liquidity fee for the market will be calculated"
  liquidityFeeSettings: LiquidityFeeSettings
  "The market minimum tick size"
  tickSize: String!
}

type LiquiditySLAParameters {
  priceRange: String!
  "Specifies the minimum fraction of time LPs must spend 'on the book' providing their committed liquidity"
  commitmentMinTimeFraction: String!
  "Specifies the number of liquidity epochs over which past performance will continue to affect rewards"
  performanceHysteresisEpochs: Int!
  """
  Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will
  lose to liquidity providers that achieved a higher SLA performance than them.
  """
  slaCompetitionFactor: String!
}

type LiquidationStrategy {
  "Specifies the interval, in seconds, at which point the network will try to unload its position."
  disposalTimeStep: Int!
  "Specifies the fraction of its position the network will try to reduce its position by in a single disposal attempt."
  disposalFraction: String!
  "Specifies the size of the position held by the network that it will try to dispose of in one attempt."
  fullDisposalSize: Int!
  "Specifies the maximum size by which the network can reduce its position as a fraction of the volume on the book."
  maxFractionConsumed: String!
}

"Representation of a network parameter"
type NetworkParameter {
  "The name of the network parameter"
  key: String!
  "The value of the network parameter"
  value: String!
}

union ProposalChange =
    NewMarket
  | UpdateMarket
  | UpdateNetworkParameter
  | NewAsset
  | UpdateAsset
  | NewFreeform
  | NewTransfer
  | CancelTransfer
  | UpdateMarketState
  | NewSpotMarket
  | UpdateSpotMarket
  | UpdateVolumeDiscountProgram
  | UpdateReferralProgram

# there are no unions for input types as of today, see: https://github.com/graphql/graphql-spec/issues/488

type ProposalRationale {
  """
  Description to show a short title / something in case the link goes offline.
  This is to be between 0 and 20k unicode characters.
  This is mandatory for all proposals.
  """
  description: String!
  """
  Title to be used to give a short description of the proposal in lists.
  This is to be between 0 and 100 unicode characters.
  This is mandatory for all proposals.
  """
  title: String!
}

"The rationale behind the proposal"
type ProposalTerms {
  """
  RFC3339Nano time and date when voting closes for this proposal.
  Constrained by "minClose" and "maxClose" network parameters.
  """
  closingDatetime: Timestamp!
  """
  RFC3339Nano time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
  Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
  Note: Optional as free form proposals do not require it.
  """
  enactmentDatetime: Timestamp

  "RFC3339Nano time and when node validation of the proposal stops, accepted only with new asset proposals"
  validationDatetime: Timestamp

  "Actual change being introduced by the proposal - action the proposal triggers if passed and enacted."
  change: ProposalChange!
}

"Terms for a batch governance proposal"
type BatchProposalTermsChange {
  """
  RFC3339Nano time and date when this proposal will be executed, if it passes.
  Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
  """
  enactmentDatetime: Timestamp

  "Actual change being introduced by the proposal - action the proposal triggers if passed and enacted."
  change: ProposalChange!
}

"The terms for the batch proposal"
type BatchProposalTerms {
  """
  RFC3339Nano time and date when voting closes for this proposal.
  Constrained by "minClose" and "maxClose" network parameters.
  """
  closingDatetime: Timestamp!

  "Actual changes being introduced by the batch proposal - actions the proposal triggers if passed and enacted."
  changes: [BatchProposalTermsChange]!
}

"""
Various proposal types that are supported by Vega
"""
enum ProposalType {
  "Propose a new market"
  TYPE_NEW_MARKET
  "Update an existing market"
  TYPE_UPDATE_MARKET
  "Proposal to change Vega network parameters"
  TYPE_NETWORK_PARAMETERS
  "Proposal to add a new asset"
  TYPE_NEW_ASSET
  "Proposal to create a new freeform proposal"
  TYPE_NEW_FREE_FORM
  "Proposal to update an existing asset"
  TYPE_UPDATE_ASSET
  "Propose a new spot market"
  TYPE_NEW_SPOT_MARKET
  "Update an existing spot market"
  TYPE_UPDATE_SPOT_MARKET
  "Propose a new transfer"
  TYPE_NEW_TRANSFER
  "Proposal to cancel a transfer"
  TYPE_CANCEL_TRANSFER
  "Proposal for updating the state of a market"
  TYPE_UPDATE_MARKET_STATE
  "Proposal to update the referral program"
  TYPE_UPDATE_REFERRAL_PROGRAM
  "Proposal to update the volume discount program"
  TYPE_UPDATE_VOLUME_DISCOUNT_PROGRAM
}

"""
Various states a proposal can transition through:
Open ->
- Passed -> Enacted.
- Rejected.
Proposal can enter Failed state from any other state.
"""
enum ProposalState {
  "Proposal became invalid and cannot be processed"
  STATE_FAILED
  "Proposal is open for voting"
  STATE_OPEN
  "Proposal has gained enough support to be executed"
  STATE_PASSED
  "Proposal didn't get enough votes"
  STATE_DECLINED
  "Proposal could not gain enough support to be executed"
  STATE_REJECTED
  "Proposal has been executed and the changes under this proposal have now been applied"
  STATE_ENACTED
  "Proposal is waiting for the node to run validation"
  STATE_WAITING_FOR_NODE_VOTE
}

type Proposal {
  "Proposal ID that is filled by Vega once proposal reaches the network"
  id: ID
  "A UUID reference to aid tracking proposals on Vega"
  reference: String!
  "Party that prepared the proposal"
  party: Party!
  "State of the proposal"
  state: ProposalState!
  "RFC3339Nano time and date when the proposal reached Vega network"
  datetime: Timestamp!
  "Rationale behind the proposal"
  rationale: ProposalRationale!
  "Terms of the proposal"
  terms: ProposalTerms!
  "Votes cast for this proposal"
  votes: ProposalVotes!
  "Why the proposal was rejected by the core"
  rejectionReason: ProposalRejectionReason
  "Error details of the rejectionReason"
  errorDetails: String
  "Required majority for this proposal to succeed"
  requiredMajority: String!
  "Required participation for this proposal to succeed"
  requiredParticipation: String!
  "Equity-like share required for a market amendment proposal to be enacted (if not met, the proposal will not be enacted), represented as a fraction that can be converted to a percentage"
  requiredLpMajority: String
  "The market share of LPs' equity-like share that must take part in the market amendment vote for the proposal to pass. This means the votes of LPs that have submitted more liquidity to that market, or have been LPs from the start carry more weight. If it requires 50% of a market's equity-like share for a majority, and the proposal receives only YES votes but only LPs with 49% of the equity-like share voted, the proposal will not pass"
  requiredLpParticipation: String
}

type BatchProposal {
  "Proposal ID that is provided by Vega once proposal reaches the network"
  id: ID
  "A UUID reference to aid tracking proposals on Vega"
  reference: String!
  "Party that prepared the proposal"
  party: Party!
  "State of the proposal"
  state: ProposalState!
  "RFC3339Nano time and date when the proposal reached the network"
  datetime: Timestamp!
  "Terms of all the proposals in the batch"
  batchTerms: BatchProposalTerms
  "Rationale behind the proposal"
  rationale: ProposalRationale!
  "Votes cast for this proposal"
  votes: ProposalVotes!
  "Reason the proposal was rejected"
  rejectionReason: ProposalRejectionReason
  "Details of the rejection reason"
  errorDetails: String
  "Required majority for this proposal to succeed"
  requiredMajority: String!
  "Required participation for this proposal to succeed"
  requiredParticipation: String!
  "Equity-like share required for a market amendment proposal to be enacted, represented as a fraction that can be converted to a percentage. If not met, the proposal will not be enacted"
  requiredLpMajority: String
  "The market share of LPs' equity-like share that must take part in a market amendment vote for the proposal to pass. This means the votes of LPs that have submitted more liquidity to that market, or have been LPs from the start carry more weight. If it requires 50% of a market's equity-like share for a majority, and the full batch of proposals receives all YES votes but only LPs with 49% of the equity-like share voted, the proposal will not pass"
  requiredLpParticipation: String
  "Proposals that are part of the batch"
  subProposals: [ProposalDetail]
}

type ProposalDetail {
  "Proposal ID that is provided by Vega once proposal reaches the network"
  id: ID
  "Batch proposal ID that is provided by Vega once proposal reaches the network"
  batchId: ID
  "A UUID reference to aid tracking proposals on Vega"
  reference: String!
  "Party that prepared the proposal"
  party: Party!
  "State of the proposal"
  state: ProposalState!
  "RFC3339Nano time and date when the proposal reached the Vega network"
  datetime: Timestamp!
  "Terms of the proposal"
  terms: ProposalTerms
  "Terms of all the proposals in the batch"
  batchTerms: BatchProposalTerms
  "Rationale behind the proposal"
  rationale: ProposalRationale!
  "Why the proposal was rejected by the core"
  rejectionReason: ProposalRejectionReason
  "Error details of the rejectionReason"
  errorDetails: String
  "Required majority for this proposal to succeed"
  requiredMajority: String!
  "Required participation for this proposal to succeed"
  requiredParticipation: String!
  "Equity-like share required for a market amendment proposal to be enacted (if not met, the proposal will not be enacted), represented as a fraction that can be converted to a percentage"
  requiredLpMajority: String
  "The market share of LPs' equity-like share that must take part in the market amendment vote for the proposal to pass. This means the votes of LPs that have submitted more liquidity to that market, or have been LPs from the start carry more weight. If it requires 50% of a market's equity-like share for a majority, and the proposal receives only YES votes but only LPs with 49% of the equity-like share voted, the proposal will not pass"
  requiredLpParticipation: String
}

type ProposalVotes {
  "Yes votes cast for this proposal"
  yes: ProposalVoteSide!
  "No votes cast for this proposal"
  no: ProposalVoteSide!
}

type ProposalVoteSide {
  "All votes cast for this side"
  votes: [Vote!]
  "Total number of votes cast for this side"
  totalNumber: String!
  "Total weight of governance token from the votes cast for this side"
  totalWeight: String!
  "Total number of governance tokens from the votes cast for this side"
  totalTokens: String!
  "Total equity-like share weight for this side (only for UpdateMarket Proposals)"
  totalEquityLikeShareWeight: String!
}

"Whether a governance vote is yes or no"
enum VoteValue {
  "No votes against a proposal"
  VALUE_NO
  "Yes votes for a proposal"
  VALUE_YES
}

type Vote {
  "The vote value cast"
  value: VoteValue!

  "The party casting the vote"
  party: Party!

  "RFC3339Nano time and date when the vote reached Vega network"
  datetime: Timestamp!

  "The ID of the proposal this vote applies to"
  proposalId: ID!

  "Total number of governance tokens for the party that cast the vote"
  governanceTokenBalance: String!

  "The weight of this vote based on the total of governance token"
  governanceTokenWeight: String!

  "The weight of this vote based on the total equity-like share"
  equityLikeShareWeight: String!

  "The equity-like share weight per market (only for batch proposals)"
  equityLikeSharePerMarket: [EquityLikeShareWeightPerMarket]
}

type EquityLikeShareWeightPerMarket {
  "The market ID"
  marketId: String!
  "The equity-like share weight for this market"
  equityLikeShareWeight: String!
}

type ProposalVote {
  "Cast vote"
  vote: Vote!
  "Proposal ID the vote is cast on"
  proposalId: ID!
}

type TimeUpdate {
  "RFC3339Nano time of new block time"
  timestamp: Timestamp!
}

type MarketEvent {
  "The market ID"
  marketId: ID!
  "The message - market events are used for logging"
  payload: String!
}

type TransferBalance {
  "Account involved in transfer"
  account: AccountDetails!
  "The new balance of the account"
  balance: String!
}

type LedgerEntry {
  "Account from which the asset was taken"
  fromAccountId: AccountDetails!
  "Account to which the balance was transferred"
  toAccountId: AccountDetails!
  "The amount transferred"
  amount: String!
  "Type of ledger entry"
  type: TransferType!
  "RFC3339Nano time at which the transfer was made"
  timestamp: Timestamp!
  "Sender account balance after the transfer"
  fromAccountBalance: String!
  "Receiver account balance after the transfer"
  toAccountBalance: String!
}

type TransferResponse {
  "The ledger entries and balances resulting from a transfer request"
  transfers: [LedgerEntry!]
  "The balances of accounts involved in the transfer"
  balances: [TransferBalance!]
}

type TransferResponses {
  "A group of transfer responses - events from core"
  responses: [TransferResponse!]
}

type PositionResolution {
  "The market ID where position resolution happened"
  marketId: ID!
  "Number of distressed parties on market"
  distressed: Int!
  "Number of parties closed out"
  closed: Int!
  "The mark price at which parties were distressed/closed out"
  markPrice: String!
}

type LossSocialization {
  "The market ID where loss socialization happened"
  marketId: ID!
  "The party that was part of the loss socialization"
  partyId: ID!
  "The amount lost"
  amount: String!
}

type TradeSettlement {
  "The size of the trade"
  size: Int!
  "The price of the trade"
  price: String!
}

type SettlePosition {
  "The market in which a position was settled"
  marketId: ID!
  "The party who settled a position"
  partyId: ID!
  "The settle price"
  price: String!
  "The trades that were settled to close the overall position"
  tradeSettlements: [TradeSettlement!]
}

type SettleDistressed {
  "The market in which a position was closed out"
  marketId: ID!
  "The party that was closed out"
  partyId: ID!
  "The margin taken from distressed party"
  margin: String!
  "The price at which the position was closed out"
  price: String!
}

type MarketTick {
  "The market ID"
  marketId: ID!
  "The block time"
  time: String!
}

type AuctionEvent {
  "The ID of the market that went into auction"
  marketId: ID!
  "Event fired because of auction end"
  leave: Boolean!
  "Event related to opening auction"
  openingAuction: Boolean!
  "RFC3339Nano start time of auction"
  auctionStart: Timestamp!
  "RFC3339Nano optional end time of auction"
  auctionEnd: Timestamp!
  "What triggered the auction"
  trigger: AuctionTrigger!
  "What, if anything, extended the ongoing auction"
  extensionTrigger: AuctionTrigger
}

"Describes the trigger for an auction"
enum AuctionTrigger {
  "Invalid trigger (or no auction)"
  AUCTION_TRIGGER_UNSPECIFIED
  "Auction because market has a frequent batch auction trading mode"
  AUCTION_TRIGGER_BATCH
  "Opening auction"
  AUCTION_TRIGGER_OPENING
  "Price monitoring"
  AUCTION_TRIGGER_PRICE
  "Liquidity monitoring due to unmet target stake"
  AUCTION_TRIGGER_LIQUIDITY_TARGET_NOT_MET
  "Liquidity monitoring due to not being able to deploy LP orders because there's nothing to peg on one or both sides of the book"
  AUCTION_TRIGGER_UNABLE_TO_DEPLOY_LP_ORDERS
  "Auction triggered by governance market suspension"
  AUCTION_TRIGGER_GOVERNANCE_SUSPENSION
}

"Event types"
enum BusEventType {
  "Vega Time has changed"
  TimeUpdate
  "Collateral has deposited in to this Vega network via the bridge"
  Deposit
  "Collateral has been withdrawn from this Vega network via the bridge"
  Withdrawal
  "The results from processing at transaction"
  TransactionResult
}

"Union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind"
union Event = TimeUpdate | Deposit | Withdrawal | TransactionResult

type BusEvent {
  "The ID for this event"
  id: ID!
  "The block hash"
  block: String!
  "The type of event"
  type: BusEventType!
  "The payload - the wrapped event"
  event: Event!
}

"A risk factor emitted by the risk model for a given market"
type RiskFactor {
  "Market the risk factor was emitted for"
  market: String!
  "Short factor"
  short: String!
  "Long factor"
  long: String!
}

"A special order type for liquidity providers"
type LiquidityOrder {
  "The value to which this order is tied"
  reference: PeggedReference!
  "The proportion of the commitment allocated to this order"
  proportion: Int!
  "Offset from the pegged reference"
  offset: String!
}

"Status of a liquidity provision"
enum LiquidityProvisionStatus {
  "An active liquidity provision"
  STATUS_ACTIVE
  "A liquidity provision stopped by the network"
  STATUS_STOPPED
  "A cancelled liquidity provision"
  STATUS_CANCELLED
  "Liquidity provision was invalid and got rejected"
  STATUS_REJECTED
  "The liquidity provision is valid and accepted by the network, but orders aren't deployed"
  STATUS_UNDEPLOYED
  """
  The liquidity provision is valid and accepted by the network, but orders aren't deployed and
  have never been deployed. If when it's possible to deploy them for the first time the
  margin check fails, then they will be cancelled without any penalties.
  """
  STATUS_PENDING
}

type LiquidityOrderReference {
  "The pegged order generated to fulfill this commitment"
  order: Order
  "The liquidity order"
  liquidityOrder: LiquidityOrder!
}

"The command to be sent to the chain for a liquidity provision submission"
type LiquidityProvision {
  "Unique identifier for the provision (set by the system after consensus)"
  id: ID!
  "The party making this commitment"
  party: Party!
  "RFC3339Nano time when the liquidity provision was initially created"
  createdAt: Timestamp!
  "RFC3339Nano time when the liquidity provision was updated"
  updatedAt: Timestamp
  "Market ID for the liquidity provision"
  market: Market!
  "Specified as a unitless number that represents the amount of the market's settlement asset for the commitment."
  commitmentAmount: String!
  "Provider's nominated liquidity fee factor, which is an input to the calculation of liquidity fees on the market, as per setting fees and rewarding liquidity providers."
  fee: String!
  "A set of liquidity sell orders to meet the liquidity provision obligation."
  sells: [LiquidityOrderReference!]!
  "A set of liquidity buy orders to meet the liquidity provision obligation."
  buys: [LiquidityOrderReference!]!
  "The version of this liquidity provision"
  version: String!
  "The current status of this liquidity provision"
  status: LiquidityProvisionStatus!
  "A reference for the orders created to support this liquidity provision"
  reference: String
}

type LiquidityProvisionWithPending {
  current: LiquidityProvision!
  "Liquidity provision that has been updated by the liquidity provider, and has been accepted by the network, but will not be active until the next epoch."
  pending: LiquidityProvision
}

"The command to be sent to the chain for a liquidity provision submission"
type LiquidityProvisionUpdate {
  "Unique identifier for the order (set by the system after consensus)"
  id: ID!
  "The party making this commitment"
  partyID: ID!
  "RFC3339Nano time when the liquidity provision was initially created"
  createdAt: Timestamp!
  "RFC3339Nano time when the liquidity provision was updated"
  updatedAt: Timestamp
  "Market for the order"
  marketID: ID!
  "Specified as a unit-less number that represents the amount of settlement asset of the market."
  commitmentAmount: String!
  "Nominated liquidity fee factor, which is an input to the calculation of liquidity fees on the market, as per setting fees and rewarding liquidity providers."
  fee: String!
  "A set of liquidity sell orders to meet the liquidity provision obligation."
  sells: [LiquidityOrderReference!]!
  "A set of liquidity buy orders to meet the liquidity provision obligation."
  buys: [LiquidityOrderReference!]!
  "The version of this liquidity provision"
  version: String!
  "The current status of this liquidity provision"
  status: LiquidityProvisionStatus!
  "A reference for the orders created out of this liquidity provision"
  reference: String
}

"Reward information for a single party"
type Reward {
  "The asset this reward is paid in"
  asset: Asset!
  "The market ID for which this reward is paid if any"
  marketId: ID! @deprecated(reason: "Use gameId")
  "The type of reward"
  rewardType: AccountType!
  "Party receiving the reward"
  party: Party!
  "Epoch for which this reward was distributed"
  epoch: Epoch!
  "Amount received for this reward"
  amount: String!
  "Amount paid as a reward, expressed in asset's quantum unit"
  quantumAmount: String!
  "Percentage out of the total distributed reward"
  percentageOfTotal: String!
  "RFC3339Nano time when the rewards were received"
  receivedAt: Timestamp!
  "The epoch when the reward is released"
  lockedUntilEpoch: Epoch!
  "Optional game ID for rewards that are paid for participation in a game"
  gameId: ID
  "Optional team ID for rewards that are paid if the party is a member of a team, and for participation in a game."
  teamId: ID
}

type RewardSummary {
  "The asset for which these rewards are associated"
  asset: Asset!
  "Total quantity of rewards awarded in this asset"
  amount: String!

  "List of individual reward payouts, ordered by epoch"
  rewardsConnection(
    "An optional asset ID"
    assetId: ID
    "Cursor pagination information"
    pagination: Pagination
  ): RewardsConnection
}

"RFC3339Nano value for time"
scalar Timestamp

type AggregatedLedgerEntry {
  "RFC3339Nano time from at which this ledger entries records were relevant"
  vegaTime: Timestamp!
  "Net amount of ledger entries for the accounts specified in the filter at this time"
  quantity: String!
  "Asset identifier, if query was grouped by asset - else null"
  assetId: ID
  "Type of the transfer for this ledger entry"
  transferType: TransferType
  "Party identifier, if query was grouped by sender party - else null"
  fromAccountPartyId: ID
  "Party identifier, if query was grouped by receiver party - else null"
  toAccountPartyId: ID
  "Market identifier, if query was grouped by sender market - else null"
  fromAccountMarketId: ID
  "Market identifier, if query was grouped by receiver market - else null"
  toAccountMarketId: ID
  "Account type, if query was grouped by sender account type - else null"
  fromAccountType: AccountType
  "Account type, if query was grouped by receiver account type - else null"
  toAccountType: AccountType
  "Sender account balance after the transfer"
  fromAccountBalance: String!
  "Receiver account balance after the transfer"
  toAccountBalance: String!
  "Transfer ID associated with this aggregated ledger entry"
  transferId: ID!
}

type AggregatedLedgerEntriesEdge {
  node: AggregatedLedgerEntry!
  cursor: String!
}

type AggregatedLedgerEntriesConnection {
  edges: [AggregatedLedgerEntriesEdge]!
  pageInfo: PageInfo!
}

"Type of transfer between accounts"
enum LedgerEntryField {
  TransferType
}

type AggregatedBalance {
  "RFC3339Nano time from at which this balance was relevant"
  timestamp: Timestamp!
  "Net balance of the accounts specified in the filter at this time"
  balance: String!
  "Account identifier, if query was grouped by account - else null"
  partyId: ID
  "Asset identifier, if query was grouped by asset - else null"
  assetId: ID
  "Market identifier, if query was grouped by market - else null"
  marketId: ID
  "Account type, if query was grouped by account type - else null"
  accountType: AccountType
}

type AggregatedBalanceEdge {
  "The aggregated balance"
  node: AggregatedBalance!
  cursor: String!
}

type AggregatedBalanceConnection {
  edges: [AggregatedBalanceEdge]!
  pageInfo: PageInfo!
}

"Information about whether proposals are enabled, if the markets are still bootstrapping, etc.."
type NetworkLimits {
  "Are market proposals allowed at this point in time"
  canProposeMarket: Boolean!
  "Are asset proposals allowed at this point in time"
  canProposeAsset: Boolean!
  "Are market proposals enabled on this chain"
  proposeMarketEnabled: Boolean!
  "Are asset proposals enabled on this chain"
  proposeAssetEnabled: Boolean!
  "True once the genesis file is loaded"
  genesisLoaded: Boolean!
  "The date/timestamp in unix nanoseconds at which market proposals will be enabled (0 indicates not set)"
  proposeMarketEnabledFrom: Timestamp!
  "The date/timestamp in unix nanoseconds at which asset proposals will be enabled (0 indicates not set)"
  proposeAssetEnabledFrom: Timestamp!
}

"A segment of data node history"
type HistorySegment {
  "From block height of the history segment"
  fromHeight: Int!
  "To block height of the history segment"
  toHeight: Int!
  "ID of the history segment"
  historySegmentId: String!
}

"""
Pagination constructs to support cursor based pagination in the API
"""
input Pagination {
  "The number of items to fetch in the next page traversing forward through the connection"
  first: Int
  "The cursor to start fetching items after. If empty, data will be fetched from the beginning of the connection"
  after: String
  "The number of items to fetch in the next page traversing backward through the connection"
  last: Int
  "The cursor to start fetching items before. If empty data will be fetched from the end of the connection"
  before: String
}

"Paging information returned with each page of a connection"
type PageInfo {
  "The connection has more pages to fetch when traversing forward through the connection"
  hasNextPage: Boolean!
  "The connection has more pages to fetch when traversing backward through the connection"
  hasPreviousPage: Boolean!
  "The first cursor in the current page"
  startCursor: String!
  "The last cursor in the current page"
  endCursor: String!
}

"Edge type containing the trade and cursor information returned by a TradeConnection"
type TradeEdge {
  "The trade"
  node: Trade!
  "The cursor for this trade"
  cursor: String!
}

"Filter to apply to the trade subscription request"
input TradesSubscriptionFilter {
  partyIds: [ID!]
  marketIds: [ID!]
}

"Filter to apply to the trade connection query"
input TradesFilter {
  partyIds: [ID!]
  marketIds: [ID!]
  orderIds: [ID!]
}

"Connection type for retrieving cursor-based paginated trade information"
type TradeConnection {
  "The trade in this connection"
  edges: [TradeEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the party and cursor information returned by a PartyConnection"
type PartyEdge {
  "The party"
  node: Party!
  "The cursor for this party"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated party information"
type PartyConnection {
  "The parties in this connection"
  edges: [PartyEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Holds metadata associated to a party."
type PartyProfile {
  partyId: ID!
  "Alias given to the party."
  alias: String!
  "Metadata to associate to a party, in a key/value format where the key describes the type of metadata in the value field."
  metadata: [Metadata!]!
}
"Edge type containing the party and cursor information returned by a PartiesProfilesConnection"
type PartyProfileEdge {
  "The party's profile"
  node: PartyProfile!
  "The cursor for this party's profile"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated profile information for multiple parties"
type PartiesProfilesConnection {
  "The profiles in this connection"
  edges: [PartyProfileEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the market and cursor information returned by a MarketConnection"
type MarketEdge {
  "The market"
  node: Market!
  "The cursor for this market"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated market information"
type MarketConnection {
  "The markets in this connection"
  edges: [MarketEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

type SuccessorMarket {
  "The market"
  market: Market!
  "Proposals for child markets"
  proposals: [Proposal]
}

"Edge type containing the market and cursor information returned by a MarketConnection"
type SuccessorMarketEdge {
  "The market"
  node: SuccessorMarket!
  "The cursor for this market"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated market information"
type SuccessorMarketConnection {
  "The markets in this connection"
  edges: [SuccessorMarketEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the order and cursor information returned by a OrderConnection"
type OrderEdge {
  "The order"
  node: Order!
  "The cursor for this order"
  cursor: String
}

"Edge type containing the stop order and cursor information returned by a StopOrderConnection"
type StopOrderEdge {
  "The stop order"
  node: StopOrder
  "The cursor for this stop order"
  cursor: String
}

input OrderFilter {
  status: [OrderStatus!]
  types: [OrderType!]
  timeInForce: [OrderTimeInForce!]
  "Date range to retrieve orders from/to. Start and end time should be expressed as an integer value Unix nanoseconds"
  dateRange: DateRange
  excludeLiquidity: Boolean
  """
  If true, only orders that are live will be returned. Orders are live if they have STATUS_ACTIVE or STATUS_PARKED
  as per https://github.com/vegaprotocol/specs-internal/blob/master/protocol/0024-OSTA-order_status.md
  """
  liveOnly: Boolean
}

"Filter to be applied when querying a list of stop orders. If multiple criteria are specified, e.g. parties and markets, then the filter is applied as an AND."
input StopOrderFilter {
  "Zero or more party IDs to filter by"
  parties: [ID!]
  "Zero or more market IDs to filter by"
  markets: [ID!]
  "Zero or more order status to filter by"
  status: [StopOrderStatus!]
  "Zero or more expiry strategies to filter by"
  expiryStrategy: [StopOrderExpiryStrategy!]
  "Date range to retrieve order from/to. Start and end time should be expressed as an integer value of Unix nanoseconds"
  dateRange: DateRange
  "Filter for live stop orders only"
  liveOnly: Boolean
}

input OrderByPartyIdsFilter {
  order: OrderFilter
  partyIds: [ID!]
}

input OrderByMarketIdsFilter {
  order: OrderFilter
  marketIds: [ID!]
}

input OrderByMarketAndPartyIdsFilter {
  order: OrderFilter
  marketIds: [ID!]
  partyIds: [ID!]
}

"Connection type for retrieving cursor-based paginated order information"
type OrderConnection {
  "The orders in this connection"
  edges: [OrderEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Connection type for retrieving cursory-based paginated stop order information"
type StopOrderConnection {
  "The stop orders in this connection"
  edges: [StopOrderEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the position and cursor information returned by a PositionConnection"
type PositionEdge {
  "The position"
  node: Position!
  "The cursor for this position"
  cursor: String
}

"Filter to apply to the positions connection query"
input PositionsFilter {
  partyIds: [ID!]
  marketIds: [ID!]
}

"Connection type for retrieving cursor-based paginated position information"
type PositionConnection {
  "The positions in this connection"
  edges: [PositionEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the vote and cursor information returned by a VoteConnection"
type VoteEdge {
  "The vote"
  node: Vote!
  "The cursor for this vote"
  cursor: String
}

"Connection type for retrieving cursor-based paginated vote information"
type VoteConnection {
  "The votes in this connection"
  edges: [VoteEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the proposal vote and cursor information returned by a ProposalVoteConnection"
type ProposalVoteEdge {
  "The proposal vote"
  node: ProposalVote!
  "The cursor for this proposal vote"
  cursor: String
}

"Connection type for retrieving cursor-based paginated proposal vote information"
type ProposalVoteConnection {
  "The proposal votes in this connection"
  edges: [ProposalVoteEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the margin and cursor information returned by a MarginConnection"
type MarginEdge {
  node: MarginLevels!
  cursor: String
}

"Connection type for retrieving cursor-based paginated margin information"
type MarginConnection {
  "The margin levels in this connection"
  edges: [MarginEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the reward and cursor information returned by a MarketDataConnection"
type MarketDataEdge {
  node: MarketData!
  cursor: String
}

"Connection type for retrieving cursor-based paginated market data information"
type MarketDataConnection {
  "The market data elements for the requested page"
  edges: [MarketDataEdge]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the reward and cursor information returned by a RewardsConnection"
type RewardEdge {
  "The reward information"
  node: Reward!
  "The cursor for this reward"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated rewards information"
type RewardsConnection {
  "The rewards"
  edges: [RewardEdge]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the candle and cursor information returned by a CandleDataConnection"
type CandleEdge {
  "The candle"
  node: Candle!
  "The cursor for the candle"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated candle information"
type CandleDataConnection {
  "The candles"
  edges: [CandleEdge]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the withdrawal and cursor information returned by a WithdrawalsConnection"
type WithdrawalEdge {
  "The withdrawal"
  node: Withdrawal!
  "The cursor for the withdrawal"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated withdrawals information"
type WithdrawalsConnection {
  "The withdrawals"
  edges: [WithdrawalEdge]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the deposit and cursor information returned by a DepositsConnection"
type DepositEdge {
  node: Deposit!
  cursor: String!
}

"Connection type for retrieving cursor-based paginated deposits information"
type DepositsConnection {
  "The deposits"
  edges: [DepositEdge]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the asset and cursor information returned by a AssetsConnection"
type AssetEdge {
  "The asset information"
  node: Asset!
  "The cursor for the asset"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated assets information"
type AssetsConnection {
  "The assets"
  edges: [AssetEdge]
  "The pagination information"
  pageInfo: PageInfo
}

type OracleSpecEdge {
  "The external data spec"
  node: OracleSpec!
  "The cursor for the external data"
  cursor: String!
}

type OracleSpecsConnection {
  edges: [OracleSpecEdge]
  pageInfo: PageInfo!
}

type OracleDataEdge {
  "The oracle data source"
  node: OracleData!
  "The cursor for the data item"
  cursor: String!
}

type OracleDataConnection {
  "The oracle data spec"
  edges: [OracleDataEdge]
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the liquidity provision and cursor information returned by a LiquidityProvisionsConnection"
type LiquidityProvisionsEdge {
  node: LiquidityProvision!
  cursor: String!
}

"Connection type for retrieving cursor-based paginated liquidity provision information"
type LiquidityProvisionsConnection {
  edges: [LiquidityProvisionsEdge]
  pageInfo: PageInfo!
}

"Edge type containing the liquidity provision and cursor information returned by a LiquidityProvisionsWithPendingConnection"
type LiquidityProvisionWithPendingEdge {
  node: LiquidityProvisionWithPending!
  cursor: String!
}

"Connection type for retrieving cursor-based paginated liquidity provision information"
type LiquidityProvisionsWithPendingConnection {
  edges: [LiquidityProvisionWithPendingEdge]
  pageInfo: PageInfo!
}

"Information about a liquidity provider"
type LiquidityProvider {
  "Party ID of the liquidity provider"
  partyId: ID!
  "Market ID the liquidity provision is for"
  marketId: ID!
  "Information used for calculating an LP's fee share, such as the equity-like share, average entry valuation and liquidity score, for the given liquidity provider and market"
  feeShare: LiquidityProviderFeeShare
  "SLA performance statistics"
  sla: LiquidityProviderSLA
}

"Edge type containing the liquidity provider and cursor information"
type LiquidityProviderEdge {
  "Liquidity provider's information"
  node: LiquidityProvider!
  "Cursor for the liquidity provider"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated liquidity provider information"
type LiquidityProviderConnection {
  "Page of liquidity provider edges for the connection"
  edges: [LiquidityProviderEdge!]!
  "Current page information"
  pageInfo: PageInfo
}

"A transfer fee record"
type TransferFee {
  "Transfer ID of the transfer for which the fee was paid"
  transferId: ID!
  "The fee amount"
  amount: String!
  "The epoch when this fee was paid"
  epoch: Int!
}

"A transfer record with the fee payments associated with the transfer"
type TransferNode {
  "The transfer record"
  transfer: Transfer!
  "The list of fee payments made"
  fees: [TransferFee]
}

"Edge type containing the transfer and cursor information returned by a TransferConnection"
type TransferEdge {
  node: TransferNode!
  cursor: String!
}

"Connection type for retrieving cursor-based paginated transfers information"
type TransferConnection {
  edges: [TransferEdge]
  pageInfo: PageInfo!
}

"Filter type for specifying the types of transfers to filter for"
enum TransferDirection {
  To
  From
  ToOrFrom
}

union ProposalNode = Proposal | BatchProposal

"Edge type containing the proposals and cursor information returned by a ProposalsConnection"
type ProposalEdge {
  "The proposal data"
  node: Proposal! @deprecated(reason: "Use proposalNode")
  "The data of either single or batch proposal"
  proposalNode: ProposalNode
  "Cursor identifying the proposal"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated proposals information"
type ProposalsConnection {
  "List of proposals available for the connection"
  edges: [ProposalEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the delegation and cursor information returned by a DelegationsConnection"
type DelegationEdge {
  "The delegation information"
  node: Delegation!
  "The cursor for the data item"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated delegation information"
type DelegationsConnection {
  "The delegation information available on this connection"
  edges: [DelegationEdge]
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the node and cursor information returned by a NodesConnection"
type NodeEdge {
  "The node"
  node: Node!
  "Cursor identifying the node"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated node information"
type NodesConnection {
  "List of nodes available for the connection"
  edges: [NodeEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the network parameter and cursor information returned by a NetworkParametersConnection"
type NetworkParameterEdge {
  "The network parameter"
  node: NetworkParameter!
  "Cursor identifying the network parameter"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated network parameters information"
type NetworkParametersConnection {
  "List of network parameters available for the connection"
  edges: [NetworkParameterEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the node signature and cursor information returned by a NodeSignatureConnection"
type NodeSignatureEdge {
  "The node signature"
  node: NodeSignature!
  "Cursor identifying the node signature"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated node signature information"
type NodeSignaturesConnection {
  "List of node signatures available for the connection"
  edges: [NodeSignatureEdge!]!
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the key rotation and cursor information returned by a KeyRotationConnection"
type KeyRotationEdge {
  "The key rotation"
  node: KeyRotation!
  "Cursor identifying the key rotation"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated key rotation information"
type KeyRotationConnection {
  "List of key rotations available for the connection"
  edges: [KeyRotationEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the reward summary and cursor information returned by a RewardSummaryConnection"
type RewardSummaryEdge {
  "The reward summary"
  node: RewardSummary!
  "Cursor identifying the reward summary"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated reward summary information"
type RewardSummaryConnection {
  "List of reward summaries available for the connection"
  edges: [RewardSummaryEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the stake linking and cursor information returned by a StakesConnection"
type StakeLinkingEdge {
  "The stake linking"
  node: StakeLinking!
  "Cursor identifying the stake linking"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated stake linking information"
type StakesConnection {
  "List of stake links available for the connection"
  edges: [StakeLinkingEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"Edge type containing the account and cursor information returned by an AccountsConnection"
type AccountEdge {
  "The account"
  node: AccountBalance!
  "Cursor identifying the account"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated list of account"
type AccountsConnection {
  "List of accounts available for the connection"
  edges: [AccountEdge]
  "Page information for the connection"
  pageInfo: PageInfo!
}

"""
Range of dates to retrieve information for.
If start and end are provided, data will be returned within the specified range (exclusive).
If start is provided without end, the end date will be the latest time available in the data set.
If end is provided without start, the start time will be the earliest time available in the data set.
"""
input DateRange {
  "The start timestamp for the date range (inclusive). RFC3339Nano format"
  start: Timestamp
  "The end timestamp for the date range (exclusive). RFC3339Nano format"
  end: Timestamp
}

"Indicator showing whether the data-node is ready for the protocol upgrade to begin."
type ProtocolUpgradeStatus {
  ready: Boolean!
}

"The set of valid statuses for a protocol upgrade proposal"
enum ProtocolUpgradeProposalStatus {
  "Invalid proposal state"
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_UNSPECIFIED
  "Proposal to upgrade protocol version is awaiting sufficient validator approval"
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_PENDING
  "Proposal to upgrade protocol version accepted"
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_APPROVED
  "Proposal to upgrade protocol version has been rejected"
  PROTOCOL_UPGRADE_PROPOSAL_STATUS_REJECTED
}

"Connection type for retrieving cursor-based paginated protocol upgrade proposals"
type ProtocolUpgradeProposalConnection {
  "The positions in this connection"
  edges: [ProtocolUpgradeProposalEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the protocol upgrade protocol cursor information"
type ProtocolUpgradeProposalEdge {
  "The protocol upgrade proposal"
  node: ProtocolUpgradeProposal!
  "Cursor identifying the protocol upgrade proposal"
  cursor: String!
}

"A proposal to upgrade the vega protocol (i.e. which version of the vega software nodes will run)"
type ProtocolUpgradeProposal {
  "At which block the upgrade is proposed"
  upgradeBlockHeight: String!
  "To which vega release tag the upgrade is proposed"
  vegaReleaseTag: String!
  "Tendermint validators that have agreed to the upgrade"
  approvers: [String!]!
  "the status of the proposal"
  status: ProtocolUpgradeProposalStatus!
}

type EpochRewardSummaryConnection {
  edges: [EpochRewardSummaryEdge]
  pageInfo: PageInfo
}

type EpochRewardSummaryEdge {
  node: EpochRewardSummary!
  cursor: String!
}

"an aggregated reward summary for a combination of epoch/asset/market/reward type"
type EpochRewardSummary {
  "The epoch for which summary is generated"
  epoch: Int!
  "ID of the market"
  marketId: ID
  "ID of the Asset"
  assetId: ID!
  "Type of the reward"
  rewardType: AccountType!
  "Total quantity of rewards awarded in this asset/market/reward type in this epoch"
  amount: String!
}

"Connection type for retrieving cursor-based paginated core snapshot data"
type CoreSnapshotConnection {
  "The positions in this connection"
  edges: [CoreSnapshotEdge!]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the core snapshot cursor information"
type CoreSnapshotEdge {
  "The core snapshot data"
  node: CoreSnapshotData!
  "Cursor identifying the core snapshot data"
  cursor: String!
}

"A snapshot taken by the core"
type CoreSnapshotData {
  "At which block the snapshot was taken"
  blockHeight: String!
  "The block hash at the snapshot block height"
  blockHash: String!
  "The current version of vega core"
  vegaCoreVersion: String!
}

"""
DataSourceSpecConfigurationTime is the internal data source used for emitting timestamps.
"""
type DataSourceSpecConfigurationTime {
  conditions: [Condition]!
}

"Trigger for an internal time data source"
type InternalTimeTrigger {
  "Trigger when the vega time is greater or equal to this time, in Unix seconds"
  initial: Int
  """
  Repeat the trigger every n seconds after the initial. If no time for initial was specified,
  begin repeating immediately
  """
  every: Int
}

"DataSourceSpecConfigurationTimeTrigger is the internal data source used for emitting timestamps automatically using predefined intervals and conditions"
type DataSourceSpecConfigurationTimeTrigger {
  conditions: [Condition]!
  triggers: [InternalTimeTrigger]!
}

union InternalDataSourceKind =
    DataSourceSpecConfigurationTime
  | DataSourceSpecConfigurationTimeTrigger

"""
DataSourceDefinitionInternal is the top level object used for all internal data sources.
It contains one of any of the defined `SourceType` variants.
"""
type DataSourceDefinitionInternal {
  sourceType: InternalDataSourceKind!
}

union ExternalDataSourceKind = DataSourceSpecConfiguration | EthCallSpec

"""
DataSourceDefinitionExternal is the top level object used for all external data sources.
It contains one of any of the defined `SourceType` variants.
"""
type DataSourceDefinitionExternal {
  sourceType: ExternalDataSourceKind!
}

union DataSourceKind =
    DataSourceDefinitionInternal
  | DataSourceDefinitionExternal

"""
DataSourceDefinition represents the top level object that deals with data sources.
DataSourceDefinition can be external or internal, with whatever number of data sources are defined
for each type in the child objects below.
"""
type DataSourceDefinition {
  sourceType: DataSourceKind!
}

"""
List of all entities created by transaction hash
"""
type Entities {
  "List of accounts created by the transaction hash"
  accounts: [AccountEvent]
  "List of orders created by the transaction hash"
  orders: [Order]
  "List of positions created by the transaction hash"
  positions: [Position]
  "List of ledger entries created by the transaction hash"
  ledgerEntries: [LedgerEntry]
  "List of balance changes created by the transaction hash"
  balanceChanges: [AccountBalance]
  "List of transfers created by the transaction hash"
  transfers: [Transfer]
  "List of votes created by the transaction hash"
  votes: [Vote]
  "List of ERC-20 multisig signer added bundles created by the transaction hash"
  erc20MultiSigSignerAddedBundles: [ERC20MultiSigSignerAddedBundle]
  "List of ERC-20 multisig signer removed bundles created by the transaction hash"
  erc20MultiSigSignerRemovedBundles: [ERC20MultiSigSignerRemovedBundle]
  "List of trades created by the transaction hash"
  trades: [Trade]
  "List of oracle specs created by the transaction hash"
  oracleSpecs: [OracleSpec]
  "List of oracle data created by the transaction hash"
  oracleData: [OracleData]
  "List of markets created by the transaction hash"
  markets: [Market]
  "List of parties created by the transaction hash"
  parties: [Party]
  "List of margin levels created by the transaction hash"
  marginLevels: [MarginLevels]
  "List of rewards created by the transaction hash"
  rewards: [Reward]
  "List of deposits created by the transaction hash"
  deposits: [Deposit]
  "List of withdrawals created by the transaction hash"
  withdrawals: [Withdrawal]
  "List of assets created by the transaction hash"
  assets: [Asset]
  "List of liquidity provisions created by the transaction hash"
  liquidityProvisions: [LiquidityProvision]
  "List of proposals created by the transaction hash"
  proposals: [ProposalDetail]
  "List of delegations created by the transaction hash"
  delegations: [Delegation]
  "List of nodes created by the transaction hash"
  nodes: [NodeBasic]
  "List of node signatures created by the transaction hash"
  nodeSignatures: [NodeSignature]
  "List of network parameters created by the transaction hash"
  networkParameters: [NetworkParameter]
  "List of key rotations created by the transaction hash"
  keyRotations: [KeyRotation]
  "List of ethereum key rotations created by the transaction hash"
  ethereumKeyRotations: [EthereumKeyRotation]
  "List of protocol upgrade proposals created by the transaction hash"
  protocolUpgradeProposals: [ProtocolUpgradeProposal]
}

"The funding payment from a perpetual market."
type FundingPayment {
  "Market the funding payment applies to."
  marketId: ID!
  "Party the funding payment applies to."
  partyId: ID!
  "Sequence number of the funding period the funding payment belongs to."
  fundingPeriodSeq: Int!
  "Amount transferred"
  amount: String
  "RFC3339Nano timestamp when the data point was received."
  timestamp: Timestamp!
}

"Edge type for funding payment"
type FundingPaymentEdge {
  "The funding payment"
  node: FundingPayment!
  "Cursor identifying the funding payment"
  cursor: String!
}

"Connection type for funding payment"
type FundingPaymentConnection {
  "List of funding payments"
  edges: [FundingPaymentEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"Data point for a funding period."
type FundingPeriodDataPoint {
  "Market the data point applies to."
  marketId: ID!
  "Sequence number of the funding period the data point belongs to."
  seq: Int!
  "Source of the data point."
  dataPointSource: FundingPeriodDataPointSource
  "Price of the asset as seen by this data point."
  price: String!
  "Time-weighted average price calculated from data points for this period from the data source."
  twap: String
  "RFC3339Nano timestamp when the data point was received."
  timestamp: Timestamp!
}

"Edge type for funding period data point"
type FundingPeriodDataPointEdge {
  "The funding period data point"
  node: FundingPeriodDataPoint!
  "Cursor identifying the funding period data point"
  cursor: String!
}

"Connection type for funding period data points"
type FundingPeriodDataPointConnection {
  "List of funding period data points"
  edges: [FundingPeriodDataPointEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"Details of a funding interval for a perpetual market."
type FundingPeriod {
  "Market the funding period relates to."
  marketId: ID!
  "Sequence number of the funding period."
  seq: Int!
  "RFC3339Nano time when the funding period started."
  startTime: Timestamp!
  "RFC3339Nano time when the funding period ended."
  endTime: Timestamp
  "Funding payment for this period as the difference between the time-weighted average price of the external and internal data point."
  fundingPayment: String
  "Percentage difference between the time-weighted average price of the external and internal data point."
  fundingRate: String
  "Time-weighted average price calculated from data points for this period from the external data source."
  externalTwap: String
  "Time-weighted average price calculated from data points for this period from the internal data source."
  internalTwap: String
}

"Sources of funding period data points."
enum FundingPeriodDataPointSource {
  "Funding period data point was sourced from an external data source."
  SOURCE_EXTERNAL
  "Funding period data point was generated internally by the network."
  SOURCE_INTERNAL
}

"Edge type containing a funding period cursor and its associated funding period data"
type FundingPeriodEdge {
  "The funding period data"
  node: FundingPeriod!
  "Cursor identifying the funding period data"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated funding period data for perpetual markets"
type FundingPeriodConnection {
  "The funding periods in this connection"
  edges: [FundingPeriodEdge!]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Referral program information"
type ReferralProgram {
  "Unique ID generated from the proposal that created this program."
  id: ID!
  "Incremental version of the program. It is incremented each time the referral program is edited."
  version: Int!
  "Defined tiers in increasing order. First element will give Tier 1, second element will give Tier 2, etc."
  benefitTiers: [BenefitTier!]!
  "Timestamp as Unix time in nanoseconds, after which when the current epoch ends, the program will end and benefits will be disabled."
  endOfProgramTimestamp: Timestamp!
  "Number of epochs over which to evaluate a referral set's running volume."
  windowLength: Int!
  """
  Defined staking tiers in increasing order. First element will give Tier 1,
  second element will give Tier 2, and so on. Determines the level of
  benefit a party can expect based on their staking.
  """
  stakingTiers: [StakingTier!]!
}

"Referral program information reported by data node with additional endedAt timestamp."
type CurrentReferralProgram {
  "Unique ID generated from the proposal that created this program."
  id: ID!
  "Incremental version of the program. It is incremented each time the referral program is edited."
  version: Int!
  "Defined tiers in increasing order. First element will give Tier 1, second element will give Tier 2, etc."
  benefitTiers: [BenefitTier!]!
  "Timestamp as Unix time in nanoseconds, after which when the current epoch ends, the program will end and benefits will be disabled."
  endOfProgramTimestamp: Timestamp!
  "Number of epochs over which to evaluate a referral set's running volume."
  windowLength: Int!
  """
  Defined staking tiers in increasing order. First element will give Tier 1,
  second element will give Tier 2, and so on. Determines the level of
  benefit a party can expect based on their staking.
  """
  stakingTiers: [StakingTier!]!
  "Timestamp as RFC3339Nano when the program ended. If present, the current program has ended and no program is currently running."
  endedAt: Timestamp
}

"Data relating to a referral set."
type ReferralSet {
  "Unique ID of the created set."
  id: ID!
  "Party that created the set."
  referrer: ID!
  "Current number of members in the referral set."
  totalMembers: Int!
  "Timestamp as RFC3339Nano when the referral set was created."
  createdAt: Timestamp!
  "Timestamp as RFC3339Nano when the referral set was updated."
  updatedAt: Timestamp!
}

"Edge type containing the referral set and cursor information returned by a ReferralSetConnection"
type ReferralSetEdge {
  "The referral set"
  node: ReferralSet!
  "The cursor for this referral set"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated referral set information"
type ReferralSetConnection {
  "The referral sets in this connection"
  edges: [ReferralSetEdge]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Data relating to referees that have joined a referral set"
type ReferralSetReferee {
  "Unique ID of the referral set the referee joined."
  referralSetId: ID!
  "Party that joined the set."
  refereeId: ID!
  "Timestamp as RFC3339Nano when the party joined the set."
  joinedAt: Timestamp!
  "Epoch in which the party joined the set."
  atEpoch: Int!
  "Total notional volume of the referee's aggressive trades over the aggregation period, default is 30 days."
  totalRefereeNotionalTakerVolume: String!
  "Total rewards generated from the referee over the aggregation period, default is 30 days."
  totalRefereeGeneratedRewards: String!
}

"Edge type containing the referral set referee and cursor information returned by a ReferralSetRefereeConnection"
type ReferralSetRefereeEdge {
  "The referral set referee"
  node: ReferralSetReferee!
  "The cursor for this referral set referee"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated information about the referral set referees"
type ReferralSetRefereeConnection {
  "The referral set referees in this connection"
  edges: [ReferralSetRefereeEdge]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Connection type for retrieving cursor-based paginated referral set statistics information"
type ReferralSetStatsConnection {
  "The referral set statistics in this connection"
  edges: [ReferralSetStatsEdge]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the referral set statistics and cursor information returned by a ReferralSetStatsConnection"
type ReferralSetStatsEdge {
  "The referral set statistics"
  node: ReferralSetStats!
  "The cursor for this referral set statistics"
  cursor: String!
}

type ReferralSetStats {
  "Epoch at which the statistics are updated."
  atEpoch: Int!
  "Unique ID of the party."
  partyId: ID!
  "Indicates if the referral set was eligible to be part of the referral program."
  wasEligible: Boolean!
  "Discount factor applied to the party."
  discountFactor: String!
  "Reward factor applied to the party."
  rewardFactor: String!
  "Current referee notional taker volume"
  epochNotionalTakerVolume: String!
  "Running volume for the set based on the window length of the current referral program."
  referralSetRunningNotionalTakerVolume: String!
  "The multiplier applied to the referral reward factor when calculating referral rewards due to the referrer."
  rewardsMultiplier: String!
  "The proportion of the referees taker fees to be rewarded to the referrer."
  rewardsFactorMultiplier: String!
  "The referrer's taker volume"
  referrerTakerVolume: String!
}

"Team record containing the team information."
type Team {
  "Unique ID of the team."
  teamId: ID!
  "Party ID that created the team."
  referrer: ID!
  "Name of the team."
  name: String!
  "Link to the team's homepage."
  teamUrl: String!
  "Link to an image of the team's avatar."
  avatarUrl: String!
  "Current number of members in the team."
  totalMembers: Int!
  "Time in RFC3339Nano format when the team was created."
  createdAt: Timestamp!
  "Epoch at which the team was created."
  createdAtEpoch: Int!
  "Whether or not the team is closed to new party members. When closed, only parties specified in the allow list can join the team."
  closed: Boolean!
  "List of public keys that are allowed to join the team. Only applicable to closed teams."
  allowList: [String!]!
}

"Edge type containing a team cursor and its associated team data"
type TeamEdge {
  "Team data"
  node: Team!
  "Cursor identifying the team data"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated team data"
type TeamConnection {
  "Teams in this connection"
  edges: [TeamEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"Team's statistics record containing the team information."
type TeamStatistics {
  "Team ID the statistics are related to."
  teamId: String!
  "Total of volume accumulated over the requested epoch period, expressed in quantum value."
  totalQuantumVolume: String!
  "List of trading volume totals per epoch, over the requested epoch period, expressed in quantum value"
  quantumVolumes: [QuantumVolumesPerEpoch!]!
  "Total of rewards accumulated over the requested epoch period, expressed in quantum value."
  totalQuantumRewards: String!
  "List of rewards over the requested epoch period, expressed in quantum value for each epoch"
  quantumRewards: [QuantumRewardsPerEpoch!]!
  "Total of games played."
  totalGamesPlayed: Int!
  "List of games played over the requested epoch period."
  gamesPlayed: [String!]!
}

type QuantumRewardsPerEpoch {
  "Epoch for which this information is valid."
  epoch: Int!
  "Total of rewards accumulated over the epoch period expressed in quantum value."
  totalQuantumRewards: String!
}

type QuantumVolumesPerEpoch {
  "Epoch for which this information is valid."
  epoch: Int!
  "Total volume across all markets, accumulated over the epoch period, expressed in quantum value."
  totalQuantumVolumes: String!
}

"Edge type containing a team statistics cursor and its associated team's statistics data"
type TeamStatisticsEdge {
  "Team's statistics data"
  node: TeamStatistics!
  "Cursor identifying the team data"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated team statistics data"
type TeamsStatisticsConnection {
  "Teams' statistics in this connection"
  edges: [TeamStatisticsEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"Team member's statistics record containing the member's information."
type TeamMemberStatistics {
  "Party ID the statistics are related to."
  partyId: String!
  "Total of volume accumulated over the requested epoch period, expressed in quantum value."
  totalQuantumVolume: String!
  "List of trading volume totals per epoch, for the requested epoch period, expressed in quantum value"
  quantumVolumes: [QuantumVolumesPerEpoch!]!
  "Total of rewards accumulated over the requested epoch period, expressed in quantum value."
  totalQuantumRewards: String!
  "List of rewards over the requested epoch period, expressed in quantum value for each epoch"
  quantumRewards: [QuantumRewardsPerEpoch!]!
  "Total number of games played."
  totalGamesPlayed: Int!
  "List of games played over the requested epoch period."
  gamesPlayed: [String!]!
}

"Edge type containing a team member statistics cursor and its associated statistics data"
type TeamMemberStatisticsEdge {
  "Team member's statistics data"
  node: TeamMemberStatistics!
  "Cursor identifying the team data"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated team member statistics data"
type TeamMembersStatisticsConnection {
  "Team members' statistics in this connection"
  edges: [TeamMemberStatisticsEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"A team's referee info"
type TeamReferee {
  "Team ID."
  teamId: ID!
  "Party ID of the referee"
  referee: ID!
  "Time in RFC3339Nano format when the referee joined the team."
  joinedAt: Timestamp!
  "Epoch at which the referee joined the team."
  joinedAtEpoch: Int!
}

"Edge type containing a team referee cursor and its associated team referee data"
type TeamRefereeEdge {
  "Team referee data"
  node: TeamReferee!
  "Cursor identifying the team referee data"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated team referee data"
type TeamRefereeConnection {
  "Team referees in this connection"
  edges: [TeamRefereeEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"Referee's team history, i.e. which team a referee has been a member of."
type TeamRefereeHistory {
  "ID of the team the referee joined."
  teamId: ID!
  "Time in RFC3339Nano format when the referee joined the team."
  joinedAt: Timestamp!
  "Epoch at which the referee joined the team."
  joinedAtEpoch: Int!
}

"Edge type containing a team referee history cursor and its associated team referee history data"
type TeamRefereeHistoryEdge {
  "Team referee history data"
  node: TeamRefereeHistory!
  "Cursor identifying the team referee history data"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated team referee history data"
type TeamRefereeHistoryConnection {
  "Team referee history in this connection"
  edges: [TeamRefereeHistoryEdge!]!
  "Pagination information"
  pageInfo: PageInfo!
}

"Fees that have been applied on a specific asset for a given party."
type FeesStatsForParty {
  "The settlement asset of the market."
  assetId: String!
  "The total referral rewards received by referrer of the referral set."
  totalRewardsReceived: String!
  "The total referral discounts applied to all referee taker fees"
  refereesDiscountApplied: String!
  "The total volume discounts applied to all referee taker fees"
  volumeDiscountApplied: String!
  "The total maker fees received by the maker side."
  totalMakerFeesReceived: String!
}

"Fees that have been applied on a specific market/asset up to the given epoch."
type FeesStats {
  "The market the fees were paid in"
  marketId: String!
  "The settlement asset of the market."
  assetId: String!
  "The epoch for which these stats were valid."
  epoch: Int!
  "The total referral rewards received by referrer of the referral set."
  totalRewardsReceived: [PartyAmount!]!
  "The total referral rewards generated by all referee taker fees."
  referrerRewardsGenerated: [ReferrerRewardsGenerated!]!
  "The total referral discounts applied to all referee taker fees"
  refereesDiscountApplied: [PartyAmount!]!
  "The total volume discounts applied to all referee taker fees"
  volumeDiscountApplied: [PartyAmount!]!
  "The total maker fees received by the maker side."
  totalMakerFeesReceived: [PartyAmount!]!
  "The total maker fees generated by all parties."
  makerFeesGenerated: [MakerFeesGenerated!]!
}

"An amount received by a party as a reward or a discount"
type PartyAmount {
  "Id of the party that received the payment"
  partyId: String!
  "Amount received by the party"
  amount: String!
}

"Rewards generated for referrers by each of their referees"
type ReferrerRewardsGenerated {
  "ID of the referral set's referrer"
  referrerId: String!
  "The amount of rewards generated per party"
  generatedReward: [PartyAmount!]!
}

"Maker fees generated by the trade aggressor"
type MakerFeesGenerated {
  "Party that paid the fees"
  taker: String!
  "Amount of maker fees paid by the taker to the maker"
  makerFeesPaid: [PartyAmount!]!
}

"Volume discount program information"
type VolumeDiscountProgram {
  "Unique ID generated from the proposal that created this program."
  id: ID!
  "Incremental version of the program. It is incremented each time the volume discount program is edited."
  version: Int!
  "Defined tiers in increasing order. First element will give Tier 1, second element will give Tier 2, etc."
  benefitTiers: [VolumeBenefitTier!]!
  "Timestamp as Unix time in nanoseconds, after which when the current epoch ends, the program will end and benefits will be disabled."
  endOfProgramTimestamp: Timestamp!
  "Number of epochs over which to evaluate parties' running volume."
  windowLength: Int!
  "Timestamp as RFC3339Nano when the program ended. If present, the current program has ended and no program is currently running."
  endedAt: Timestamp
}

"Connection type for retrieving cursor-based paginated volume discount statistics information"
type VolumeDiscountStatsConnection {
  "The volume discount statistics in this connection"
  edges: [VolumeDiscountStatsEdge]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the volume discount statistics and cursor information returned by a VolumeDiscountStatsConnection"
type VolumeDiscountStatsEdge {
  "The volume discount statistics"
  node: VolumeDiscountStats!
  "The cursor for this volume discount statistics"
  cursor: String!
}

type VolumeDiscountStats {
  "Epoch at which the statistics are updated."
  atEpoch: Int!
  "Unique ID of the party."
  partyId: ID!
  "Discount factor applied to the party."
  discountFactor: String!
  "Party's running volume."
  runningVolume: String!
}

"Liquidity fees that have been paid to a party in a specific market/asset up to the given epoch."
type PaidLiquidityFees {
  "The market the fees were paid in"
  marketId: String!
  "The settlement asset of the market."
  assetId: String!
  "The epoch for which these stats were valid."
  epoch: Int!
  "Total fees paid across all parties"
  totalFeesPaid: String!
  "Fees paid per party"
  feesPaidPerParty: [PartyAmount!]!
}

"Connection type for retrieving cursor-based paginated paid liquidity fees statistics"
type PaidLiquidityFeesConnection {
  "The volume discount statistics in this connection"
  edges: [PaidLiquidityFeesEdge]!
  "The pagination information"
  pageInfo: PageInfo!
}

"Edge type containing the volume discount statistics and cursor information returned by a PaidLiquidityFeesConnection"
type PaidLiquidityFeesEdge {
  "The volume discount statistics"
  node: PaidLiquidityFees!
  "The cursor for this volume discount statistics"
  cursor: String!
}

"Returns total transfer fee discount available"
type TotalTransferFeeDiscount {
  "Total per party per asset discount available."
  totalDiscount: String!
}

"EstimatedTransferFee Results of estimation of transfer fee and the fee discount"
type EstimatedTransferFee {
  "Estimated fee for the transfer."
  fee: String!
  "Discount applied to the fee."
  discount: String!
}

"Individual party participating in a game and their metrics"
type IndividualGameEntity {
  "Party ID of the participant"
  individual: ID!
  "The rank of the individual within the game. If the individual is in a team, then the rank of the individual in the team"
  rank: Int!
  "The volume traded by the individual"
  volume: String!
  "The reward metric applied to the game"
  rewardMetric: DispatchMetric!
  "The rewards earned by the individual during the epoch"
  rewardEarned: String!
  "Total rewards earned by the individual during the game"
  totalRewardsEarned: String!
  "The rewards earned by the individual during the epoch in quantum value"
  rewardEarnedQuantum: String!
  "Total rewards earned by the individual during the game in quantum value"
  totalRewardsEarnedQuantum: String!
}

"Team participation information, i.e. the team ID and the metrics for each participating team member."
type TeamParticipation {
  "Team ID"
  teamId: ID!
  "List of participating team members and their metrics."
  membersParticipating: [IndividualGameEntity!]!
}

"Team participating in a game and their metrics."
type TeamGameEntity {
  "Breakdown of the team members and their contributions to the total team metrics."
  team: TeamParticipation!
  "Rank of the team within the game."
  rank: Int!
  "Total volume traded by the team"
  volume: String!
  "Reward metric applied to the game."
  rewardMetric: DispatchMetric!
  "Total rewards earned by the team during the epoch"
  rewardEarned: String!
  "Total rewards earned by the team for the game"
  totalRewardsEarned: String!
  "Total rewards earned by the team during the epoch in quantum value"
  rewardEarnedQuantum: String!
  "Total rewards earned by the team for the game in quantum value"
  totalRewardsEarnedQuantum: String!
}

union GameEntity = TeamGameEntity | IndividualGameEntity

"Game metrics for a given epoch"
type Game {
  "ID of the game."
  id: ID!
  "Epoch during which the metrics were calculated."
  epoch: Int!
  "Number of participants that took part in the game during the epoch."
  numberOfParticipants: Int!
  "Entities that were rewarded during the epoch."
  entities: [GameEntity!]!
  "ID of asset in which the rewards were paid."
  rewardAssetId: ID!
}

"Edge type containing the game metrics and cursor information returned by a GameConnection"
type GameEdge {
  "Game information and metrics."
  node: Game!
  "Cursor identifying the game"
  cursor: String!
}

"Connection type for retrieving cursor-based paginated game information"
type GamesConnection {
  "Page of game edges for the connection"
  edges: [GameEdge]
  "Current page information"
  pageInfo: PageInfo
}

"Connection type for retrieving cursor-based paginated party margin modes information"
type PartyMarginModesConnection {
  "The party margin modes"
  edges: [PartyMarginModeEdge]
  "The pagination information"
  pageInfo: PageInfo
}

"Edge type containing the deposit and cursor information returned by a PartyMarginModeConnection"
type PartyMarginModeEdge {
  node: PartyMarginMode!
  cursor: String!
}

"Margin mode selected for the given party and market."
type PartyMarginMode {
  "Unique ID of the market."
  marketId: ID!
  "Unique ID of the party."
  partyId: ID!
  "Selected margin mode."
  marginMode: MarginMode!
  "Margin factor for the market. Isolated mode only."
  marginFactor: String
  "Minimum theoretical margin factor for the market. Isolated mode only."
  minTheoreticalMarginFactor: String
  "Maximum theoretical leverage for the market. Isolated mode only."
  maxTheoreticalLeverage: String
  "Epoch at which the update happened."
  atEpoch: Int!
}

type TimeWeightedNotionalPosition {
  "Settlement asset for this position"
  assetId: ID!
  "Party holding the position"
  partyId: ID!
  "Game the time weighted notional position was calculated for"
  gameId: ID!
  "Epoch the time weighted notional position was calculated for"
  epoch: Int!
  "Time weighted notional position"
  timeWeightedNotionalPosition: String!
  "Time of the last block in which the metric was updated"
  lastUpdated: Timestamp!
}
