// Copyright (C) 2023 Gobalsky Labs Limited
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package entities

import (
	"encoding/json"
	"fmt"
	"time"

	"code.vegaprotocol.io/vega/libs/num"
	"code.vegaprotocol.io/vega/libs/ptr"
	v2 "code.vegaprotocol.io/vega/protos/data-node/api/v2"
	eventspb "code.vegaprotocol.io/vega/protos/vega/events/v1"
)

type _AMMPoolID struct{}

type AMMPoolID = ID[_AMMPoolID]

type AMMPool struct {
	ID                             AMMPoolID
	PartyID                        PartyID
	MarketID                       MarketID
	AmmPartyID                     PartyID
	Commitment                     num.Decimal
	Status                         AMMStatus
	StatusReason                   AMMStatusReason
	ParametersBase                 num.Decimal
	ParametersLowerBound           *num.Decimal
	ParametersUpperBound           *num.Decimal
	ParametersLeverageAtLowerBound *num.Decimal
	ParametersLeverageAtUpperBound *num.Decimal
	ProposedFee                    *num.Decimal
	CreatedAt                      time.Time
	LastUpdated                    time.Time
	LowerVirtualLiquidity          num.Decimal
	LowerTheoreticalPosition       num.Decimal
	UpperVirtualLiquidity          num.Decimal
	UpperTheoreticalPosition       num.Decimal
}

type AMMFilterType interface {
	Where(fieldName *string, nextBindVar func(*[]any, any) string, args ...any) (string, []any)
}

type AMMPoolsFilter interface {
	*PartyID | *MarketID | *AMMPoolID | *AMMStatus

	// Where clause generated by the filter to be used in SQL queries.
	// Optionally override the default field name defined on the implemented filter
	// with the provided field name by providing a not nil value for the field name
	Where(fieldName *string, nextBindVar func(*[]any, any) string, args ...any) (string, []any)
}

func AMMPoolFromProto(pool *eventspb.AMM, vegaTime time.Time) (AMMPool, error) {
	var (
		parametersBase,
		commitment num.Decimal
		parametersLowerBound,
		parametersUpperBound, fee *num.Decimal
		err error
	)
	partyID := PartyID(pool.PartyId)
	marketID := MarketID(pool.MarketId)
	poolID := AMMPoolID(pool.Id)
	ammPartyID := PartyID(pool.AmmPartyId)
	status := AMMStatus(pool.Status)
	statusReason := AMMStatusReason(pool.StatusReason)

	params := pool.Parameters
	if params == nil {
		return AMMPool{}, fmt.Errorf("missing AMM parameters")
	}

	if commitment, err = num.DecimalFromString(pool.Commitment); err != nil {
		return AMMPool{}, err
	}

	if parametersBase, err = num.DecimalFromString(params.Base); err != nil {
		return AMMPool{}, err
	}

	if params.LowerBound != nil {
		v, err := num.DecimalFromString(*params.LowerBound)
		if err != nil {
			return AMMPool{}, err
		}
		parametersLowerBound = &v
	}

	if params.UpperBound != nil {
		v, err := num.DecimalFromString(*params.UpperBound)
		if err != nil {
			return AMMPool{}, err
		}
		parametersUpperBound = &v
	}

	var lowerLeverage, upperLeverage *num.Decimal
	if pool.Parameters.LeverageAtLowerBound != nil {
		v, err := num.DecimalFromString(*pool.Parameters.LeverageAtLowerBound)
		if err != nil {
			return AMMPool{}, err
		}
		lowerLeverage = &v
	}

	if pool.Parameters.LeverageAtUpperBound != nil {
		v, err := num.DecimalFromString(*pool.Parameters.LeverageAtUpperBound)
		if err != nil {
			return AMMPool{}, err
		}
		upperLeverage = &v
	}

	if len(pool.ProposedFee) > 0 {
		fd, err := num.DecimalFromString(pool.ProposedFee)
		if err != nil {
			return AMMPool{}, err
		}
		fee = &fd
	}

	var lowerL, upperL, lowerPv, upperPv num.Decimal
	if pool.LowerCurve != nil {
		lowerL, err = num.DecimalFromString(pool.LowerCurve.VirtualLiquidity)
		if err != nil {
			return AMMPool{}, err
		}

		lowerPv, err = num.DecimalFromString(pool.LowerCurve.TheoreticalPosition)
		if err != nil {
			return AMMPool{}, err
		}
	}

	if pool.UpperCurve != nil {
		upperL, err = num.DecimalFromString(pool.UpperCurve.VirtualLiquidity)
		if err != nil {
			return AMMPool{}, err
		}

		upperPv, err = num.DecimalFromString(pool.UpperCurve.TheoreticalPosition)
		if err != nil {
			return AMMPool{}, err
		}
	}

	return AMMPool{
		PartyID:                        partyID,
		MarketID:                       marketID,
		ID:                             poolID,
		AmmPartyID:                     ammPartyID,
		Commitment:                     commitment,
		Status:                         status,
		StatusReason:                   statusReason,
		ParametersBase:                 parametersBase,
		ParametersLowerBound:           parametersLowerBound,
		ParametersUpperBound:           parametersUpperBound,
		ParametersLeverageAtLowerBound: lowerLeverage,
		ParametersLeverageAtUpperBound: upperLeverage,
		ProposedFee:                    fee,
		CreatedAt:                      vegaTime,
		LastUpdated:                    vegaTime,
		LowerVirtualLiquidity:          lowerL,
		LowerTheoreticalPosition:       lowerPv,
		UpperVirtualLiquidity:          upperL,
		UpperTheoreticalPosition:       upperPv,
	}, nil
}

func (p AMMPool) ToProto() *eventspb.AMM {
	var lowerBound, upperBound, lowerLeverage, upperLeverage *string
	var fee string

	if p.ParametersLowerBound != nil {
		lowerBound = ptr.From(p.ParametersLowerBound.String())
	}

	if p.ParametersUpperBound != nil {
		upperBound = ptr.From(p.ParametersUpperBound.String())
	}

	if p.ParametersLeverageAtLowerBound != nil {
		lowerLeverage = ptr.From(p.ParametersLeverageAtLowerBound.String())
	}

	if p.ParametersLeverageAtUpperBound != nil {
		upperLeverage = ptr.From(p.ParametersLeverageAtUpperBound.String())
	}
	if p.ProposedFee != nil {
		fee = p.ProposedFee.String()
	}

	return &eventspb.AMM{
		PartyId:      p.PartyID.String(),
		MarketId:     p.MarketID.String(),
		Id:           p.ID.String(),
		AmmPartyId:   p.AmmPartyID.String(),
		Commitment:   p.Commitment.String(),
		Status:       eventspb.AMM_Status(p.Status),
		StatusReason: eventspb.AMM_StatusReason(p.StatusReason),
		ProposedFee:  fee,
		Parameters: &eventspb.AMM_ConcentratedLiquidityParameters{
			Base:                 p.ParametersBase.String(),
			LowerBound:           lowerBound,
			UpperBound:           upperBound,
			LeverageAtLowerBound: lowerLeverage,
			LeverageAtUpperBound: upperLeverage,
		},
	}
}

type AMMPoolCursor struct {
	CreatedAt  time.Time
	PartyID    PartyID
	MarketID   MarketID
	ID         AMMPoolID
	AMMPartyID PartyID
}

func (c AMMPoolCursor) String() string {
	bs, err := json.Marshal(c)
	if err != nil {
		panic(fmt.Errorf("could not marshal AMM pool cursor: %v", err))
	}
	return string(bs)
}

func (c *AMMPoolCursor) Parse(cursorString string) error {
	if cursorString == "" {
		return nil
	}
	return json.Unmarshal([]byte(cursorString), c)
}

func (p AMMPool) Cursor() *Cursor {
	pc := AMMPoolCursor{
		CreatedAt:  p.CreatedAt,
		PartyID:    p.PartyID,
		MarketID:   p.MarketID,
		ID:         p.ID,
		AMMPartyID: p.AmmPartyID,
	}
	return NewCursor(pc.String())
}

func (p AMMPool) ToProtoEdge(_ ...any) (*v2.AMMEdge, error) {
	return &v2.AMMEdge{
		Node:   p.ToProto(),
		Cursor: p.Cursor().Encode(),
	}, nil
}
