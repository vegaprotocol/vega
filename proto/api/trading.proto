syntax = "proto3";

option go_package = "code.vegaprotocol.io/vega/proto/api";

import "proto/vega.proto";
import "proto/markets.proto";
import "proto/governance.proto";
import "proto/chain_events.proto";
import "proto/assets.proto";

package api;

import "google/protobuf/empty.proto";
import "github.com/mwitkow/go-proto-validators/validator.proto";

service trading {

  // Prepare a submit order request
  rpc PrepareSubmitOrder(SubmitOrderRequest) returns (PrepareSubmitOrderResponse);

  // Prepare a cancel order request
  rpc PrepareCancelOrder(CancelOrderRequest) returns (PrepareCancelOrderResponse);

  // Prepare an amend order request
  rpc PrepareAmendOrder(AmendOrderRequest) returns (PrepareAmendOrderResponse);

  // Request a withdrawal
  rpc PrepareWithdraw(PrepareWithdrawRequest) returns (PrepareWithdrawResponse);

  // Submit a signed transaction
  rpc SubmitTransaction(SubmitTransactionRequest) returns (SubmitTransactionResponse);

  // Prepare a governance proposal
  rpc PrepareProposal(PrepareProposalRequest) returns (PrepareProposalResponse);

  // Prepare a governance vote
  rpc PrepareVote(PrepareVoteRequest) returns (PrepareVoteResponse);

  // Propagate a chain event
  rpc PropagateChainEvent(PropagateChainEventRequest) returns (PropagateChainEventResponse);
}

// Request for a new event sent by the blockchain queue to be propagated on Vega.
message PropagateChainEventRequest {

  // Chain event.
  vega.ChainEvent evt = 1;
  // Public key.
  string pubKey = 2;
  // Signature.
  bytes signature = 3;
}

// Response for a new event sent by the blockchain queue to be propagated on Vega.
message PropagateChainEventResponse {

  // Success will be true if the event was accepted by the node.
  // Important - success does not mean that the event is confirmed by consensus.
  bool success = 1;
}

// Request for submitting a transaction on Vega.
message SubmitTransactionRequest {
  // This request will take the signed `blob` result from a `prepare` call and submit it for inclusion in a block by the Vega blockchain.
  // Several commands are available on Vega:
  // - SubmitOrder, see [PrepareSubmitOrder](#api.trading).
  // - AmendOrder, see [PrepareAmendOrder](#api.trading).
  // - CancelOrder, see [PrepareCancelOrder](#api.trading).
  // - PrepareProposal, see [PrepareProposal](#api.trading).
  // - PrepareVote, see [PrepareVote](#api.trading).
  // - Withdraw, see [WithdrawRequest](#api.trading).
  // All of these can be prepared using this API. Payload data must be signed using Vega Wallet before submitting a transaction.

  // A bundle of signed payload and signature, to form a transaction that will be submitted to the Vega blockchain.
  vega.SignedBundle tx = 1;
}

// Response for submitting a transaction on Vega.
message SubmitTransactionResponse {

  // Success will be true if the transaction was accepted by the node.
  // Important - success does not mean that the transaction is confirmed by consensus.
  bool success = 1;
}

// Request for preparing a withdrawal.
message PrepareWithdrawRequest {

  // An asset withdrawal.
  vega.Withdraw withdraw = 1;
}

// Response for preparing a withdrawal.
message PrepareWithdrawResponse {

  // blob is an encoded representation of the withdrawal ready to sign using the Vega Wallet and then submit as a transaction.
  bytes blob = 1;
}

// Response for preparing an order submission.
message PrepareSubmitOrderResponse {

  // blob is an encoded representation of the order submission ready to sign using the Vega Wallet and then submit as a transaction.
  bytes blob = 1;
  // Submission identifier (order reference).
  string submitID = 2;
}

// Response for preparing an order cancellation.
message PrepareCancelOrderResponse {

  // blob is an encoded representation of the order cancellation ready to sign using the Vega Wallet and then submit as a transaction.
  bytes blob = 1;
}

// Response for preparing an order amendment.
message PrepareAmendOrderResponse {

  // blob is an encoded representation of the order amendment ready to sign using the Vega Wallet and then submit as a transaction.
  bytes blob = 1;
}

// Request to submit a new order.
message SubmitOrderRequest {

  // An order submission.
  vega.OrderSubmission submission = 1;
}

// Request to cancel an existing order.
message CancelOrderRequest {

  // An order cancellation.
  vega.OrderCancellation cancellation = 1;
}

// Request to amend an existing order.
message AmendOrderRequest {

  // An order amendment.
  vega.OrderAmendment amendment = 1;
}

service trading_data {

  // -- Accounts --

  // Get a list of Accounts by Market
  rpc MarketAccounts(MarketAccountsRequest) returns (MarketAccountsResponse);

  // Get a list of Accounts by Party
  rpc PartyAccounts(PartyAccountsRequest) returns (PartyAccountsResponse);

  // Get the list of infrastructure fees accounts filter eventually by assets
 rpc FeeInfrastructureAccounts(FeeInfrastructureAccountsRequest) returns (FeeInfrastructureAccountsResponse);

  // -- Candles --

  // Get a list of Candles by Market
  rpc Candles(CandlesRequest) returns (CandlesResponse);

  // -- Market Data --

  // Get Market Data by MarketID
  rpc MarketDataByID(MarketDataByIDRequest) returns (MarketDataByIDResponse);

  // Get a list of Market Data
  rpc MarketsData(google.protobuf.Empty) returns (MarketsDataResponse);

  // -- Markets --

  // Get a Market by ID
  rpc MarketByID(MarketByIDRequest) returns (MarketByIDResponse);

  // Get Market Depth
  rpc MarketDepth(MarketDepthRequest) returns (MarketDepthResponse);

  // Get a list of Markets
  rpc Markets(google.protobuf.Empty) returns (MarketsResponse);

  // -- Orders --

  // Get an Order by Market and OrderID
  rpc OrderByMarketAndID(OrderByMarketAndIdRequest) returns (OrderByMarketAndIdResponse);

  // Get an Order by Pending Order reference (UUID)
  rpc OrderByReference(OrderByReferenceRequest) returns (OrderByReferenceResponse);

  // Get a list of Orders by Market
  rpc OrdersByMarket(OrdersByMarketRequest) returns (OrdersByMarketResponse);

  // Get a list of Orders by Party
  rpc OrdersByParty(OrdersByPartyRequest) returns (OrdersByPartyResponse);

  // Get a specific order by orderID
  rpc OrderByID(OrderByIDRequest) returns (vega.Order);

  // Get a specific order by referenceID
  rpc OrderByReferenceID(OrderByReferenceIDRequest) returns (vega.Order);

  // Get all versions of the order by its orderID
  rpc OrderVersionsByID(OrderVersionsByIDRequest) returns (OrderVersionsResponse);

  // -- Parties --

  // Get Margin Levels by PartyID
  rpc MarginLevels(MarginLevelsRequest) returns (MarginLevelsResponse);

  // Get a list of Parties
  rpc Parties(google.protobuf.Empty) returns (PartiesResponse);

  // Get a Party by ID
  rpc PartyByID(PartyByIDRequest) returns (PartyByIDResponse);

  // -- Positions --

  // Get a list of Positions by Party
  rpc PositionsByParty(PositionsByPartyRequest) returns (PositionsByPartyResponse);

  // -- Trades --

  // Get latest Trade
  rpc LastTrade(LastTradeRequest) returns (LastTradeResponse);

  // Get a list of Trades by Market
  rpc TradesByMarket(TradesByMarketRequest) returns (TradesByMarketResponse);

  // Get a list of Trades by Order
  rpc TradesByOrder(TradesByOrderRequest) returns (TradesByOrderResponse);

  // Get a list of Trades by Party
  rpc TradesByParty(TradesByPartyRequest) returns (TradesByPartyResponse);

  // -- Governance --

  // Get governance data (proposals and votes) for all proposals
  rpc GetProposals(GetProposalsRequest) returns (GetProposalsResponse);

  // Get governance data (proposals and votes) for proposals by party authoring them
  rpc GetProposalsByParty(GetProposalsByPartyRequest) returns (GetProposalsByPartyResponse);

  // Get votes by party casting them
  rpc GetVotesByParty(GetVotesByPartyRequest) returns (GetVotesByPartyResponse);

  // Get governance data (proposals and votes) for proposals that aim creating new markets
  rpc GetNewMarketProposals(GetNewMarketProposalsRequest) returns (GetNewMarketProposalsResponse);

  // Get governance data (proposals and votes) for proposals that aim updating markets
  rpc GetUpdateMarketProposals(GetUpdateMarketProposalsRequest) returns (GetUpdateMarketProposalsResponse);

  // Get governance data (proposals and votes) for proposals that aim updating Vega network parameters
  rpc GetNetworkParametersProposals(GetNetworkParametersProposalsRequest) returns (GetNetworkParametersProposalsResponse);

  // Get governance data (proposals and votes) for proposals aiming to create new assets
  rpc GetNewAssetProposals(GetNewAssetProposalsRequest) returns (GetNewAssetProposalsResponse);

  // Get governance data (proposals and votes) for a proposal located by ID
  rpc GetProposalByID(GetProposalByIDRequest) returns (GetProposalByIDResponse);

  // Get governance data (proposals and votes) for a proposal located by reference
  rpc GetProposalByReference(GetProposalByReferenceRequest) returns (GetProposalByReferenceResponse);

  // Subscribe to a stream of all governance updates
  rpc ObserveGovernance(google.protobuf.Empty) returns (stream vega.GovernanceData);

  // Subscribe to a stream of proposal updates
  rpc ObservePartyProposals(ObservePartyProposalsRequest) returns (stream vega.GovernanceData);

  // Subscribe to a stream of votes cast by a specific party
  rpc ObservePartyVotes(ObservePartyVotesRequest) returns (stream vega.Vote);

  // Subscribe to a stream of proposal votes
  rpc ObserveProposalVotes(ObserveProposalVotesRequest) returns (stream vega.Vote);

  // -- Misc --

  // Get Statistics
  rpc Statistics(google.protobuf.Empty) returns (vega.Statistics);

  // Get Time
  rpc GetVegaTime(google.protobuf.Empty) returns (VegaTimeResponse);

  // Subscribe to a stream of Accounts
  rpc AccountsSubscribe(AccountsSubscribeRequest) returns (stream vega.Account);

  // Subscribe to a stream of Candles
  rpc CandlesSubscribe(CandlesSubscribeRequest) returns (stream vega.Candle);

  // Subscribe to a stream of Margin Levels
  rpc MarginLevelsSubscribe(MarginLevelsSubscribeRequest) returns (stream vega.MarginLevels);

  // Subscribe to a stream of Market Depth
  rpc MarketDepthSubscribe(MarketDepthSubscribeRequest) returns (stream vega.MarketDepth);

  // Subscribe to a stream of Markets Data
  rpc MarketsDataSubscribe(MarketsDataSubscribeRequest) returns (stream vega.MarketData);

  // Subscribe to a stream of Orders
  rpc OrdersSubscribe(OrdersSubscribeRequest) returns (stream OrdersStream);

  // Subscribe to a stream of Positions
  rpc PositionsSubscribe(PositionsSubscribeRequest) returns (stream vega.Position);

  // Subscribe to a stream of Trades
  rpc TradesSubscribe(TradesSubscribeRequest) returns (stream TradesStream);

  // Subscribe to a stream of Transfer Responses
  rpc TransferResponsesSubscribe(google.protobuf.Empty) returns (stream vega.TransferResponse);

  // Get an aggregate of signatures from all the nodes of the network.
  rpc GetNodeSignaturesAggregate(GetNodeSignaturesAggregateRequest) returns (GetNodeSignaturesAggregateResponse);

  // Get an asset by its identifier.
  rpc AssetByID(AssetByIDRequest) returns (AssetByIDResponse);

  // Get a list of all assets on Vega.
  rpc Assets(AssetsRequest) returns (AssetsResponse);
}

// @exclude todo: could be replaced by google.protobuf.Empty, however I do prefer the more verbose AssetRequest message

// Request for a list of all assets enabled on Vega.
message AssetsRequest {
}

// Response for a list of all assets enabled on Vega.
message AssetsResponse {

  // A list of 0 or more assets.
  repeated vega.Asset assets = 1;
}

// Request for an asset given an asset identifier.
message AssetByIDRequest {

  // @exclude todo: Missing validator for required.
  // Asset identifier. Required field.
  string ID = 1;
}

// Response for an asset given an asset identifier.
message AssetByIDResponse {

  // An asset record, if found.
  vega.Asset asset = 1;
}

// Request to specify the identifier of the resource we want to retrieve aggregated signatures for.
message GetNodeSignaturesAggregateRequest {

  // @exclude todo: Missing validator for required.
  // Resource identifier. Required field.
  string ID = 1;
}

// Response to specify the identifier of the resource we want to retrieve aggregated signatures for.
message GetNodeSignaturesAggregateResponse {

  // A list of 0 or more signatures.
  repeated vega.NodeSignature signatures = 1;
}

// Optional proposal state.
message OptionalProposalState {

  // Proposal state value.
  vega.Proposal.State value = 1;
}

// Request for a list of proposals.
message GetProposalsRequest {

  // Optional proposal state.
  OptionalProposalState selectInState = 1;
}

// Response for a list of proposals.
message GetProposalsResponse {

  // A list of 0 or more governance data.
  repeated vega.GovernanceData data = 1;
}

// Request for a list of proposals for a party.
message GetProposalsByPartyRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true}];
  // Optional proposal state.
  OptionalProposalState selectInState = 2;
}

// Response for a list of proposals for a party.
message GetProposalsByPartyResponse {

  // A list of 0 or more governance data.
  repeated vega.GovernanceData data = 1;
}

// Request for a list of votes for a party.
message GetVotesByPartyRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true}];
}

// Response for a list of votes for a party.
message GetVotesByPartyResponse {

  // A list of 0 or more votes.
  repeated vega.Vote votes = 1;
}

// Request for a list of new market proposals.
message GetNewMarketProposalsRequest {

  // Optional proposal state.
  OptionalProposalState selectInState = 1;
}

// Response for a list of new market proposals.
message GetNewMarketProposalsResponse {

  // A list of 0 or more governance data.
  repeated vega.GovernanceData data = 1;
}

// Request for a list of update market proposals.
message GetUpdateMarketProposalsRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true}];
  // Proposal state.
  OptionalProposalState selectInState = 2;
}

// Response for a list of update market proposals.
message GetUpdateMarketProposalsResponse {

  // A list of 0 or more governance data.
  repeated vega.GovernanceData data = 1;
}

// Request for a list of network parameter proposals.
message GetNetworkParametersProposalsRequest {

  // Optional proposal state.
  OptionalProposalState selectInState = 1;
}

// Response for a list of network parameter proposals.
message GetNetworkParametersProposalsResponse {

  // A list of 0 or more governance data.
  repeated vega.GovernanceData data = 1;
}

// Request for a list of new asset proposals.
message GetNewAssetProposalsRequest {

  // Optional proposal state.
  OptionalProposalState selectInState = 1;
}

// Response for a list of new asset proposals.
message GetNewAssetProposalsResponse {

  // A list of 0 or more governance data.
  repeated vega.GovernanceData data = 1;
}

// Request for a governance proposal given a proposal identifier.
message GetProposalByIDRequest {

  // Proposal identifier. Required field.
  string proposalID = 1 [(validator.field) = {string_not_empty : true}];
}

// Response for a governance proposal given a proposal identifier.
message GetProposalByIDResponse {

  // Governance data, if found.
  vega.GovernanceData data = 1;
}

// Request for a governance proposal given a proposal reference.
message GetProposalByReferenceRequest {

  // Proposal reference. Required field.
  string Reference = 1 [(validator.field) = {string_not_empty : true}];
}

// Response for a governance proposal given a proposal reference.
message GetProposalByReferenceResponse {

  // Governance data, if found.
  vega.GovernanceData data = 1;
}

// Request to subscribe to a stream of governance proposals for a party.
message ObservePartyProposalsRequest {

  // Party identifier. Required field.
  string partyID = 1  [(validator.field) = {string_not_empty : true }];
}

// Request to subscribe to a stream of governance votes for a proposal.
message ObserveProposalVotesRequest {

  // Proposal identifier. Required field.
  string proposalID = 1  [(validator.field) = {string_not_empty : true }];
}

// Request to subscribe to a stream of governance votes for a party.
message ObservePartyVotesRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true }];
}

// Request to subscribe to a stream of MarginLevels data matching the given party identifier.
// Optionally, the list can be additionally filtered by market.
message MarginLevelsSubscribeRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true }];
  // Market identifier.
  string marketID = 2;
}

// Request for margin levels for a party.
message MarginLevelsRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true }];
  // Market identifier.
  string marketID = 2;
}

// Response for margin levels for a party.
message MarginLevelsResponse {

  // A list of 0 or more margin levels.
  repeated vega.MarginLevels marginLevels = 1;
}

// Request to subscribe to a stream of MarketsData.
// Optionally, the list can be additionally filtered by market.
message MarketsDataSubscribeRequest {

  // Market identifier.
  string marketID = 1;
}

// Request for market data for a market.
message MarketDataByIDRequest {

  // Market identifier.
  string marketID = 1 [(validator.field) = {string_not_empty : true }];
}

// Response for market data for a market.
message MarketDataByIDResponse {

  // Market data, if found.
  vega.MarketData marketData = 1;
}

// Response for market data.
message MarketsDataResponse {

  // A list of 0 or more market data.
  repeated vega.MarketData marketsData = 1;
}

// Request for the latest trade that occurred on Vega for a given market.
message LastTradeRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true }];
}

// Response for the latest trade that occurred on Vega for a given market.
message LastTradeResponse {

  // A trade, if found.
  vega.Trade trade = 1;
}

// Request for a market given a market identifier.
message MarketByIDRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true }];
}

// Response for a market given a market identifier.
message MarketByIDResponse {

  // A market, if found.
  vega.Market market = 1;
}

// Request for a party given a party identifier.
message PartyByIDRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true }];
}

// Response for a party given a party identifier.
message PartyByIDResponse {

  // A party, if found.
  vega.Party party = 1;
}

// Response to a request for a list of parties.
message PartiesResponse {

  // A list of 0 or more parties.
  repeated vega.Party parties = 1;
}

// Request for a list of trades relating to the given party.
// Optionally, the list can be additionally filtered for trades by market.
message TradesByPartyRequest {

  // Party identifier. Required field.
  string partyID = 1;
  // Market identifier.
  string marketID = 2;
  // Pagination controls.
  Pagination pagination = 3;
}

// Response for a list of trades relating to a party.
message TradesByPartyResponse {

  // A list of 0 or more trades.
  repeated vega.Trade trades = 1;
}

// Request for a list of trades related to an order.
message TradesByOrderRequest {

  // Order identifier. Required field.
  string orderID = 1;
}

// Response for a list of trades related to an order.
message TradesByOrderResponse {

  // A list of 0 or more trades.
  repeated vega.Trade trades = 1;
}

// Request to subscribe to a stream of Accounts.
message AccountsSubscribeRequest {

  // @exclude todo(cdm): describe the combinations of using the fields here...

  // Market identifier.
  string marketID = 1;
  // Party identifier.
  string partyID = 2;
  // Asset identifier.
  string asset = 3;
  // Account type to subscribe to. Required field.
  vega.AccountType type = 4;
}

// Request to subscribe to a stream of Orders.
message OrdersSubscribeRequest {

  // @exclude Todo(cdm): check the logic, I think these are filters not required fields...

  // Market identifier.
  string marketID = 1;
  // Party identifier.
  string partyID = 2;
}

// Request to subscribe to a stream of Trades.
message TradesSubscribeRequest {

  // @exclude Todo(cdm): check the logic, I think these are filters not required fields...

  // Market identifier.
  string marketID = 1;
  // Party identifier.
  string partyID = 2;
}

// Request to subscribe to a stream of Candles.
message CandlesSubscribeRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true}];
  // Time interval for the candles. Required field.
  vega.Interval interval = 2;
}

// Request to subscribe to a stream of MarketDepth data.
message MarketDepthSubscribeRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true}];
}

// Request to subscribe to a stream of Positions.
message PositionsSubscribeRequest {

  // Party identifier. Required field.
  string partyID = 1;
}

// Request for a list of orders for a market.
message OrdersByMarketRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true}];
  // Optional pagination controls.
  Pagination pagination = 2;
}

// Response for a list of orders for a market.
message OrdersByMarketResponse {

  // A list of 0 or more orders.
  repeated vega.Order orders = 1;
}

// Request for a list of orders for a party.
message OrdersByPartyRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true }];
  // Pagination controls.
  Pagination pagination = 2;
}

// Response for a list of orders for a party.
message OrdersByPartyResponse {

  // A list of 0 or more orders.
  repeated vega.Order orders = 1;
}

// Request for an order on a market given an order identifier.
message OrderByMarketAndIdRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true}];
  // Order identifier. Required field.
  string orderID = 2 [(validator.field) = {string_not_empty : true}];
}

// Response for an order on a market given an order identifier.
message OrderByMarketAndIdResponse {

  // An order, if found.
  vega.Order order = 1;
}

// Request for an order given an order reference.
message OrderByReferenceRequest {

  // Unique reference. Required field.
  string reference = 1 [(validator.field) = {string_not_empty : true}];
}

// Response for an order given an order reference.
message OrderByReferenceResponse {

  // An order, if found.
  vega.Order order = 1;
}

// Response for a list of markets on Vega.
message MarketsResponse {

  // A list of 0 or more markets.
  repeated vega.Market markets = 1;
}

// Request for a list of candles for a market at an interval.
message CandlesRequest {

  // @exclude todo(cdm): additional helpful information about candles...

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty : true}];
  // Timestamp to retrieve candles since, in nanoseconds since the epoch.
  // See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`. Required field.
  int64 sinceTimestamp = 2 [(validator.field) = {int_gt: 0}];
  // Time interval for the candles. Required field.
  vega.Interval interval = 3;
}

// Response for a list of candles for a market at an interval.
message CandlesResponse {

  // A list of 0 or more candles.
  repeated vega.Candle candles = 1;
}

// Request for the market depth/order book price levels on a market.
// Optionally, a maximum depth can be set to limit the number of levels returned.
message MarketDepthRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty: true}];
  // Max depth limits the number of levels returned. Default is 0, which returns all levels.
  uint64 maxDepth = 2;
}

// Response for the market depth/order book price levels on a market.
message MarketDepthResponse {

  // Market identifier.
  string marketID = 1;
  // Zero or more price levels for the buy side of the market depth data.
  repeated vega.PriceLevel buy = 2;
  // Zero or more price levels for the sell side of the market depth data.
  repeated vega.PriceLevel sell = 3;
  // Last trade recorded on Vega at the time of retrieving the `MarketDepthResponse`.
  vega.Trade lastTrade = 4;
}

// Request for a list of trades on a market.
message TradesByMarketRequest {

  // Market identifier. Required field.
  string marketID = 1 [(validator.field) = {string_not_empty: true}];
  // Pagination controls.
  Pagination pagination = 2;
}

// Response for a list of trades on a market.
message TradesByMarketResponse {

  // A list of 0 or more trades.
  repeated vega.Trade trades = 1;
}

// Request for a list of positions for a party.
// Optionally, if a market identifier is set, the results will be filtered for that market only.
message PositionsByPartyRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty: true}];
  // Market identifier.
  string marketID = 2;
}

// Response for a list of positions for a party.
message PositionsByPartyResponse {

  // A list of 0 or more positions.
  repeated vega.Position positions = 1;
}

// Response for the current consensus coordinated time on the Vega network, referred to as "VegaTime".
message VegaTimeResponse {

  // Timestamp representation of current VegaTime.
  // Nanoseconds since the epoch, for example `1580473859111222333` corresponds to `2020-01-31T12:30:59.111222333Z`
  int64 timestamp = 1;
}

// Pagination controls.
message Pagination {

  // Skip the number of records specified. Default is 0.
  uint64 skip = 1;
  // Limit the number of returned records to the value specified. Default is 50.
  uint64 limit = 2;
  // Descending reverses the order of the records returned.
  // Default is true, if false the results will be returned in ascending order.
  bool descending = 3;
}

// A stream of orders.
message OrdersStream {

  // A list of 0 or more orders.
  repeated vega.Order orders = 1;
}

// A stream of trades.
message TradesStream {

  // A list of 0 or more trades.
  repeated vega.Trade trades = 1;
}

// Request for a list of accounts for a party.
message PartyAccountsRequest {

  // @exclude todo(cdm): Include in mop up ticket - required fields here and naming....

  // Party identifier.
  string partyID = 1;
  // Market identifier.
  string marketID = 2;
  // Account type. Required field.
  vega.AccountType type = 3;
  // Asset identifier.
  string asset = 4;
}

// Response for a list of accounts for a party.
message PartyAccountsResponse {

  // A list of 0 or more accounts.
  repeated vega.Account accounts = 1;
}

// Request for a list of accounts for a market.
message MarketAccountsRequest {

  // @exclude todo(cdm): Include in mop up ticket - required fields here and naming....

  // Market identifier.
  string marketID = 1;
  // Asset identifier.
  string asset = 2;
}

// Response for a list of accounts for a market.
message MarketAccountsResponse {

  // A list of 0 or more accounts.
  repeated vega.Account accounts = 1;
}

// Request for a list of infrastructure fee accounts.
message FeeInfrastructureAccountsRequest {

  // Asset identifier. Required field.
  // Set to an empty string to return all accounts.
  // Set to an asset ID to return a single infrastructure fee account for a given asset.
  string asset = 1;
}

// Response for a list of infrastructure fee accounts.
message FeeInfrastructureAccountsResponse {

  // A list of 0 or more infrastructure fee accounts.
  repeated vega.Account accounts = 1;
}

// Request to prepare a governance proposal.
message PrepareProposalRequest {

  // Party identifier. Required field.
  string partyID = 1 [(validator.field) = {string_not_empty : true}];
  // Unique reference.
  string reference = 2;
  // Proposal terms. Required field.
  vega.ProposalTerms proposal = 3 [(validator.field) = {msg_exists : true}];
}

// Response to prepare a governance proposal.
message PrepareProposalResponse {

  // blob is an encoded representation of the proposal ready to sign using the Vega Wallet and then submit as a transaction.
  bytes blob = 1;
  // A copy of the prepared proposal.
  vega.Proposal pendingProposal = 2;
}

// Request to prepare a governance vote.
message PrepareVoteRequest {

  // Vote. Required field.
  vega.Vote vote = 1 [(validator.field) = {msg_exists: true}];
}

// Response to prepare a governance vote.
message PrepareVoteResponse {

  // blob is an encoded representation of the vote ready to sign using the Vega Wallet and then submit as a transaction.
  bytes blob = 1;
  // A copy of the prepared vote.
  vega.Vote vote = 2;
}

// Request for an order with the specified order identifier.
// Optionally, return a specific version of the order with the `version` field.
message OrderByIDRequest {

  // Order identifier. Required field.
  string orderID = 1 [(validator.field) = {msg_exists: true}];
  // Version of the order.
  // Set `version` to 0 for most recent version of the order.
  // Set `1` for original version of the order.
  // Set `2` for first amendment, `3` for second amendment, etc.
  uint64 version = 2;
}

//@exclude todo(cdm): Remove this duplicate response and add Order Versions By ID Response

// Request for an order given the specified order reference.
message OrderByReferenceIDRequest {

  // Reference. Required field.
  string referenceID = 1 [(validator.field) = {msg_exists: true}];
}

// Request for a list of all versions of an order given the specified order identifier.
message OrderVersionsByIDRequest {

  // Order identifier. Required field.
  string orderID = 1 [(validator.field) = {msg_exists: true}];
  // Pagination controls.
  Pagination pagination = 2;
}

// Response to a request for a list of all versions of an order.
message OrderVersionsResponse {

    // A list of 0 or more orders (list will contain the same order but with different versions, if it has been amended).
    repeated vega.Order orders = 1;
}