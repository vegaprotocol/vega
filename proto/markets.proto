syntax = "proto3";

package vega;
option go_package = "code.vegaprotocol.io/vega/proto";

import "github.com/mwitkow/go-proto-validators/validator.proto";

// An auction duration is used to configure 3 auction periods:
// 1. `duration > 0`, `volume == 0`:
//   The auction will last for at least N seconds.
// 2. `duration == 0`, `volume > 0`:
//   The auction will end once we can close with given traded volume.
// 3. `duration > 0`, `volume > 0`:
//   The auction will take at least N seconds, but can end sooner if we can trade a certain volume.
message AuctionDuration {

  // Duration of the auction in seconds.
  int64 duration = 1;
  //Target uncrossing trading volume.
  uint64 volume = 2;
}

// Continuous trading.
message ContinuousTrading {

  // Tick size.
  string tickSize = 1;
}

// Discrete trading.
message DiscreteTrading {

  // Duration in nanoseconds, maximum 1 month (2592000000000000 ns)
  int64 durationNs = 1 [(validator.field) = {int_gt: 0, int_lt: 2592000000000000}];
  // Tick size.
  string tickSize = 2;
}

// Future product definition.
message Future {

  // The maturity for the future.
  string maturity = 1;
  // The asset for the future.
  string asset = 2;
  // Oracle configuration.
  oneof oracle {
    // Ethereum events.
    EthereumEvent ethereumEvent = 100;
  }
}

// Ethereum event (for oracles).
message EthereumEvent {

  // Ethereum contract identifier.
  string contractID = 1;
  // Event.
  string event = 2;
  // Value.
  uint64 value = 3;
}

// Instrument metadata definition.
message InstrumentMetadata {

  // A list of 0 or more tags.
  repeated string tags = 1;
}

// Instrument definition.
message Instrument {

  // Instrument identifier.
  string id = 1;
  // Code for the instrument.
  string code = 2;
  // Name of the instrument.
  string name = 3;
  // Base name of the instrument.
  string baseName = 4;
  // Quote name of the instrument.
  string quoteName = 5;
  // A collection of instrument meta-data.
  InstrumentMetadata metadata = 6;
  // An initial mark price for the instrument.
  uint64 initialMarkPrice = 7;
  // The product the instrument is composed of.
  oneof product {
    // Future.
    Future future = 100;
  }
}

// Risk model for log normal.
message LogNormalRiskModel {

  // Risk Aversion Parameter.
  double riskAversionParameter = 1;
  // Tau.
  double tau = 2;
  // Risk model parameters for log normal.
  LogNormalModelParams params = 3;
}

// Risk model parameters for log normal.
message LogNormalModelParams {

  // Mu param.
  double mu = 1;
  // R param.
  double r = 2;
  // Sigma param.
  double sigma = 3;
}

// Risk model for simple modelling.
message SimpleRiskModel {

  // Risk model params for simple modelling.
  SimpleModelParams params = 1;
}

// Risk model parameters for simple modelling.
message SimpleModelParams {

  // Pre-defined risk factor value for long.
  double factorLong = 1;
  // Pre-defined risk factor value for short.
  double factorShort = 2;
  // Pre-defined maximum price move up that the model considers as valid.
  double maxMoveUp = 3 [(validator.field) = {float_gte: 0}];
  // Pre-defined minimum price move down that the model considers as valid.
  double minMoveDown = 4 [(validator.field) = {float_lte: 0}];
}

// Risk model for external modelling.
// Provided by external service via a Unix socket.
message ExternalRiskModel {

  // Name.
  string name = 1;
  // Local machine socket to connect to.
  string socket = 2;
  // Collection of configuration items.
  map<string, string> config = 3;
}

// Scaling Factors (for use in margin calculation).
message ScalingFactors {

  // Search level.
  double searchLevel = 1;
  // Initial margin level.
  double initialMargin = 2;
  // Collateral release level.
  double collateralRelease = 3;
}

// Margin Calculator definition.
message MarginCalculator {
  // Scaling factors for margin calculation.
  ScalingFactors scalingFactors = 1;
}

// Tradable Instrument definition.
message TradableInstrument {

  // Instrument details.
  Instrument instrument = 1;
  // Margin calculator for the instrument.
  MarginCalculator marginCalculator = 2;
  // Risk model for use by the instrument.
  oneof riskModel {
    // Log normal.
    LogNormalRiskModel logNormalRiskModel = 100;
    // External socket.
    ExternalRiskModel externalRiskModel = 101;
    // Simple.
    SimpleRiskModel simpleRiskModel = 102;
  }
}

// Fee factors definition.
message FeeFactors {
  // Maker fee.
  string makerFee = 1;
  // Infrastructure fee.
  string infrastructureFee = 2;
  // Liquidity fee.
  string liquidityFee = 3;
}

// Fees definition.
message Fees {
  // Fee factors.
  FeeFactors factors = 1;
}

// PriceMonitoringParameters holds together price projection horizon τ, probability level p, and auction extension duration
message PriceMonitoringParameters {
  // Price monitoring projection horizon τ
  int64 horizon = 1 [(validator.field) = {int_gt: 0}];
  // Price monitoirng probability level p
  double probability = 2 [(validator.field) = {int_gt: 0, int_lt: 0}];
  // Price monitoring auction extension duration in seconds should the price
  // breach it's theoretical level over the specified horizon at the specified
  // probability level
  int64 auctionExtension = 3 [(validator.field) = {int_gte: 0}];
}

message PriceMonitoringSettings {
  // Specifies a set of PriceMonitoringParameters to be used for price
  // monitoring purposes
  repeated PriceMonitoringParameters priceMonitoringParameters = 1;

  // Specifies how often (expressed in seconds) the price monitoring bounds should be updated.
  int64 updateFrequency = 2 [(validator.field) = {int_gt: 0}];
}

// Market definition.
message Market {

  // Unique identifier.
  string id = 1;
  // Tradable instrument configuration.
  TradableInstrument tradableInstrument = 2;
  // Number of decimal places that a price must be shifted by in order to get a
  // correct price denominated in the currency of the market. For example:
  // `realPrice = price / 10^decimalPlaces`
  uint64 decimalPlaces = 3;
  // Fees configuration.
  Fees fees = 4;
  // Auction duration specifies how long the opening auction will run (minimum
  // duration and optionally a minimum traded volume).
  AuctionDuration openingAuction = 5;
  // Trading mode for the market.
  oneof tradingMode {
    // Continuous.
    ContinuousTrading continuous = 100;
    // Discrete.
    DiscreteTrading discrete = 101;
  }
  // PriceMonitoringSettings for the market.
  PriceMonitoringSettings priceMonitoringSettings = 6;
}
