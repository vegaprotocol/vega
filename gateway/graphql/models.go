// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/proto"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

// union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind
type Event interface {
	IsEvent()
}

type Product interface {
	IsProduct()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type TradingMode interface {
	IsTradingMode()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// Represents an asset in vega
type Asset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// The origin source of the asset (e.g: an erc20 asset)
	Source AssetSource `json:"source"`
	// The infrastructure fee account for this asset
	InfrastructureFeeAccount *proto.Account `json:"infrastructureFeeAccount"`
}

func (Asset) IsEvent() {}

// An auction duration is used to configure 3 auction periods:
// 1. `duration > 0`, `volume == 0`:
// The auction will last for at least N seconds.
// 2. `duration == 0`, `volume > 0`:
// The auction will end once we can close with given traded volume.
// 3. `duration > 0`, `volume > 0`:
// The auction will take at least N seconds, but can end sooner if we can trade a certain volume.
type AuctionDuration struct {
	// Duration of the auction in seconds
	DurationSecs int `json:"durationSecs"`
	// Target uncrossing trading volume
	Volume int `json:"volume"`
}

type AuctionEvent struct {
	// the market ID
	MarketID string `json:"marketID"`
	// event fired because of auction end
	Leave bool `json:"leave"`
	// event related to opening auction
	OpeningAuction bool `json:"openingAuction"`
	// start time of auction
	AuctionStart string `json:"auctionStart"`
	// optional end time of auction
	AuctionEnd string `json:"auctionEnd"`
	// What triggered the auction
	Trigger AuctionTrigger `json:"trigger"`
}

func (AuctionEvent) IsEvent() {}

// A vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

// A vega builtin asset, mostly for testing purpose
type BuiltinAssetInput struct {
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

type BusEvent struct {
	// the id for this event
	EventID string `json:"eventID"`
	// the block hash
	Block string `json:"block"`
	// the type of event we're dealing with
	Type BusEventType `json:"type"`
	// the payload - the wrapped event
	Event Event `json:"event"`
}

// Condition describes the condition that must be validated by the
type ConditionInput struct {
	// comparator is the type of comparison to make on the value.
	Operator ConditionOperator `json:"operator"`
	// value is used by the comparator.
	Value string `json:"value"`
}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (ContinuousTrading) IsTradingMode() {}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTradingInput struct {
	// Size of an increment in price in terms of the quote currency. Note this field should not be used and will be ignored
	TickSize *string `json:"tickSize"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (DiscreteTrading) IsTradingMode() {}

// Frequent batch auctions trading mode
type DiscreteTradingInput struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency. Note this field should not be used and will be ignored
	TickSize *string `json:"tickSize"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

func (Erc20) IsAssetSource() {}

// An asset originated from an Ethereum ERC20 Token
type ERC20Input struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawan
	Amount string `json:"amount"`
	// The expiry of the approval (RFC3339Nano)
	Expiry string `json:"expiry"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// ERC20 specific details to start a withdrawal
type Erc20WithdrawalDetailsInput struct {
	// The ethereum address to which the withdrawn funds will be send to
	ReceiverAddress string `json:"receiverAddress"`
}

// The factors applied to calculate the fees
type FeeFactors struct {
	// The factor applied to calculate MakerFees, a non-negative float
	MakerFee string `json:"makerFee"`
	// The factor applied to calculate InfrastructureFees, a non-negative float
	InfrastructureFee string `json:"infrastructureFee"`
	// The factor applied to calculate LiquidityFees, a non-negative float
	LiquidityFee string `json:"liquidityFee"`
}

// The fees applicable to a market
type Fees struct {
	// The factors used to calculate the different fees
	Factors *FeeFactors `json:"factors"`
}

// Filter describes the conditions under which an oracle data is considered of
// interest or not.
type FilterInput struct {
	// key is the oracle data property key targeted by the filter.
	Key *PropertyKeyInput `json:"key"`
	// conditions are the conditions that should be matched by the data to be
	// considered of interest.
	Conditions []*ConditionInput `json:"conditions"`
}

// Future product configuration
type FutureProductInput struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	SettlementAsset string `json:"settlementAsset"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// The oracle spec describing the oracle data of interest.
	OracleSpec *OracleSpecInput `json:"oracleSpec"`
	// The binding between the oracle spec and the settlement price
	OracleSpecBinding *OracleSpecToFutureBindingInput `json:"oracleSpecBinding"`
}

type InstrumentConfigurationInput struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// Future product specification
	FutureProduct *FutureProductInput `json:"futureProduct"`
}

// A set of metadata to associate to an instruments
type InstrumentMetadata struct {
	// An arbitrary list of tags to associated to associate to the Instrument (string list)
	Tags []string `json:"tags"`
}

type LedgerEntry struct {
	// account from which the asset was taken
	FromAccount string `json:"fromAccount"`
	// account to which the balance was transferred
	ToAccount string `json:"toAccount"`
	// the amount transferred
	Amount int `json:"amount"`
	// The transfer reference
	Reference string `json:"reference"`
	// Type of ledger entry
	Type string `json:"type"`
	// The time at which the transfer was made
	Timestamp string `json:"timestamp"`
}

// A special order type for liquidity providers
type LiquidityOrderInput struct {
	// The value to which this order is tied
	Reference PeggedReference `json:"reference"`
	// The proportion of the commitment allocted to this order
	Proportion int `json:"proportion"`
	// Offset from the pegged reference
	Offset int `json:"offset"`
}

// The equity like share of liquidity fee for each liquidity provider
type LiquidityProviderFeeShare struct {
	// The liquidity provider party id
	Party *proto.Party `json:"party"`
	// The share own by this liquidity provider (float)
	EquityLikeShare string `json:"equityLikeShare"`
	// the average entry valuation of the liqidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
}

// Parameters for the log normal risk model
type LogNormalModelParams struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

type LogNormalModelParamsInput struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

// A type of risk model for futures trading
type LogNormalRiskModel struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParams `json:"params"`
}

func (LogNormalRiskModel) IsRiskModel() {}

type LogNormalRiskModelInput struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParamsInput `json:"params"`
}

type LossSocialization struct {
	// the market ID where loss socialization happened
	MarketID string `json:"marketID"`
	// the party that was part of the loss socialization
	PartyID string `json:"partyID"`
	// the amount lost
	Amount int `json:"amount"`
}

func (LossSocialization) IsEvent() {}

type MarginCalculator struct {
	// The scaling factors that will be used for margin calculation
	ScalingFactors *ScalingFactors `json:"scalingFactors"`
}

// The MM commitments for this market
type MarketDataCommitments struct {
	// a set of liquidity sell orders to meet the liquidity provision obligation, see MM orders spec.
	Sells []*proto.LiquidityOrderReference `json:"sells"`
	// a set of liquidity buy orders to meet the liquidity provision obligation, see MM orders spec.
	Buys []*proto.LiquidityOrderReference `json:"buys"`
}

type MarketEvent struct {
	// the market ID
	MarketID string `json:"marketID"`
	// the message - market events are used for logging
	Payload string `json:"payload"`
}

func (MarketEvent) IsEvent() {}

type MarketTick struct {
	// the market ID
	MarketID string `json:"marketID"`
	// the block time
	Time string `json:"time"`
}

func (MarketTick) IsEvent() {}

// Representation of a network parameter
type NetworkParameterInput struct {
	// The name of the network parameter
	Key string `json:"key"`
	// The value of the network parameter
	Value string `json:"value"`
}

// A new asset to be added into vega
type NewAssetInput struct {
	// A new builtin assed to be created
	BuiltinAsset *BuiltinAssetInput `json:"builtinAsset"`
	// A new ERC20 asset to be created
	Erc20 *ERC20Input `json:"erc20"`
}

// Allows creating new markets on the network
type NewMarketInput struct {
	// New market instrument configuration
	Instrument *InstrumentConfigurationInput `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters *RiskParametersInput `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// Price monitoring configuration
	PriceMonitoringParameters *PriceMonitoringParametersInput `json:"priceMonitoringParameters"`
	// A mode where Vega try to execute order as soon as they are received. Valid only if discreteTrading is not set
	ContinuousTrading *ContinuousTradingInput `json:"continuousTrading"`
	// Frequent batch auctions trading mode. Valid only if continuousTrading is not set
	DiscreteTrading *DiscreteTradingInput `json:"discreteTrading"`
}

// An oracle spec describe the oracle data that a product (or a risk model)
// wants to get from the oracle engine.
type OracleSpecInput struct {
	// pubKeys is the list of authorized public keys that signed the data for this
	// oracle. All the public keys in the oracle data should be contained in these
	// public keys.
	PubKeys []string `json:"pubKeys"`
	// filters describes which oracle data are considered of interest or not for
	// the product (or the risk model).
	Filters []*FilterInput `json:"filters"`
}

// OracleSpecToFutureBindingInput tells on which property oracle data should be
// used as settlement price.
type OracleSpecToFutureBindingInput struct {
	SettlementPriceProperty string `json:"settlementPriceProperty"`
}

// An estimate of the fee to be paid by the order
type OrderEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
	// The margin requirement for this order
	MarginLevels *proto.MarginLevels `json:"marginLevels"`
}

// Create an order linked to an index rather than a price
type PeggedOrderInput struct {
	// Index to link this order to
	Reference PeggedReference `json:"reference"`
	// Price offset from the peg
	Offset string `json:"offset"`
}

type PositionResolution struct {
	// the market ID where position resolution happened
	MarketID string `json:"marketID"`
	// number of distressed traders on market
	Distressed int `json:"distressed"`
	// number of traders closed out
	Closed int `json:"closed"`
	// the mark price at which traders were distressed/closed out
	MarkPrice int `json:"markPrice"`
}

func (PositionResolution) IsEvent() {}

type PreparedAmendOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedCancelOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

// A prepared LiquidityProvision command
type PreparedLiquidityProvision struct {
	// The blob to be send to the wallet and to be signed
	Blob string `json:"blob"`
}

type PreparedProposal struct {
	// Raw transaction data to sign & submit
	Blob string `json:"blob"`
	// The pending proposal
	PendingProposal *proto.GovernanceData `json:"pendingProposal"`
}

type PreparedSubmitOrder struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedVote struct {
	// Raw, serialised vote to be signed
	Blob string `json:"blob"`
	// The vote serialised in the blob field
	Vote *ProposalVote `json:"vote"`
}

type PreparedWithdrawal struct {
	// the raw transaction to sign & submit
	Blob string `json:"blob"`
}

// Range of valid prices and the associated price monitoring trigger
type PriceMonitoringBounds struct {
	// Minimum price that isn't currently breaching the specified price monitoring trigger
	MinValidPrice string `json:"minValidPrice"`
	// Maximum price that isn't currently breaching the specified price monitoring trigger
	MaxValidPrice string `json:"maxValidPrice"`
	// Price monitoring trigger associated with the bounds
	Trigger *PriceMonitoringTrigger `json:"trigger"`
	// Reference price used to calculate the valid price range
	ReferencePrice string `json:"referencePrice"`
}

// PriceMonitoringParameters holds a list of triggers
type PriceMonitoringParameters struct {
	// The list of triggers for this price monitoring
	Triggers []*PriceMonitoringTrigger `json:"triggers"`
}

// PriceMonitoringParameters holds a list of triggers
type PriceMonitoringParametersInput struct {
	// The list of triggers for this price monitoring
	Triggers []*PriceMonitoringTriggerInput `json:"triggers"`
}

// Configuration of a market price monitorings auctions triggers
type PriceMonitoringSettings struct {
	// Specified a set of PriceMonitoringParameters to be use for price monitoring purposes
	Parameters *PriceMonitoringParameters `json:"parameters"`
	// How often (in seconds) the price monitoring bounds should be updated
	UpdateFrequencySecs int `json:"updateFrequencySecs"`
}

// Configuration of a market price monitorings auctions triggers
type PriceMonitoringSettingsInput struct {
	// Specified a set of PriceMonitoringParameters to be use for price monitoring purposes
	Parameters *PriceMonitoringParametersInput `json:"parameters"`
	// How often (in seconds) the price monitoring bounds should be updated
	UpdateFrequencySecs *int `json:"updateFrequencySecs"`
}

// PriceMonitoringParameters holds together price projection horizon τ, probability level p, and auction extension duration
type PriceMonitoringTrigger struct {
	// Price monitoring projection horizon τ in seconds (> 0).
	HorizonSecs int `json:"horizonSecs"`
	// Price monitoring probability level p. (>0 and < 1)
	Probability float64 `json:"probability"`
	// Price monitoring auction extension duration in seconds should the price
	// breach it's theoretical level over the specified horizon at the specified
	// probability level (> 0)
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

// PriceMonitoringParameters holds together price projection horizon τ, probability level p, and auction extension duration
type PriceMonitoringTriggerInput struct {
	// Price monitoring projection horizon τ in seconds (> 0).
	HorizonSecs int `json:"horizonSecs"`
	// Price monitoring probability level p. (>0 and < 1)
	Probability float64 `json:"probability"`
	// Price monitoring auction extension duration in seconds should the price
	// breach it's theoretical level over the specified horizon at the specified
	// probability level (> 0)
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

// PropertyKey describes the property key contained in an oracle data.
type PropertyKeyInput struct {
	// name is the name of the property.
	Name string `json:"name"`
	// type is the type of the property.
	Type PropertyKeyType `json:"type"`
}

// Proposal terms input. Only one kind of change is expected. Proposals with no changes or more than one will not be accepted.
type ProposalTermsInput struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Field defining new market change - the proposal will create new market if passed and enacted.
	// It can only be set if "updateMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	NewMarket *NewMarketInput `json:"newMarket"`
	// Field defining update market change - the proposal will update existing market if passed and enacted.
	// It can only be set if "newMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateMarket *UpdateMarketInput `json:"updateMarket"`
	// Field defining update network change - the proposal will update Vega network parameters if passed and enacted.
	// It can only be set if "newMarket" and "updateMarket" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateNetworkParameter *UpdateNetworkParameterInput `json:"updateNetworkParameter"`
	// a new Asset proposal, this will create a new asset to be used in the vega network
	NewAsset *NewAssetInput `json:"newAsset"`
}

type ProposalVote struct {
	// Cast vote
	Vote *Vote `json:"vote"`
	// Proposal casting the vote on
	ProposalID string `json:"proposalId"`
}

type RiskParametersInput struct {
	// Simple risk model parameters. Set only if risk model is Simple
	Simple *SimpleRiskModelParamsInput `json:"simple"`
	// Log normal risk model parameters. Set only if risk model is LogNormal
	LogNormal *LogNormalRiskModelInput `json:"logNormal"`
}

type ScalingFactors struct {
	// the scaling factor that determines the margin level at which we have to search for more money
	SearchLevel float64 `json:"searchLevel"`
	// the scaling factor that determines the optimal margin level
	InitialMargin float64 `json:"initialMargin"`
	// The scaling factor that determines the overflow margin level
	CollateralRelease float64 `json:"collateralRelease"`
}

type SettleDistressed struct {
	// the market in which a position was closed out
	MarketID string `json:"marketID"`
	// the party who closed out
	PartyID string `json:"partyID"`
	// the margin taken from distressed trader
	Margin int `json:"margin"`
	// the price at which position was closed out
	Price int `json:"price"`
}

func (SettleDistressed) IsEvent() {}

type SettlePosition struct {
	// the market in which a position was settled
	MarketID string `json:"marketID"`
	// the party who settled a position
	PartyID string `json:"partyID"`
	// the settle price
	Price int `json:"price"`
	// the trades that were settled to close the overall position
	TradeSettlements []*TradeSettlement `json:"tradeSettlements"`
}

func (SettlePosition) IsEvent() {}

// A signature to be bundled with a transaction
type SignatureInput struct {
	// The signature, base64 encoded
	Sig string `json:"sig"`
	// The algorithm used to produice the signature
	Algo string `json:"algo"`
	// The version of the signature
	Version int `json:"version"`
}

// A type of simple/dummy risk model where we can specify the risk factor long and short in params
type SimpleRiskModel struct {
	// Params for the simple risk model
	Params *SimpleRiskModelParams `json:"params"`
}

func (SimpleRiskModel) IsRiskModel() {}

// Parameters for the simple risk model
type SimpleRiskModelParams struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

type SimpleRiskModelParamsInput struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

// TargetStakeParameters contains parameters used in target stake calculation
type TargetStakeParameters struct {
	// Specifies length of time window expressed in seconds for target stake calculation
	TimeWindow int `json:"timeWindow"`
	// Specifies scaling factors used in target stake calculation
	ScalingFactor float64 `json:"scalingFactor"`
}

type TimeUpdate struct {
	// timestamp - new block time
	Timestamp string `json:"timestamp"`
}

func (TimeUpdate) IsEvent() {}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the node runner to maintain the vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the market makers to provide liquidity in the market
	LiquidityFee string `json:"liquidityFee"`
}

type TradeSettlement struct {
	// the size of the trade
	Size int `json:"size"`
	// the price of the trade
	Price int `json:"price"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

type TransferBalance struct {
	// Account involved in transfer
	Account *proto.Account `json:"account"`
	// The new balance of the account
	Balance int `json:"balance"`
}

type TransferResponse struct {
	// the ledger entries and balances resulting from a transfer request
	Transfers []*LedgerEntry `json:"transfers"`
	// the balances of accounts involved in the transfer
	Balances []*TransferBalance `json:"balances"`
}

type TransferResponses struct {
	// a group of transfer responses - events from core
	Responses []*TransferResponse `json:"responses"`
}

func (TransferResponses) IsEvent() {}

type UpdateMarketInput struct {
	MarketID string `json:"marketId"`
}

// Allows submitting a proposal for changing network parameters
type UpdateNetworkParameterInput struct {
	NetworkParameter *NetworkParameterInput `json:"networkParameter"`
}

type Vote struct {
	// The vote value cast
	Value VoteValue `json:"value"`
	// The party casting the vote
	Party *proto.Party `json:"party"`
	// ISO-8601 time and date when the vote reached Vega network
	Datetime string `json:"datetime"`
	// The ID of the proposal this vote applies to
	ProposalID string `json:"proposalId"`
}

func (Vote) IsEvent() {}

// The various account types we have (used by collateral)
type AccountType string

const (
	// Insurance pool account - only for 'system' party
	AccountTypeInsurance AccountType = "Insurance"
	// Settlement - only for 'system' party
	AccountTypeSettlement AccountType = "Settlement"
	// Margin - The leverage account for traders
	AccountTypeMargin AccountType = "Margin"
	// General account - the account containing 'unused' collateral for traders
	AccountTypeGeneral AccountType = "General"
	// Infrastructure fee account - the account where all infrastructure fees are collected
	AccountTypeFeeInfrastructure AccountType = "FeeInfrastructure"
	// Liquidity fee account - the account where all infrastructure fees are collected
	AccountTypeFeeLiquidity AccountType = "FeeLiquidity"
	// LockWithdraw - and account use for party in the process of withdrawing funds
	AccountTypeLockWithdraw AccountType = "LockWithdraw"
	// Bond - an account use to maintain MM commitments
	AccountTypeBond AccountType = "Bond"
)

var AllAccountType = []AccountType{
	AccountTypeInsurance,
	AccountTypeSettlement,
	AccountTypeMargin,
	AccountTypeGeneral,
	AccountTypeFeeInfrastructure,
	AccountTypeFeeLiquidity,
	AccountTypeLockWithdraw,
	AccountTypeBond,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeInsurance, AccountTypeSettlement, AccountTypeMargin, AccountTypeGeneral, AccountTypeFeeInfrastructure, AccountTypeFeeLiquidity, AccountTypeLockWithdraw, AccountTypeBond:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuctionTrigger string

const (
	// Invalid trigger (or no auction)
	AuctionTriggerUnspecified AuctionTrigger = "Unspecified"
	// Auction because market is trading FBA
	AuctionTriggerBatch AuctionTrigger = "Batch"
	// Opening auction
	AuctionTriggerOpening AuctionTrigger = "Opening"
	// Price monitoring
	AuctionTriggerPrice AuctionTrigger = "Price"
	// Liquidity monitoring
	AuctionTriggerLiquidity AuctionTrigger = "Liquidity"
)

var AllAuctionTrigger = []AuctionTrigger{
	AuctionTriggerUnspecified,
	AuctionTriggerBatch,
	AuctionTriggerOpening,
	AuctionTriggerPrice,
	AuctionTriggerLiquidity,
}

func (e AuctionTrigger) IsValid() bool {
	switch e {
	case AuctionTriggerUnspecified, AuctionTriggerBatch, AuctionTriggerOpening, AuctionTriggerPrice, AuctionTriggerLiquidity:
		return true
	}
	return false
}

func (e AuctionTrigger) String() string {
	return string(e)
}

func (e *AuctionTrigger) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuctionTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuctionTrigger", str)
	}
	return nil
}

func (e AuctionTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BusEventType string

const (
	// Vega Time has changed
	BusEventTypeTimeUpdate BusEventType = "TimeUpdate"
	// A balance has been transferred between accounts
	BusEventTypeTransferResponses BusEventType = "TransferResponses"
	// A position resolution event has occurred
	BusEventTypePositionResolution BusEventType = "PositionResolution"
	// An order has been created or updated
	BusEventTypeOrder BusEventType = "Order"
	// An account has been updated
	BusEventTypeAccount BusEventType = "Account"
	// A party has been updated
	BusEventTypeParty BusEventType = "Party"
	// A trade has been created
	BusEventTypeTrade BusEventType = "Trade"
	// Margin levels have changed for a position
	BusEventTypeMarginLevels BusEventType = "MarginLevels"
	// A governance proposal has been created or updated
	BusEventTypeProposal BusEventType = "Proposal"
	// A vote has been placed on a governance proposal
	BusEventTypeVote BusEventType = "Vote"
	// Market data has been updated
	BusEventTypeMarketData BusEventType = "MarketData"
	// Validator nodes signatures for an event
	BusEventTypeNodeSignature BusEventType = "NodeSignature"
	// A position has been closed without sufficient insurance pool balance to cover it
	BusEventTypeLossSocialization BusEventType = "LossSocialization"
	// A position has been settled
	BusEventTypeSettlePosition BusEventType = "SettlePosition"
	// A distressed position has been settled
	BusEventTypeSettleDistressed BusEventType = "SettleDistressed"
	// A new market has been created
	BusEventTypeMarketCreated BusEventType = "MarketCreated"
	// A market has been updated
	BusEventTypeMarketUpdated BusEventType = "MarketUpdated"
	// An asset has been created or update
	BusEventTypeAsset BusEventType = "Asset"
	// A market has progressed by one tick
	BusEventTypeMarketTick BusEventType = "MarketTick"
	// A market has either entered or exited auction
	BusEventTypeAuction BusEventType = "Auction"
	// A risk factor adjustment was made
	BusEventTypeRiskFactor BusEventType = "RiskFactor"
	// A liquidity commitment change occurred
	BusEventTypeLiquidityProvision BusEventType = "LiquidityProvision"
	// Collateral has deposited in to this Vega network via the bridge
	BusEventTypeDeposit BusEventType = "Deposit"
	// Collateral has been withdrawn from this Vega network via the bridge
	BusEventTypeWithdrawal BusEventType = "Withdrawal"
	// constant for market events - mainly used for logging
	BusEventTypeMarket BusEventType = "Market"
)

var AllBusEventType = []BusEventType{
	BusEventTypeTimeUpdate,
	BusEventTypeTransferResponses,
	BusEventTypePositionResolution,
	BusEventTypeOrder,
	BusEventTypeAccount,
	BusEventTypeParty,
	BusEventTypeTrade,
	BusEventTypeMarginLevels,
	BusEventTypeProposal,
	BusEventTypeVote,
	BusEventTypeMarketData,
	BusEventTypeNodeSignature,
	BusEventTypeLossSocialization,
	BusEventTypeSettlePosition,
	BusEventTypeSettleDistressed,
	BusEventTypeMarketCreated,
	BusEventTypeMarketUpdated,
	BusEventTypeAsset,
	BusEventTypeMarketTick,
	BusEventTypeAuction,
	BusEventTypeRiskFactor,
	BusEventTypeLiquidityProvision,
	BusEventTypeDeposit,
	BusEventTypeWithdrawal,
	BusEventTypeMarket,
}

func (e BusEventType) IsValid() bool {
	switch e {
	case BusEventTypeTimeUpdate, BusEventTypeTransferResponses, BusEventTypePositionResolution, BusEventTypeOrder, BusEventTypeAccount, BusEventTypeParty, BusEventTypeTrade, BusEventTypeMarginLevels, BusEventTypeProposal, BusEventTypeVote, BusEventTypeMarketData, BusEventTypeNodeSignature, BusEventTypeLossSocialization, BusEventTypeSettlePosition, BusEventTypeSettleDistressed, BusEventTypeMarketCreated, BusEventTypeMarketUpdated, BusEventTypeAsset, BusEventTypeMarketTick, BusEventTypeAuction, BusEventTypeRiskFactor, BusEventTypeLiquidityProvision, BusEventTypeDeposit, BusEventTypeWithdrawal, BusEventTypeMarket:
		return true
	}
	return false
}

func (e BusEventType) String() string {
	return string(e)
}

func (e *BusEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusEventType", str)
	}
	return nil
}

func (e BusEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Comparator describes the type of comparison.
type ConditionOperator string

const (
	// Verify if the property values are strictly equal or not.
	ConditionOperatorOperatorEquals ConditionOperator = "OperatorEquals"
	// Verify if the oracle data value is greater than the Condition value.
	ConditionOperatorOperatorGreaterThan ConditionOperator = "OperatorGreaterThan"
	// Verify if the oracle data value is greater than or equal to the Condition
	// value.
	ConditionOperatorOperatorGreaterThanOrEqual ConditionOperator = "OperatorGreaterThanOrEqual"
	//  Verify if the oracle data value is less than the Condition value.
	ConditionOperatorOperatorLessThan ConditionOperator = "OperatorLessThan"
	// Verify if the oracle data value is less or equal to than the Condition
	// value.
	ConditionOperatorOperatorLessThanOrEqual ConditionOperator = "OperatorLessThanOrEqual"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorOperatorEquals,
	ConditionOperatorOperatorGreaterThan,
	ConditionOperatorOperatorGreaterThanOrEqual,
	ConditionOperatorOperatorLessThan,
	ConditionOperatorOperatorLessThanOrEqual,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorOperatorEquals, ConditionOperatorOperatorGreaterThan, ConditionOperatorOperatorGreaterThanOrEqual, ConditionOperatorOperatorLessThan, ConditionOperatorOperatorLessThanOrEqual:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a deposit
type DepositStatus string

const (
	// The deposit is open and being processed by the network
	DepositStatusOpen DepositStatus = "Open"
	// The deposit have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	DepositStatusCancelled DepositStatus = "Cancelled"
	// The deposit was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts
	DepositStatusFinalized DepositStatus = "Finalized"
)

var AllDepositStatus = []DepositStatus{
	DepositStatusOpen,
	DepositStatusCancelled,
	DepositStatusFinalized,
}

func (e DepositStatus) IsValid() bool {
	switch e {
	case DepositStatusOpen, DepositStatusCancelled, DepositStatusFinalized:
		return true
	}
	return false
}

func (e DepositStatus) String() string {
	return string(e)
}

func (e *DepositStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DepositStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DepositStatus", str)
	}
	return nil
}

func (e DepositStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval for trade candles when subscribing via VEGA graphql, default is I15M
type Interval string

const (
	// 1 minute interval
	IntervalI1m Interval = "I1M"
	// 5 minute interval
	IntervalI5m Interval = "I5M"
	// 15 minute interval (default)
	IntervalI15m Interval = "I15M"
	// 1 hour interval
	IntervalI1h Interval = "I1H"
	// 6 hour interval
	IntervalI6h Interval = "I6H"
	// 1 day interval
	IntervalI1d Interval = "I1D"
)

var AllInterval = []Interval{
	IntervalI1m,
	IntervalI5m,
	IntervalI15m,
	IntervalI1h,
	IntervalI6h,
	IntervalI1d,
}

func (e Interval) IsValid() bool {
	switch e {
	case IntervalI1m, IntervalI5m, IntervalI15m, IntervalI1h, IntervalI6h, IntervalI1d:
		return true
	}
	return false
}

func (e Interval) String() string {
	return string(e)
}

func (e *Interval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Interval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Interval", str)
	}
	return nil
}

func (e Interval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a liquidity provision order
type LiquidityProvisionStatus string

const (
	// An active liquidity provision
	LiquidityProvisionStatusActive LiquidityProvisionStatus = "Active"
	// A liquidity provision stopped by the network
	LiquidityProvisionStatusStopped LiquidityProvisionStatus = "Stopped"
	// A Cancelled Liquidity provision
	LiquidityProvisionStatusCancelled LiquidityProvisionStatus = "Cancelled"
	// A liquidity provision was invalid and got rejected
	LiquidityProvisionStatusRejected LiquidityProvisionStatus = "Rejected"
	// The liquidity provision is valid and accepted by network, but oreders aren't deployed
	LiquidityProvisionStatusUndeployed LiquidityProvisionStatus = "Undeployed"
)

var AllLiquidityProvisionStatus = []LiquidityProvisionStatus{
	LiquidityProvisionStatusActive,
	LiquidityProvisionStatusStopped,
	LiquidityProvisionStatusCancelled,
	LiquidityProvisionStatusRejected,
	LiquidityProvisionStatusUndeployed,
}

func (e LiquidityProvisionStatus) IsValid() bool {
	switch e {
	case LiquidityProvisionStatusActive, LiquidityProvisionStatusStopped, LiquidityProvisionStatusCancelled, LiquidityProvisionStatusRejected, LiquidityProvisionStatusUndeployed:
		return true
	}
	return false
}

func (e LiquidityProvisionStatus) String() string {
	return string(e)
}

func (e *LiquidityProvisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LiquidityProvisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LiquidityProvisionStatus", str)
	}
	return nil
}

func (e LiquidityProvisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The current state of a market
type MarketState string

const (
	// The Governance proposal valid and accepted
	MarketStateProposed MarketState = "PROPOSED"
	// Outcome of governance votes is to reject the market
	MarketStateRejected MarketState = "REJECTED"
	// Governance vote passes/wins
	MarketStatePending MarketState = "PENDING"
	// Market triggers cancellation condition or governance
	// votes to close before market becomes Active
	MarketStateCancelled MarketState = "CANCELLED"
	// Enactment date reached and usual auction exit checks pass
	MarketStateActive MarketState = "ACTIVE"
	// Price monitoring or liquidity monitoring trigger
	MarketStateSuspended MarketState = "SUSPENDED"
	// Governance vote (to close)
	MarketStateClosed MarketState = "CLOSED"
	// Defined by the product (i.e. from a product parameter,
	// specified in market definition, giving close date/time)
	MarketStateTradingTerminated MarketState = "TRADING_TERMINATED"
	// Settlement triggered and completed as defined by product
	MarketStateSettled MarketState = "SETTLED"
)

var AllMarketState = []MarketState{
	MarketStateProposed,
	MarketStateRejected,
	MarketStatePending,
	MarketStateCancelled,
	MarketStateActive,
	MarketStateSuspended,
	MarketStateClosed,
	MarketStateTradingTerminated,
	MarketStateSettled,
}

func (e MarketState) IsValid() bool {
	switch e {
	case MarketStateProposed, MarketStateRejected, MarketStatePending, MarketStateCancelled, MarketStateActive, MarketStateSuspended, MarketStateClosed, MarketStateTradingTerminated, MarketStateSettled:
		return true
	}
	return false
}

func (e MarketState) String() string {
	return string(e)
}

func (e *MarketState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketState", str)
	}
	return nil
}

func (e MarketState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// What market trading mode are we in
type MarketTradingMode string

const (
	// Continuous trading where orders are processed and potentially matched on arrival
	MarketTradingModeContinuous MarketTradingMode = "CONTINUOUS"
	// Auction trading where orders are uncrossed at the end of the opening auction period
	MarketTradingModeOpeningAuction MarketTradingMode = "OPENING_AUCTION"
	// Auction as normal trading mode for the market, where orders are uncrossed periodically
	MarketTradingModeBatchAuction MarketTradingMode = "BATCH_AUCTION"
	// Auction triggered by price/liquidity monitoring
	MarketTradingModeMonitoringAuction MarketTradingMode = "MONITORING_AUCTION"
)

var AllMarketTradingMode = []MarketTradingMode{
	MarketTradingModeContinuous,
	MarketTradingModeOpeningAuction,
	MarketTradingModeBatchAuction,
	MarketTradingModeMonitoringAuction,
}

func (e MarketTradingMode) IsValid() bool {
	switch e {
	case MarketTradingModeContinuous, MarketTradingModeOpeningAuction, MarketTradingModeBatchAuction, MarketTradingModeMonitoringAuction:
		return true
	}
	return false
}

func (e MarketTradingMode) String() string {
	return string(e)
}

func (e *MarketTradingMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketTradingMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketTradingMode", str)
	}
	return nil
}

func (e MarketTradingMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type signature provided by a node
type NodeSignatureKind string

const (
	// A signature for proposing a new asset into the network
	NodeSignatureKindAssetNew NodeSignatureKind = "AssetNew"
	// A signature for allowing a withdrawal of funds
	NodeSignatureKindAssetWithdrawal NodeSignatureKind = "AssetWithdrawal"
)

var AllNodeSignatureKind = []NodeSignatureKind{
	NodeSignatureKindAssetNew,
	NodeSignatureKindAssetWithdrawal,
}

func (e NodeSignatureKind) IsValid() bool {
	switch e {
	case NodeSignatureKindAssetNew, NodeSignatureKindAssetWithdrawal:
		return true
	}
	return false
}

func (e NodeSignatureKind) String() string {
	return string(e)
}

func (e *NodeSignatureKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeSignatureKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeSignatureKind", str)
	}
	return nil
}

func (e NodeSignatureKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the order being rejected by the core node
type OrderRejectionReason string

const (
	// Market id is invalid
	OrderRejectionReasonInvalidMarketID OrderRejectionReason = "InvalidMarketId"
	// Order id is invalid
	OrderRejectionReasonInvalidOrderID OrderRejectionReason = "InvalidOrderId"
	// Order is out of sequence
	OrderRejectionReasonOrderOutOfSequence OrderRejectionReason = "OrderOutOfSequence"
	// Remaining size in the order is invalid
	OrderRejectionReasonInvalidRemainingSize OrderRejectionReason = "InvalidRemainingSize"
	// Time has failed us
	OrderRejectionReasonTimeFailure OrderRejectionReason = "TimeFailure"
	// Unable to remove the order
	OrderRejectionReasonOrderRemovalFailure OrderRejectionReason = "OrderRemovalFailure"
	// Expiration time is invalid
	OrderRejectionReasonInvalidExpirationTime OrderRejectionReason = "InvalidExpirationTime"
	// Order reference is invalid
	OrderRejectionReasonInvalidOrderReference OrderRejectionReason = "InvalidOrderReference"
	// Edit is not allowed
	OrderRejectionReasonEditNotAllowed OrderRejectionReason = "EditNotAllowed"
	// Order amend fail
	OrderRejectionReasonOrderAmendFailure OrderRejectionReason = "OrderAmendFailure"
	// Order does not exist
	OrderRejectionReasonOrderNotFound OrderRejectionReason = "OrderNotFound"
	// Party id is invalid
	OrderRejectionReasonInvalidPartyID OrderRejectionReason = "InvalidPartyId"
	// Market is closed
	OrderRejectionReasonMarketClosed OrderRejectionReason = "MarketClosed"
	// Margin check failed
	OrderRejectionReasonMarginCheckFailed OrderRejectionReason = "MarginCheckFailed"
	// Order missing general account
	OrderRejectionReasonMissingGeneralAccount OrderRejectionReason = "MissingGeneralAccount"
	// An internal error happend
	OrderRejectionReasonInternalError OrderRejectionReason = "InternalError"
	// Invalid size
	OrderRejectionReasonInvalidSize OrderRejectionReason = "InvalidSize"
	// Invalid persistence
	OrderRejectionReasonInvalidPersistence OrderRejectionReason = "InvalidPersistence"
	// Invalid type
	OrderRejectionReasonInvalidType OrderRejectionReason = "InvalidType"
	// Self trading
	OrderRejectionReasonSelfTrading OrderRejectionReason = "SelfTrading"
	// Insufficient funds to pay fees
	OrderRejectionReasonInsufficientFundsToPayFees OrderRejectionReason = "InsufficientFundsToPayFees"
	// Invalid Time In Force
	OrderRejectionReasonInvalidTimeInForce OrderRejectionReason = "InvalidTimeInForce"
	// Attempt to amend order to GTT without ExpiryAt
	OrderRejectionReasonAmendToGTTWithoutExpiryAt OrderRejectionReason = "AmendToGTTWithoutExpiryAt"
	// Attempt to amend ExpiryAt to a value before CreatedAt
	OrderRejectionReasonExpiryAtBeforeCreatedAt OrderRejectionReason = "ExpiryAtBeforeCreatedAt"
	// Attempt to amend to GTC without an ExpiryAt value
	OrderRejectionReasonGTCWithExpiryAtNotValid OrderRejectionReason = "GTCWithExpiryAtNotValid"
	// Amending to FOK or IOC is invalid
	OrderRejectionReasonCannotAmendToFOKOrIoc OrderRejectionReason = "CannotAmendToFOKOrIOC"
	// Amending to GFA or GFN is invalid
	OrderRejectionReasonCannotAmendToGFAOrGfn OrderRejectionReason = "CannotAmendToGFAOrGFN"
	// Amending from GFA or GFN is invalid
	OrderRejectionReasonCannotAmendFromGFAOrGfn OrderRejectionReason = "CannotAmendFromGFAOrGFN"
	// Invalid Market Type
	OrderRejectionReasonInvalidMarketType OrderRejectionReason = "InvalidMarketType"
	// Good for normal order received during an auction
	OrderRejectionReasonGFNOrderDuringAuction OrderRejectionReason = "GFNOrderDuringAuction"
	// Good for auction order received during continuous trading
	OrderRejectionReasonGFAOrderDuringContinuousTrading OrderRejectionReason = "GFAOrderDuringContinuousTrading"
	// IOC orders are not allowed during auction
	OrderRejectionReasonIOCOrderDuringAuction OrderRejectionReason = "IOCOrderDuringAuction"
	// FOK orders are not allowed during auction
	OrderRejectionReasonFOKOrderDuringAuction OrderRejectionReason = "FOKOrderDuringAuction"
	// Pegged orders must be LIMIT orders
	OrderRejectionReasonPeggedOrderMustBeLimitOrder OrderRejectionReason = "PeggedOrderMustBeLimitOrder"
	// Pegged orders can only have TIF GTC or GTT
	OrderRejectionReasonPeggedOrderMustBeGTTOrGtc OrderRejectionReason = "PeggedOrderMustBeGTTOrGTC"
	// Pegged order must have a reference price
	OrderRejectionReasonPeggedOrderWithoutReferencePrice OrderRejectionReason = "PeggedOrderWithoutReferencePrice"
	// Buy pegged order cannot reference best ask price
	OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice OrderRejectionReason = "PeggedOrderBuyCannotReferenceBestAskPrice"
	// Pegged order offset must be <= 0
	OrderRejectionReasonPeggedOrderOffsetMustBeLessOrEqualToZero OrderRejectionReason = "PeggedOrderOffsetMustBeLessOrEqualToZero"
	// Pegged order offset must be < 0
	OrderRejectionReasonPeggedOrderOffsetMustBeLessThanZero OrderRejectionReason = "PeggedOrderOffsetMustBeLessThanZero"
	// Pegged order offset must be >= 0
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero OrderRejectionReason = "PeggedOrderOffsetMustBeGreaterOrEqualToZero"
	// Sell pegged order cannot reference best bid price
	OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice OrderRejectionReason = "PeggedOrderSellCannotReferenceBestBidPrice"
	// Pegged order offset must be > zero
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero OrderRejectionReason = "PeggedOrderOffsetMustBeGreaterThanZero"
	// Insufficient balance to submit the order (no deposit made)
	OrderRejectionReasonInsufficientAssetBalance OrderRejectionReason = "InsufficientAssetBalance"
	// Cannot change pegged order fields on a non pegged order
	OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder OrderRejectionReason = "CannotAmendPeggedOrderDetailsOnNonPeggedOrder"
	// Unable to reprice a pegged order
	OrderRejectionReasonUnableToRepricePeggedOrder OrderRejectionReason = "UnableToRepricePeggedOrder"
	// Unable to amend pegged order price
	OrderRejectionReasonUnableToAmendPeggedOrderPrice OrderRejectionReason = "UnableToAmendPeggedOrderPrice"
)

var AllOrderRejectionReason = []OrderRejectionReason{
	OrderRejectionReasonInvalidMarketID,
	OrderRejectionReasonInvalidOrderID,
	OrderRejectionReasonOrderOutOfSequence,
	OrderRejectionReasonInvalidRemainingSize,
	OrderRejectionReasonTimeFailure,
	OrderRejectionReasonOrderRemovalFailure,
	OrderRejectionReasonInvalidExpirationTime,
	OrderRejectionReasonInvalidOrderReference,
	OrderRejectionReasonEditNotAllowed,
	OrderRejectionReasonOrderAmendFailure,
	OrderRejectionReasonOrderNotFound,
	OrderRejectionReasonInvalidPartyID,
	OrderRejectionReasonMarketClosed,
	OrderRejectionReasonMarginCheckFailed,
	OrderRejectionReasonMissingGeneralAccount,
	OrderRejectionReasonInternalError,
	OrderRejectionReasonInvalidSize,
	OrderRejectionReasonInvalidPersistence,
	OrderRejectionReasonInvalidType,
	OrderRejectionReasonSelfTrading,
	OrderRejectionReasonInsufficientFundsToPayFees,
	OrderRejectionReasonInvalidTimeInForce,
	OrderRejectionReasonAmendToGTTWithoutExpiryAt,
	OrderRejectionReasonExpiryAtBeforeCreatedAt,
	OrderRejectionReasonGTCWithExpiryAtNotValid,
	OrderRejectionReasonCannotAmendToFOKOrIoc,
	OrderRejectionReasonCannotAmendToGFAOrGfn,
	OrderRejectionReasonCannotAmendFromGFAOrGfn,
	OrderRejectionReasonInvalidMarketType,
	OrderRejectionReasonGFNOrderDuringAuction,
	OrderRejectionReasonGFAOrderDuringContinuousTrading,
	OrderRejectionReasonIOCOrderDuringAuction,
	OrderRejectionReasonFOKOrderDuringAuction,
	OrderRejectionReasonPeggedOrderMustBeLimitOrder,
	OrderRejectionReasonPeggedOrderMustBeGTTOrGtc,
	OrderRejectionReasonPeggedOrderWithoutReferencePrice,
	OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice,
	OrderRejectionReasonPeggedOrderOffsetMustBeLessOrEqualToZero,
	OrderRejectionReasonPeggedOrderOffsetMustBeLessThanZero,
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero,
	OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice,
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero,
	OrderRejectionReasonInsufficientAssetBalance,
	OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder,
	OrderRejectionReasonUnableToRepricePeggedOrder,
	OrderRejectionReasonUnableToAmendPeggedOrderPrice,
}

func (e OrderRejectionReason) IsValid() bool {
	switch e {
	case OrderRejectionReasonInvalidMarketID, OrderRejectionReasonInvalidOrderID, OrderRejectionReasonOrderOutOfSequence, OrderRejectionReasonInvalidRemainingSize, OrderRejectionReasonTimeFailure, OrderRejectionReasonOrderRemovalFailure, OrderRejectionReasonInvalidExpirationTime, OrderRejectionReasonInvalidOrderReference, OrderRejectionReasonEditNotAllowed, OrderRejectionReasonOrderAmendFailure, OrderRejectionReasonOrderNotFound, OrderRejectionReasonInvalidPartyID, OrderRejectionReasonMarketClosed, OrderRejectionReasonMarginCheckFailed, OrderRejectionReasonMissingGeneralAccount, OrderRejectionReasonInternalError, OrderRejectionReasonInvalidSize, OrderRejectionReasonInvalidPersistence, OrderRejectionReasonInvalidType, OrderRejectionReasonSelfTrading, OrderRejectionReasonInsufficientFundsToPayFees, OrderRejectionReasonInvalidTimeInForce, OrderRejectionReasonAmendToGTTWithoutExpiryAt, OrderRejectionReasonExpiryAtBeforeCreatedAt, OrderRejectionReasonGTCWithExpiryAtNotValid, OrderRejectionReasonCannotAmendToFOKOrIoc, OrderRejectionReasonCannotAmendToGFAOrGfn, OrderRejectionReasonCannotAmendFromGFAOrGfn, OrderRejectionReasonInvalidMarketType, OrderRejectionReasonGFNOrderDuringAuction, OrderRejectionReasonGFAOrderDuringContinuousTrading, OrderRejectionReasonIOCOrderDuringAuction, OrderRejectionReasonFOKOrderDuringAuction, OrderRejectionReasonPeggedOrderMustBeLimitOrder, OrderRejectionReasonPeggedOrderMustBeGTTOrGtc, OrderRejectionReasonPeggedOrderWithoutReferencePrice, OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice, OrderRejectionReasonPeggedOrderOffsetMustBeLessOrEqualToZero, OrderRejectionReasonPeggedOrderOffsetMustBeLessThanZero, OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero, OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice, OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero, OrderRejectionReasonInsufficientAssetBalance, OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder, OrderRejectionReasonUnableToRepricePeggedOrder, OrderRejectionReasonUnableToAmendPeggedOrderPrice:
		return true
	}
	return false
}

func (e OrderRejectionReason) String() string {
	return string(e)
}

func (e *OrderRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderRejectionReason", str)
	}
	return nil
}

func (e OrderRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
type OrderStatus string

const (
	// The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
	// Active does not necessarily mean it's still on the order book.
	OrderStatusActive OrderStatus = "Active"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
	OrderStatusExpired OrderStatus = "Expired"
	// The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
	OrderStatusCancelled OrderStatus = "Cancelled"
	// This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity.
	OrderStatusStopped OrderStatus = "Stopped"
	// This order is fully filled with remaining equals zero.
	OrderStatusFilled OrderStatus = "Filled"
	// This order was rejected while being processed in the core.
	OrderStatusRejected OrderStatus = "Rejected"
	// This order was partially filled.
	OrderStatusPartiallyFilled OrderStatus = "PartiallyFilled"
	// This order has been removed from the order book and applies to pegged orders only
	OrderStatusParked OrderStatus = "Parked"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusActive,
	OrderStatusExpired,
	OrderStatusCancelled,
	OrderStatusStopped,
	OrderStatusFilled,
	OrderStatusRejected,
	OrderStatusPartiallyFilled,
	OrderStatusParked,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusActive, OrderStatusExpired, OrderStatusCancelled, OrderStatusStopped, OrderStatusFilled, OrderStatusRejected, OrderStatusPartiallyFilled, OrderStatusParked:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order types, these determine what happens when an order is added to the book
type OrderTimeInForce string

const (
	// The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
	OrderTimeInForceFok OrderTimeInForce = "FOK"
	// The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
	OrderTimeInForceIoc OrderTimeInForce = "IOC"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
	OrderTimeInForceGtc OrderTimeInForce = "GTC"
	// This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
	// NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
	OrderTimeInForceGtt OrderTimeInForce = "GTT"
	// This order is only accepted during an auction period
	OrderTimeInForceGfa OrderTimeInForce = "GFA"
	// This order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
	OrderTimeInForceGfn OrderTimeInForce = "GFN"
)

var AllOrderTimeInForce = []OrderTimeInForce{
	OrderTimeInForceFok,
	OrderTimeInForceIoc,
	OrderTimeInForceGtc,
	OrderTimeInForceGtt,
	OrderTimeInForceGfa,
	OrderTimeInForceGfn,
}

func (e OrderTimeInForce) IsValid() bool {
	switch e {
	case OrderTimeInForceFok, OrderTimeInForceIoc, OrderTimeInForceGtc, OrderTimeInForceGtt, OrderTimeInForceGfa, OrderTimeInForceGfn:
		return true
	}
	return false
}

func (e OrderTimeInForce) String() string {
	return string(e)
}

func (e *OrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTimeInForce", str)
	}
	return nil
}

func (e OrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderType string

const (
	// the default order type
	OrderTypeMarket OrderType = "MARKET"
	// mentioned in ticket, but as yet unused order type
	OrderTypeLimit OrderType = "LIMIT"
	// Used for distressed traders, an order placed by the network to close out distressed traders
	// similar to MARKET order, only no party is attached to the order.
	OrderTypeNetwork OrderType = "NETWORK"
)

var AllOrderType = []OrderType{
	OrderTypeMarket,
	OrderTypeLimit,
	OrderTypeNetwork,
}

func (e OrderType) IsValid() bool {
	switch e {
	case OrderTypeMarket, OrderTypeLimit, OrderTypeNetwork:
		return true
	}
	return false
}

func (e OrderType) String() string {
	return string(e)
}

func (e *OrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderType", str)
	}
	return nil
}

func (e OrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid references used for pegged orders.
type PeggedReference string

const (
	// Peg the order against the mid price of the order book
	PeggedReferenceMid PeggedReference = "Mid"
	// Peg the order against the best bid price of the order book
	PeggedReferenceBestBid PeggedReference = "BestBid"
	// Peg the order against the best ask price of the order book
	PeggedReferenceBestAsk PeggedReference = "BestAsk"
)

var AllPeggedReference = []PeggedReference{
	PeggedReferenceMid,
	PeggedReferenceBestBid,
	PeggedReferenceBestAsk,
}

func (e PeggedReference) IsValid() bool {
	switch e {
	case PeggedReferenceMid, PeggedReferenceBestBid, PeggedReferenceBestAsk:
		return true
	}
	return false
}

func (e PeggedReference) String() string {
	return string(e)
}

func (e *PeggedReference) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeggedReference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeggedReference", str)
	}
	return nil
}

func (e PeggedReference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type describes the type of properties that are supported by the oracle
// engine.
type PropertyKeyType string

const (
	// Any type.
	PropertyKeyTypeTypeEmpty PropertyKeyType = "TypeEmpty"
	// Integer type.
	PropertyKeyTypeTypeInteger PropertyKeyType = "TypeInteger"
	// String type.
	PropertyKeyTypeTypeString PropertyKeyType = "TypeString"
	// Boolean type.
	PropertyKeyTypeTypeBoolean PropertyKeyType = "TypeBoolean"
	// Any floating point decimal type.
	PropertyKeyTypeTypeDecimal PropertyKeyType = "TypeDecimal"
	// Timestamp date type.
	PropertyKeyTypeTypeTimestamp PropertyKeyType = "TypeTimestamp"
)

var AllPropertyKeyType = []PropertyKeyType{
	PropertyKeyTypeTypeEmpty,
	PropertyKeyTypeTypeInteger,
	PropertyKeyTypeTypeString,
	PropertyKeyTypeTypeBoolean,
	PropertyKeyTypeTypeDecimal,
	PropertyKeyTypeTypeTimestamp,
}

func (e PropertyKeyType) IsValid() bool {
	switch e {
	case PropertyKeyTypeTypeEmpty, PropertyKeyTypeTypeInteger, PropertyKeyTypeTypeString, PropertyKeyTypeTypeBoolean, PropertyKeyTypeTypeDecimal, PropertyKeyTypeTypeTimestamp:
		return true
	}
	return false
}

func (e PropertyKeyType) String() string {
	return string(e)
}

func (e *PropertyKeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertyKeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertyKeyType", str)
	}
	return nil
}

func (e PropertyKeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the proposal being rejected by the core node
type ProposalRejectionReason string

const (
	// The specified close time is too early based on network parameters
	ProposalRejectionReasonCloseTimeTooSoon ProposalRejectionReason = "CloseTimeTooSoon"
	// The specified close time is too late based on network parameters
	ProposalRejectionReasonCloseTimeTooLate ProposalRejectionReason = "CloseTimeTooLate"
	// The specified enactment time is too early based on network parameters
	ProposalRejectionReasonEnactTimeTooSoon ProposalRejectionReason = "EnactTimeTooSoon"
	// The specified enactment time is too late based on network parameters
	ProposalRejectionReasonEnactTimeTooLate ProposalRejectionReason = "EnactTimeTooLate"
	// The proposer for this proposal has insufficient token
	ProposalRejectionReasonInsufficientTokens ProposalRejectionReason = "InsufficientTokens"
	// The instrument quote name and base name were the same
	ProposalRejectionReasonInvalidInstrumentSecurity ProposalRejectionReason = "InvalidInstrumentSecurity"
	// The proposal has no product specified
	ProposalRejectionReasonNoProduct ProposalRejectionReason = "NoProduct"
	// The specified product is not supported
	ProposalRejectionReasonUnsupportedProduct ProposalRejectionReason = "UnsupportedProduct"
	// Invalid future maturity timestamp (expect RFC3339)
	ProposalRejectionReasonInvalidFutureMaturityTimestamp ProposalRejectionReason = "InvalidFutureMaturityTimestamp"
	// The product maturity is already in the past
	ProposalRejectionReasonProductMaturityIsPassed ProposalRejectionReason = "ProductMaturityIsPassed"
	// The proposal has no trading mode
	ProposalRejectionReasonNoTradingMode ProposalRejectionReason = "NoTradingMode"
	// The proposal has an unsupported trading mode
	ProposalRejectionReasonUnsupportedTradingMode ProposalRejectionReason = "UnsupportedTradingMode"
	// The proposal failed node validation
	ProposalRejectionReasonNodeValidationFailed ProposalRejectionReason = "NodeValidationFailed"
	// A builtin asset configuration is missing
	ProposalRejectionReasonMissingBuiltinAssetField ProposalRejectionReason = "MissingBuiltinAssetField"
	// The ERC20 contract address is missing from an ERC20 asset proposal
	ProposalRejectionReasonMissingERC20ContractAddress ProposalRejectionReason = "MissingERC20ContractAddress"
	// The specified asset for the market proposal is invalid
	ProposalRejectionReasonInvalidAsset ProposalRejectionReason = "InvalidAsset"
	// proposal terms timestamps are not compatible (Validation < Closing < Enactment)
	ProposalRejectionReasonIncompatibleTimestamps ProposalRejectionReason = "IncompatibleTimestamps"
	// Risk parameters are missing from the market proposal
	ProposalRejectionReasonNoRiskParameters ProposalRejectionReason = "NoRiskParameters"
	// Invalid key in update network parameter proposal
	ProposalRejectionReasonNetworkParameterInvalidKey ProposalRejectionReason = "NetworkParameterInvalidKey"
	// Invalid value in update network parameter proposal
	ProposalRejectionReasonNetworkParameterInvalidValue ProposalRejectionReason = "NetworkParameterInvalidValue"
	// Validation failed for network parameter proposal
	ProposalRejectionReasonNetworkParameterValidationFailed ProposalRejectionReason = "NetworkParameterValidationFailed"
	// Opening auction duration is less than the network minimum opening auction time
	ProposalRejectionReasonOpeningAuctionDurationTooSmall ProposalRejectionReason = "OpeningAuctionDurationTooSmall"
	// Opening auction duration is more than the network minimum opening auction time
	ProposalRejectionReasonOpeningAuctionDurationTooLarge ProposalRejectionReason = "OpeningAuctionDurationTooLarge"
	// Market proposal is missing a liquidity commitment
	ProposalRejectionReasonMarketMissingLiquidityCommitment ProposalRejectionReason = "MarketMissingLiquidityCommitment"
	// Market proposal market could not be instantiate in execution
	ProposalRejectionReasonCouldNotInstantiateMarket ProposalRejectionReason = "CouldNotInstantiateMarket"
)

var AllProposalRejectionReason = []ProposalRejectionReason{
	ProposalRejectionReasonCloseTimeTooSoon,
	ProposalRejectionReasonCloseTimeTooLate,
	ProposalRejectionReasonEnactTimeTooSoon,
	ProposalRejectionReasonEnactTimeTooLate,
	ProposalRejectionReasonInsufficientTokens,
	ProposalRejectionReasonInvalidInstrumentSecurity,
	ProposalRejectionReasonNoProduct,
	ProposalRejectionReasonUnsupportedProduct,
	ProposalRejectionReasonInvalidFutureMaturityTimestamp,
	ProposalRejectionReasonProductMaturityIsPassed,
	ProposalRejectionReasonNoTradingMode,
	ProposalRejectionReasonUnsupportedTradingMode,
	ProposalRejectionReasonNodeValidationFailed,
	ProposalRejectionReasonMissingBuiltinAssetField,
	ProposalRejectionReasonMissingERC20ContractAddress,
	ProposalRejectionReasonInvalidAsset,
	ProposalRejectionReasonIncompatibleTimestamps,
	ProposalRejectionReasonNoRiskParameters,
	ProposalRejectionReasonNetworkParameterInvalidKey,
	ProposalRejectionReasonNetworkParameterInvalidValue,
	ProposalRejectionReasonNetworkParameterValidationFailed,
	ProposalRejectionReasonOpeningAuctionDurationTooSmall,
	ProposalRejectionReasonOpeningAuctionDurationTooLarge,
	ProposalRejectionReasonMarketMissingLiquidityCommitment,
	ProposalRejectionReasonCouldNotInstantiateMarket,
}

func (e ProposalRejectionReason) IsValid() bool {
	switch e {
	case ProposalRejectionReasonCloseTimeTooSoon, ProposalRejectionReasonCloseTimeTooLate, ProposalRejectionReasonEnactTimeTooSoon, ProposalRejectionReasonEnactTimeTooLate, ProposalRejectionReasonInsufficientTokens, ProposalRejectionReasonInvalidInstrumentSecurity, ProposalRejectionReasonNoProduct, ProposalRejectionReasonUnsupportedProduct, ProposalRejectionReasonInvalidFutureMaturityTimestamp, ProposalRejectionReasonProductMaturityIsPassed, ProposalRejectionReasonNoTradingMode, ProposalRejectionReasonUnsupportedTradingMode, ProposalRejectionReasonNodeValidationFailed, ProposalRejectionReasonMissingBuiltinAssetField, ProposalRejectionReasonMissingERC20ContractAddress, ProposalRejectionReasonInvalidAsset, ProposalRejectionReasonIncompatibleTimestamps, ProposalRejectionReasonNoRiskParameters, ProposalRejectionReasonNetworkParameterInvalidKey, ProposalRejectionReasonNetworkParameterInvalidValue, ProposalRejectionReasonNetworkParameterValidationFailed, ProposalRejectionReasonOpeningAuctionDurationTooSmall, ProposalRejectionReasonOpeningAuctionDurationTooLarge, ProposalRejectionReasonMarketMissingLiquidityCommitment, ProposalRejectionReasonCouldNotInstantiateMarket:
		return true
	}
	return false
}

func (e ProposalRejectionReason) String() string {
	return string(e)
}

func (e *ProposalRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalRejectionReason", str)
	}
	return nil
}

func (e ProposalRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Various states a proposal can transition through:
// Open ->
// - Passed -> Enacted.
// - Rejected.
// Proposal can enter Failed state from any other state.
type ProposalState string

const (
	// Proposal became invalid and cannot be processed
	ProposalStateFailed ProposalState = "Failed"
	// Proposal is open for voting
	ProposalStateOpen ProposalState = "Open"
	// Proposal has gained enough support to be executed
	ProposalStatePassed ProposalState = "Passed"
	// Proposal didn't get enough votes
	ProposalStateDeclined ProposalState = "Declined"
	// Proposal could not gain enough support to be executed
	ProposalStateRejected ProposalState = "Rejected"
	// Proposal has been executed and the changes under this proposal have now been applied
	ProposalStateEnacted ProposalState = "Enacted"
	// Proposal is waiting for the node to run validation
	ProposalStateWaitingForNodeVote ProposalState = "WaitingForNodeVote"
)

var AllProposalState = []ProposalState{
	ProposalStateFailed,
	ProposalStateOpen,
	ProposalStatePassed,
	ProposalStateDeclined,
	ProposalStateRejected,
	ProposalStateEnacted,
	ProposalStateWaitingForNodeVote,
}

func (e ProposalState) IsValid() bool {
	switch e {
	case ProposalStateFailed, ProposalStateOpen, ProposalStatePassed, ProposalStateDeclined, ProposalStateRejected, ProposalStateEnacted, ProposalStateWaitingForNodeVote:
		return true
	}
	return false
}

func (e ProposalState) String() string {
	return string(e)
}

func (e *ProposalState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalState", str)
	}
	return nil
}

func (e ProposalState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether the placer of an order is aiming to buy or sell on the market
type Side string

const (
	// The Placer of the order is aiming to buy
	SideBuy Side = "Buy"
	// The placer of the order is aiming to sell
	SideSell Side = "Sell"
)

var AllSide = []Side{
	SideBuy,
	SideSell,
}

func (e Side) IsValid() bool {
	switch e {
	case SideBuy, SideSell:
		return true
	}
	return false
}

func (e Side) String() string {
	return string(e)
}

func (e *Side) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Side(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Side", str)
	}
	return nil
}

func (e Side) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The way the transaction is sent to the blockchain
type SubmitTransactionType string

const (
	// The call will return as soon as submitted
	SubmitTransactionTypeAsync SubmitTransactionType = "Async"
	// The call will return once the mempool has run CheckTx on the transaction
	SubmitTransactionTypeSync SubmitTransactionType = "Sync"
	// The call will return once the transaction has been processed by the core
	SubmitTransactionTypeCommit SubmitTransactionType = "Commit"
)

var AllSubmitTransactionType = []SubmitTransactionType{
	SubmitTransactionTypeAsync,
	SubmitTransactionTypeSync,
	SubmitTransactionTypeCommit,
}

func (e SubmitTransactionType) IsValid() bool {
	switch e {
	case SubmitTransactionTypeAsync, SubmitTransactionTypeSync, SubmitTransactionTypeCommit:
		return true
	}
	return false
}

func (e SubmitTransactionType) String() string {
	return string(e)
}

func (e *SubmitTransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmitTransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmitTransactionType", str)
	}
	return nil
}

func (e SubmitTransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid trade types
type TradeType string

const (
	// Default trade type
	TradeTypeDefault TradeType = "Default"
	// Network close-out - good
	TradeTypeNetworkCloseOutGood TradeType = "NetworkCloseOutGood"
	// Network close-out - bad
	TradeTypeNetworkCloseOutBad TradeType = "NetworkCloseOutBad"
)

var AllTradeType = []TradeType{
	TradeTypeDefault,
	TradeTypeNetworkCloseOutGood,
	TradeTypeNetworkCloseOutBad,
}

func (e TradeType) IsValid() bool {
	switch e {
	case TradeTypeDefault, TradeTypeNetworkCloseOutGood, TradeTypeNetworkCloseOutBad:
		return true
	}
	return false
}

func (e TradeType) String() string {
	return string(e)
}

func (e *TradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeType", str)
	}
	return nil
}

func (e TradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteValue string

const (
	// NO reject a proposal
	VoteValueNo VoteValue = "NO"
	// YES accept a proposal
	VoteValueYes VoteValue = "YES"
)

var AllVoteValue = []VoteValue{
	VoteValueNo,
	VoteValueYes,
}

func (e VoteValue) IsValid() bool {
	switch e {
	case VoteValueNo, VoteValueYes:
		return true
	}
	return false
}

func (e VoteValue) String() string {
	return string(e)
}

func (e *VoteValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteValue", str)
	}
	return nil
}

func (e VoteValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a withdrawal
type WithdrawalStatus string

const (
	// The withdrawal is open and being processed by the network
	WithdrawalStatusOpen WithdrawalStatus = "Open"
	// The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	WithdrawalStatusCancelled WithdrawalStatus = "Cancelled"
	// The withdrawal was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts
	WithdrawalStatusFinalized WithdrawalStatus = "Finalized"
)

var AllWithdrawalStatus = []WithdrawalStatus{
	WithdrawalStatusOpen,
	WithdrawalStatusCancelled,
	WithdrawalStatusFinalized,
}

func (e WithdrawalStatus) IsValid() bool {
	switch e {
	case WithdrawalStatusOpen, WithdrawalStatusCancelled, WithdrawalStatusFinalized:
		return true
	}
	return false
}

func (e WithdrawalStatus) String() string {
	return string(e)
}

func (e *WithdrawalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WithdrawalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WithdrawalStatus", str)
	}
	return nil
}

func (e WithdrawalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
