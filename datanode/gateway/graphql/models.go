// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/protos/data-node/api/v2"
	"code.vegaprotocol.io/vega/protos/vega"
	"code.vegaprotocol.io/vega/protos/vega/data/v1"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

type DataSourceKind interface {
	IsDataSourceKind()
}

// Union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind
type Event interface {
	IsEvent()
}

type ExternalDataSourceKind interface {
	IsExternalDataSourceKind()
}

type GameEntity interface {
	IsGameEntity()
}

type GovernanceTransferKind interface {
	IsGovernanceTransferKind()
}

type InternalDataSourceKind interface {
	IsInternalDataSourceKind()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProductConfiguration interface {
	IsProductConfiguration()
}

type ProductData interface {
	IsProductData()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type SignerKind interface {
	IsSignerKind()
}

type StopOrderTrigger interface {
	IsStopOrderTrigger()
}

type TransferKind interface {
	IsTransferKind()
}

type TriggerKind interface {
	IsTriggerKind()
}

// One of the possible asset sources for update assets proposals
type UpdateAssetSource interface {
	IsUpdateAssetSource()
}

type UpdateMarketRiskParameters interface {
	IsUpdateMarketRiskParameters()
}

type UpdateProductConfiguration interface {
	IsUpdateProductConfiguration()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// An auction duration is used to configure 3 auction periods:
// 1. `duration > 0`, `volume == 0`:
// The auction will last for at least N seconds.
// 2. `duration == 0`, `volume > 0`:
// The auction will end once the given volume will match at uncrossing.
// 3. `duration > 0`, `volume > 0`:
// The auction will take at least N seconds, but can end sooner if the market can trade a certain volume.
type AuctionDuration struct {
	// Duration of the auction in seconds
	DurationSecs int `json:"durationSecs"`
	// Target uncrossing trading volume
	Volume int `json:"volume"`
}

// A Vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

type BusEvent struct {
	// The ID for this event
	ID string `json:"id"`
	// The block hash
	Block string `json:"block"`
	// The type of event
	Type BusEventType `json:"type"`
	// The payload - the wrapped event
	Event Event `json:"event"`
}

// Condition describes the condition that must be validated by the data source engine
type Condition struct {
	// The type of comparison to make on the value.
	Operator v1.Condition_Operator `json:"operator"`
	// The value to compare against.
	Value *string `json:"value"`
}

// A mode where Vega tries to execute orders as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// A data source contains the data sent by a data source
type Data struct {
	// signers is the list of public keys/ETH addresses that signed the data
	Signers []*Signer `json:"signers"`
	// properties contains all the properties sent by a data source
	Data     []*v1.Property `json:"data"`
	MetaData []*v1.Property `json:"metaData"`
	// List of all the data specs that matched this source data.
	// When the array is empty, it means no data spec matched this source data.
	MatchedSpecIds []string `json:"matchedSpecIds"`
	// RFC3339Nano formatted date and time for when the data was broadcast to the markets
	// with a matching data spec.
	// It has no value when the source data does not match any data spec.
	BroadcastAt int64 `json:"broadcastAt"`
}

// An data source specification describes the data source data that a product (or a risk model)
// wants to get from the oracle engine.
type DataSourceSpec struct {
	// ID is a hash generated from the DataSourceSpec data.
	ID string `json:"id"`
	// RFC3339Nano creation date time
	CreatedAt int64 `json:"createdAt"`
	// RFC3339Nano last updated timestamp
	UpdatedAt *int64                     `json:"updatedAt"`
	Data      *vega.DataSourceDefinition `json:"data"`
	// Status describes the status of the data source spec
	Status DataSourceSpecStatus `json:"status"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the ERC20 contract
	ContractAddress string `json:"contractAddress"`
	// The lifetime limits deposit per address
	// Note: this is a temporary measure that can be changed by governance
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
	// There is no limit on the size of a withdrawal
	// Note: this is a temporary measure that can be changed by governance
	WithdrawThreshold string `json:"withdrawThreshold"`
}

func (Erc20) IsAssetSource() {}

type ERC20MultiSigSignerAddedBundleEdge struct {
	Node   *v2.ERC20MultiSigSignerAddedBundle `json:"node"`
	Cursor string                             `json:"cursor"`
}

// Response for the signature bundle to add a particular validator to the signer list of the multisig contract
type ERC20MultiSigSignerAddedConnection struct {
	Edges    []*ERC20MultiSigSignerAddedBundleEdge `json:"edges"`
	PageInfo *v2.PageInfo                          `json:"pageInfo"`
}

type ERC20MultiSigSignerRemovedBundleEdge struct {
	Node   *v2.ERC20MultiSigSignerRemovedBundle `json:"node"`
	Cursor string                               `json:"cursor"`
}

// Response for the signature bundle to remove a particular validator from the signer list of the multisig contract
type ERC20MultiSigSignerRemovedConnection struct {
	// The list of signer bundles for that validator
	Edges []*ERC20MultiSigSignerRemovedBundleEdge `json:"edges"`
	// The pagination information
	PageInfo *v2.PageInfo `json:"pageInfo"`
}

// Response for the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge
type ERC20SetAssetLimitsBundle struct {
	// The address of the asset on ethereum
	AssetSource string `json:"assetSource"`
	// The ID of the vega asset
	VegaAssetID string `json:"vegaAssetId"`
	// The nonce, which is actually the internal reference for the proposal
	Nonce string `json:"nonce"`
	// The lifetime limit deposit for this asset
	LifetimeLimit string `json:"lifetimeLimit"`
	// The threshold withdraw for this asset
	Threshold string `json:"threshold"`
	// The signatures bundle as hex encoded data, forward by 0x
	// e.g: 0x + sig1 + sig2 + ... + sixN
	Signatures string `json:"signatures"`
}

type ETHAddress struct {
	Address *string `json:"address"`
}

func (ETHAddress) IsSignerKind() {}

// Summary of a node's rewards for a given epoch
type EpochParticipation struct {
	Epoch *vega.Epoch `json:"epoch"`
	// RFC3339 timestamp
	Offline *int64 `json:"offline"`
	// RFC3339 timestamp
	Online *int64 `json:"online"`
	// Total amount rewarded for participation in the given epoch
	TotalRewards *float64 `json:"totalRewards"`
}

// Response for the signature bundle to allowlist an ERC20 token in the collateral bridge
type Erc20ListAssetBundle struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The ID of the vega asset
	VegaAssetID string `json:"vegaAssetId"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawn
	Amount string `json:"amount"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
	// The target address that will receive the funds
	TargetAddress string `json:"targetAddress"`
	// RFC3339Nano timestamp at which the withdrawal was created
	Creation string `json:"creation"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// EthCallTrigger is the type of trigger used to make calls to Ethereum network.
type EthCallTrigger struct {
	Trigger TriggerKind `json:"trigger"`
}

// Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
// one-off or repeating.
type EthTimeTrigger struct {
	// Trigger when the Ethereum time is greater or equal to this time, in Unix seconds.
	Initial *int64 `json:"initial"`
	// Repeat the call every n seconds after the initial call. If no time for
	// initial call was specified, begin repeating immediately.
	Every *int `json:"every"`
	// If repeating, stop once Ethereum time is greater than this time, in Unix
	// seconds. If not set, then repeat indefinitely.
	Until *int64 `json:"until"`
}

func (EthTimeTrigger) IsTriggerKind() {}

// An Ethereum data source
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

type ExternalData struct {
	Data *Data `json:"data"`
}

// externalDataSourceSpec is the type that wraps the DataSourceSpec type in order to be further used/extended
// by the OracleSpec
type ExternalDataSourceSpec struct {
	Spec *DataSourceSpec `json:"spec"`
}

// An estimate of the fee to be paid for the order
type FeeEstimate struct {
	// The estimated fees if the order was to trade
	Fees *TradeFee `json:"fees"`
	// The total estimated amount of fees if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
}

// Filter describes the conditions under which oracle data is considered of
// interest or not.
type Filter struct {
	// key is the data source data property key targeted by the filter.
	Key *PropertyKey `json:"key"`
	// The conditions that should be matched by the data to be
	// considered of interest.
	Conditions []*Condition `json:"conditions"`
}

// Individual party participating in a game and their metrics
type IndividualGameEntity struct {
	// Party ID of the participant
	Individual string `json:"individual"`
	// The rank of the individual within the game. If the individual is in a team, then the rank of the individual in the team
	Rank int `json:"rank"`
	// The volume traded by the individual
	Volume string `json:"volume"`
	// The reward metric applied to the game
	RewardMetric string `json:"rewardMetric"`
	// The rewards earned by the individual during the epoch
	RewardEarned string `json:"rewardEarned"`
	// Total rewards earned by the individual during the game
	TotalRewardsEarned string `json:"totalRewardsEarned"`
}

func (IndividualGameEntity) IsGameEntity() {}

// Configuration of a market liquidity monitoring parameters
type LiquidityMonitoringParameters struct {
	// Specifies parameters related to target stake calculation
	TargetStakeParameters *TargetStakeParameters `json:"targetStakeParameters"`
	// Specifies the triggering ratio for entering liquidity auction
	TriggeringRatio string `json:"triggeringRatio"`
	// Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

// The equity like share of liquidity fee for each liquidity provider
type LiquidityProviderFeeShare struct {
	// The liquidity provider party ID
	Party *vega.Party `json:"party"`
	// The share owned by this liquidity provider
	EquityLikeShare string `json:"equityLikeShare"`
	// The average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
	// The average liquidity score
	AverageScore string `json:"averageScore"`
	// The virtual stake for this liquidity provider
	VirtualStake string `json:"virtualStake"`
}

// The SLA statistics for each liquidity provider
type LiquidityProviderSLA struct {
	// The liquidity provider party ID
	Party *vega.Party `json:"party"`
	// Indicates how often LP meets the commitment during the current epoch.
	CurrentEpochFractionOfTimeOnBook string `json:"currentEpochFractionOfTimeOnBook"`
	// Indicates how often LP met the commitment in the previous epoch.
	LastEpochFractionOfTimeOnBook string `json:"lastEpochFractionOfTimeOnBook"`
	// Indicates the fee penalty amount applied in the previous epoch.
	LastEpochFeePenalty string `json:"lastEpochFeePenalty"`
	// Indicates the bond penalty amount applied in the previous epoch.
	LastEpochBondPenalty string `json:"lastEpochBondPenalty"`
	// Determines how the fee penalties from past epochs affect future fee revenue.
	HysteresisPeriodFeePenalties []string `json:"hysteresisPeriodFeePenalties"`
	// Represents the total amount of funds LP must supply. The amount to be supplied is in the market’s settlement currency, spread on both buy and sell sides of the order book within a defined range.
	RequiredLiquidity string `json:"requiredLiquidity"`
	// Notional volume of orders within the range provided on the buy side of the book.
	NotionalVolumeBuys string `json:"notionalVolumeBuys"`
	// Notional volume of orders within the range provided on the sell side of the book.
	NotionalVolumeSells string `json:"notionalVolumeSells"`
}

type LossSocialization struct {
	// The market ID where loss socialization happened
	MarketID string `json:"marketId"`
	// The party that was part of the loss socialization
	PartyID string `json:"partyId"`
	// The amount lost
	Amount string `json:"amount"`
}

// The liquidity commitments for this market
type MarketDataCommitments struct {
	// A set of liquidity sell orders to meet the liquidity provision obligation.
	Sells []*vega.LiquidityOrderReference `json:"sells"`
	// A set of liquidity buy orders to meet the liquidity provision obligation.
	Buys []*vega.LiquidityOrderReference `json:"buys"`
}

type MarketDepthTrade struct {
	// ID of the trade for the given market (if available)
	ID string `json:"id"`
	// Price of the trade
	Price string `json:"price"`
	// Size of the trade
	Size string `json:"size"`
}

type MarketEvent struct {
	// The market ID
	MarketID string `json:"marketId"`
	// The message - market events are used for logging
	Payload string `json:"payload"`
}

type MarketTick struct {
	// The market ID
	MarketID string `json:"marketId"`
	// The block time
	Time string `json:"time"`
}

// Details on the collection of nodes for particular validator status
type NodeSet struct {
	// Total number of nodes in the node set
	Total int `json:"total"`
	// Number of nodes in the node set that had a performance score of 0 at the end of the last epoch
	Inactive int `json:"inactive"`
	// IDs of the nodes that were promoted into this node set at the start of the epoch
	Promoted []string `json:"promoted"`
	// IDs of the nodes that were demoted into this node set at the start of the epoch
	Demoted []string `json:"demoted"`
	// Total number of nodes allowed in the node set
	Maximum *int `json:"maximum"`
}

// Normaliser to convert the data returned from the contract method
// into a standard format.
type Normaliser struct {
	Name       string `json:"name"`
	Expression string `json:"expression"`
}

// The equity like share of liquidity fee for each liquidity provider
type ObservableLiquidityProviderFeeShare struct {
	// The liquidity provider party ID
	PartyID string `json:"partyId"`
	// The share owned by this liquidity provider (float)
	EquityLikeShare string `json:"equityLikeShare"`
	// The average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
	// The average liquidity score
	AverageScore string `json:"averageScore"`
}

// The SLA statistics for each liquidity provider
type ObservableLiquidityProviderSLA struct {
	// The liquidity provider party ID
	Party string `json:"party"`
	// Indicates how often LP meets the commitment during the current epoch.
	CurrentEpochFractionOfTimeOnBook string `json:"currentEpochFractionOfTimeOnBook"`
	// Indicates how often LP meets the commitment during last epoch.
	LastEpochFractionOfTimeOnBook string `json:"lastEpochFractionOfTimeOnBook"`
	// Indicates the fee penalty amount applied in the previous epoch.
	LastEpochFeePenalty string `json:"lastEpochFeePenalty"`
	// Indicates the bond penalty amount applied in the previous epoch.
	LastEpochBondPenalty string `json:"lastEpochBondPenalty"`
	// Determines how the fee penalties from past epochs affect future fee revenue.
	HysteresisPeriodFeePenalties []string `json:"hysteresisPeriodFeePenalties"`
	// Represents the total amount of funds LP must supply. The amount to be supplied is in the market’s settlement currency, spread on both buy and sell sides of the order book within a defined range.
	RequiredLiquidity string `json:"requiredLiquidity"`
	// Notional volume of orders within the range provided on the buy side of the book.
	NotionalVolumeBuys string `json:"notionalVolumeBuys"`
	// Notional volume of orders within the range provided on the sell side of the book.
	NotionalVolumeSells string `json:"notionalVolumeSells"`
}

type OrderByMarketAndPartyIdsFilter struct {
	Order     *v2.OrderFilter `json:"order"`
	MarketIds []string        `json:"marketIds"`
	PartyIds  []string        `json:"partyIds"`
}

type OrderByMarketIdsFilter struct {
	Order     *v2.OrderFilter `json:"order"`
	MarketIds []string        `json:"marketIds"`
}

type OrderByPartyIdsFilter struct {
	Order    *v2.OrderFilter `json:"order"`
	PartyIds []string        `json:"partyIds"`
}

// An estimate of the fee to be paid by the order
type OrderEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
	// The margin requirement for this order
	MarginLevels *vega.MarginLevels `json:"marginLevels"`
}

// Basic description of an order
type OrderInfo struct {
	// Whether the order is to buy or sell
	Side vega.Side `json:"side"`
	// Price for the order
	Price string `json:"price"`
	// Number of units remaining of the total that have not yet been bought or sold (uint64)
	Remaining string `json:"remaining"`
	// Boolean indicating a market order
	IsMarketOrder bool `json:"isMarketOrder"`
}

// Response for the estimate of the margin level and, if available, collateral was provided in the request, liquidation price for the specified position
type PositionEstimate struct {
	// Margin level range estimate for the specified position
	Margin *v2.MarginEstimate `json:"margin"`
	// Liquidation price range estimate for the specified position. Only populated if available collateral was specified in the request
	Liquidation *v2.LiquidationEstimate `json:"liquidation"`
}

type PositionResolution struct {
	// The market ID where position resolution happened
	MarketID string `json:"marketId"`
	// Number of distressed parties on market
	Distressed int `json:"distressed"`
	// Number of parties closed out
	Closed int `json:"closed"`
	// The mark price at which parties were distressed/closed out
	MarkPrice string `json:"markPrice"`
}

// Range of valid prices and the associated price monitoring trigger
type PriceMonitoringBounds struct {
	// Minimum price that isn't currently breaching the specified price monitoring trigger
	MinValidPrice string `json:"minValidPrice"`
	// Maximum price that isn't currently breaching the specified price monitoring trigger
	MaxValidPrice string `json:"maxValidPrice"`
	// Price monitoring trigger associated with the bounds
	Trigger *PriceMonitoringTrigger `json:"trigger"`
	// Reference price used to calculate the valid price range
	ReferencePrice string `json:"referencePrice"`
}

// PriceMonitoringParameters holds a list of triggers
type PriceMonitoringParameters struct {
	// The list of triggers for this price monitoring
	Triggers []*PriceMonitoringTrigger `json:"triggers"`
}

// Configuration of a market price monitoring auctions triggers
type PriceMonitoringSettings struct {
	// Specified a set of PriceMonitoringParameters to be use for price monitoring purposes
	Parameters *PriceMonitoringParameters `json:"parameters"`
}

// PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration
type PriceMonitoringTrigger struct {
	// Price monitoring projection horizon τ in seconds (> 0).
	HorizonSecs int `json:"horizonSecs"`
	// Price monitoring probability level p. (>0 and < 1)
	Probability float64 `json:"probability"`
	// Price monitoring auction extension duration in seconds should the price
	// breach its theoretical level over the specified horizon at the specified
	// probability level (> 0)
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

// PropertyKey describes the property key contained in a source data.
type PropertyKey struct {
	// The name of the property.
	Name *string `json:"name"`
	// The type of the property.
	Type v1.PropertyKey_Type `json:"type"`
	// An optional decimal place to be applied on the provided value.
	// Valid only for PropertyType of type DECIMAL, INTEGER.
	NumberDecimalPlaces *int `json:"numberDecimalPlaces"`
}

type ProposalVote struct {
	// Cast vote
	Vote *vega.Vote `json:"vote"`
	// Proposal ID the vote is cast on
	ProposalID string `json:"proposalId"`
}

// Connection type for retrieving cursor-based paginated proposal vote information
type ProposalVoteConnection struct {
	// The proposal votes in this connection
	Edges []*ProposalVoteEdge `json:"edges"`
	// The pagination information
	PageInfo *v2.PageInfo `json:"pageInfo"`
}

// Edge type containing the proposal vote and cursor information returned by a ProposalVoteConnection
type ProposalVoteEdge struct {
	// The proposal vote
	Node *ProposalVote `json:"node"`
	// The cursor for this proposal vote
	Cursor *string `json:"cursor"`
}

type ProposalVoteSide struct {
	// All votes cast for this side
	Votes []*vega.Vote `json:"votes"`
	// Total number of votes cast for this side
	TotalNumber string `json:"totalNumber"`
	// Total weight of governance token from the votes cast for this side
	TotalWeight string `json:"totalWeight"`
	// Total number of governance tokens from the votes cast for this side
	TotalTokens string `json:"totalTokens"`
	// Total equity like share weight for this side (only for UpdateMarket Proposals)
	TotalEquityLikeShareWeight string `json:"totalEquityLikeShareWeight"`
}

type ProposalVotes struct {
	// Yes votes cast for this proposal
	Yes *ProposalVoteSide `json:"yes"`
	// No votes cast for this proposal
	No *ProposalVoteSide `json:"no"`
}

// Indicator showing whether the data-node is ready for the protocol upgrade to begin.
type ProtocolUpgradeStatus struct {
	Ready bool `json:"ready"`
}

type PubKey struct {
	Key *string `json:"key"`
}

func (PubKey) IsSignerKind() {}

// Connection type for retrieving cursor-based paginated reward summary information
type RewardSummaryConnection struct {
	// List of reward summaries available for the connection
	Edges []*RewardSummaryEdge `json:"edges"`
	// Page information for the connection
	PageInfo *v2.PageInfo `json:"pageInfo"`
}

// Edge type containing the reward summary and cursor information returned by a RewardSummaryConnection
type RewardSummaryEdge struct {
	// The reward summary
	Node *vega.RewardSummary `json:"node"`
	// Cursor identifying the reward summary
	Cursor string `json:"cursor"`
}

type SettleDistressed struct {
	// The market in which a position was closed out
	MarketID string `json:"marketId"`
	// The party that was closed out
	PartyID string `json:"partyId"`
	// The margin taken from distressed party
	Margin string `json:"margin"`
	// The price at which the position was closed out
	Price string `json:"price"`
}

type SettlePosition struct {
	// The market in which a position was settled
	MarketID string `json:"marketId"`
	// The party who settled a position
	PartyID string `json:"partyId"`
	// The settle price
	Price string `json:"price"`
	// The trades that were settled to close the overall position
	TradeSettlements []*TradeSettlement `json:"tradeSettlements"`
}

// Signer is the authorized signature used for the data.
type Signer struct {
	Signer SignerKind `json:"signer"`
}

// All staking information related to a Party.
// Contains the current recognised balance by the network and
// all the StakeLink/Unlink seen by the network
type StakingSummary struct {
	// The stake currently available for the party
	CurrentStakeAvailable string `json:"currentStakeAvailable"`
	// The list of all stake link/unlink for the party
	Linkings *v2.StakesConnection `json:"linkings"`
}

// Price at which a stop order will trigger
type StopOrderPrice struct {
	Price string `json:"price"`
}

func (StopOrderPrice) IsStopOrderTrigger() {}

// Percentage movement in the price at which a stop order will trigger.
type StopOrderTrailingPercentOffset struct {
	TrailingPercentOffset string `json:"trailingPercentOffset"`
}

func (StopOrderTrailingPercentOffset) IsStopOrderTrigger() {}

// TargetStakeParameters contains parameters used in target stake calculation
type TargetStakeParameters struct {
	// Specifies length of time window expressed in seconds for target stake calculation
	TimeWindow int `json:"timeWindow"`
	// Specifies scaling factors used in target stake calculation
	ScalingFactor float64 `json:"scalingFactor"`
}

// Team participating in a game and their metrics.
type TeamGameEntity struct {
	// Breakdown of the team members and their contributions to the total team metrics.
	Team *TeamParticipation `json:"team"`
	// Rank of the team within the game.
	Rank int `json:"rank"`
	// Total volume traded by the team
	Volume string `json:"volume"`
	// Reward metric applied to the game.
	RewardMetric string `json:"rewardMetric"`
	// Total rewards earned by the team during the epoch
	RewardEarned string `json:"rewardEarned"`
	// Total rewards earned by the team for the game
	TotalRewardsEarned string `json:"totalRewardsEarned"`
}

func (TeamGameEntity) IsGameEntity() {}

// Team participation information, i.e. the team ID and the metrics for each participating team member.
type TeamParticipation struct {
	// Team ID
	TeamID string `json:"teamId"`
	// List of participating team members and their metrics.
	MembersParticipating []*IndividualGameEntity `json:"membersParticipating"`
}

type TimeUpdate struct {
	// RFC3339Nano time of new block time
	Timestamp int64 `json:"timestamp"`
}

func (TimeUpdate) IsEvent() {}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, paid by the aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the validators to maintain the Vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the liquidity providers that committed liquidity to the market
	LiquidityFee string `json:"liquidityFee"`
	// Referral discount on maker fees for the trade
	MakerFeeReferralDiscount *string `json:"makerFeeReferralDiscount"`
	// Volume discount on maker fees for the trade
	MakerFeeVolumeDiscount *string `json:"makerFeeVolumeDiscount"`
	// Referral discount on infrastructure fees for the trade
	InfrastructureFeeReferralDiscount *string `json:"infrastructureFeeReferralDiscount"`
	// Volume discount on infrastructure fees for the trade
	InfrastructureFeeVolumeDiscount *string `json:"infrastructureFeeVolumeDiscount"`
	// Referral discount on liquidity fees for the trade
	LiquidityFeeReferralDiscount *string `json:"liquidityFeeReferralDiscount"`
	// Volume discount on liquidity fees for the trade
	LiquidityFeeVolumeDiscount *string `json:"liquidityFeeVolumeDiscount"`
}

type TradeSettlement struct {
	// The size of the trade
	Size int `json:"size"`
	// The price of the trade
	Price string `json:"price"`
}

// Filter to apply to the trade connection query
type TradesFilter struct {
	PartyIds  []string `json:"partyIds"`
	MarketIds []string `json:"marketIds"`
	OrderIds  []string `json:"orderIds"`
}

// Filter to apply to the trade subscription request
type TradesSubscriptionFilter struct {
	PartyIds  []string `json:"partyIds"`
	MarketIds []string `json:"marketIds"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

type TransferBalance struct {
	// Account involved in transfer
	Account *vega.AccountDetails `json:"account"`
	// The new balance of the account
	Balance string `json:"balance"`
}

// A transfer fee record
type TransferFee struct {
	// Transfer ID of the transfer for which the fee was paid
	TransferID string `json:"transferId"`
	// The fee amount
	Amount string `json:"amount"`
	// The epoch when this fee was paid
	Epoch int `json:"epoch"`
}

type TransferResponse struct {
	// The ledger entries and balances resulting from a transfer request
	Transfers []*vega.LedgerEntry `json:"transfers"`
	// The balances of accounts involved in the transfer
	Balances []*TransferBalance `json:"balances"`
}

type TransferResponses struct {
	// A group of transfer responses - events from core
	Responses []*TransferResponse `json:"responses"`
}

// An asset originated from an Ethereum ERC20 Token
type UpdateErc20 struct {
	// The lifetime limits deposit per address
	// Note: this is a temporary measure that can be changed by governance
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
	// There is no limit on the size of a withdrawal
	// Note: this is a temporary measure that can be changed by governance
	WithdrawThreshold string `json:"withdrawThreshold"`
}

func (UpdateErc20) IsUpdateAssetSource() {}

type UpdateInstrumentConfiguration struct {
	Code    string                     `json:"code"`
	Product UpdateProductConfiguration `json:"product"`
}

// Event types
type BusEventType string

const (
	// Vega Time has changed
	BusEventTypeTimeUpdate BusEventType = "TimeUpdate"
	// Collateral has deposited in to this Vega network via the bridge
	BusEventTypeDeposit BusEventType = "Deposit"
	// Collateral has been withdrawn from this Vega network via the bridge
	BusEventTypeWithdrawal BusEventType = "Withdrawal"
	// The results from processing at transaction
	BusEventTypeTransactionResult BusEventType = "TransactionResult"
)

var AllBusEventType = []BusEventType{
	BusEventTypeTimeUpdate,
	BusEventTypeDeposit,
	BusEventTypeWithdrawal,
	BusEventTypeTransactionResult,
}

func (e BusEventType) IsValid() bool {
	switch e {
	case BusEventTypeTimeUpdate, BusEventTypeDeposit, BusEventTypeWithdrawal, BusEventTypeTransactionResult:
		return true
	}
	return false
}

func (e BusEventType) String() string {
	return string(e)
}

func (e *BusEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusEventType", str)
	}
	return nil
}

func (e BusEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the status of the data spec
type DataSourceSpecStatus string

const (
	// Describes an active data spec
	DataSourceSpecStatusStatusActive DataSourceSpecStatus = "STATUS_ACTIVE"
	// Describes a data spec that is not listening to data
	// anymore
	DataSourceSpecStatusStatusDeactivated DataSourceSpecStatus = "STATUS_DEACTIVATED"
)

var AllDataSourceSpecStatus = []DataSourceSpecStatus{
	DataSourceSpecStatusStatusActive,
	DataSourceSpecStatusStatusDeactivated,
}

func (e DataSourceSpecStatus) IsValid() bool {
	switch e {
	case DataSourceSpecStatusStatusActive, DataSourceSpecStatusStatusDeactivated:
		return true
	}
	return false
}

func (e DataSourceSpecStatus) String() string {
	return string(e)
}

func (e *DataSourceSpecStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataSourceSpecStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DataSourceSpecStatus", str)
	}
	return nil
}

func (e DataSourceSpecStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GovernanceTransferType string

const (
	// Default value, always invalid
	GovernanceTransferTypeGovernanceTransferTypeUnspecified GovernanceTransferType = "GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED"
	// Transfers the specified amount or does not transfer anything
	GovernanceTransferTypeGovernanceTransferTypeAllOrNothing GovernanceTransferType = "GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING"
	// Transfers the specified amount or the max allowable amount if this is less than the specified amount
	GovernanceTransferTypeGovernanceTransferTypeBestEffort GovernanceTransferType = "GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT"
)

var AllGovernanceTransferType = []GovernanceTransferType{
	GovernanceTransferTypeGovernanceTransferTypeUnspecified,
	GovernanceTransferTypeGovernanceTransferTypeAllOrNothing,
	GovernanceTransferTypeGovernanceTransferTypeBestEffort,
}

func (e GovernanceTransferType) IsValid() bool {
	switch e {
	case GovernanceTransferTypeGovernanceTransferTypeUnspecified, GovernanceTransferTypeGovernanceTransferTypeAllOrNothing, GovernanceTransferTypeGovernanceTransferTypeBestEffort:
		return true
	}
	return false
}

func (e GovernanceTransferType) String() string {
	return string(e)
}

func (e *GovernanceTransferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GovernanceTransferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GovernanceTransferType", str)
	}
	return nil
}

func (e GovernanceTransferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MarketUpdateType string

const (
	// Default value, always invalid
	MarketUpdateTypeMarketStateUpdateTypeUnspecified MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_UNSPECIFIED"
	// Terminate the market
	MarketUpdateTypeMarketStateUpdateTypeTerminate MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_TERMINATE"
	// Suspend the market
	MarketUpdateTypeMarketStateUpdateTypeSuspend MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_SUSPEND"
	// Resume a suspended market
	MarketUpdateTypeMarketStateUpdateTypeResume MarketUpdateType = "MARKET_STATE_UPDATE_TYPE_RESUME"
)

var AllMarketUpdateType = []MarketUpdateType{
	MarketUpdateTypeMarketStateUpdateTypeUnspecified,
	MarketUpdateTypeMarketStateUpdateTypeTerminate,
	MarketUpdateTypeMarketStateUpdateTypeSuspend,
	MarketUpdateTypeMarketStateUpdateTypeResume,
}

func (e MarketUpdateType) IsValid() bool {
	switch e {
	case MarketUpdateTypeMarketStateUpdateTypeUnspecified, MarketUpdateTypeMarketStateUpdateTypeTerminate, MarketUpdateTypeMarketStateUpdateTypeSuspend, MarketUpdateTypeMarketStateUpdateTypeResume:
		return true
	}
	return false
}

func (e MarketUpdateType) String() string {
	return string(e)
}

func (e *MarketUpdateType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketUpdateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketUpdateType", str)
	}
	return nil
}

func (e MarketUpdateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Filter type for specifying the types of transfers to filter for
type TransferDirection string

const (
	TransferDirectionTo       TransferDirection = "To"
	TransferDirectionFrom     TransferDirection = "From"
	TransferDirectionToOrFrom TransferDirection = "ToOrFrom"
)

var AllTransferDirection = []TransferDirection{
	TransferDirectionTo,
	TransferDirectionFrom,
	TransferDirectionToOrFrom,
}

func (e TransferDirection) IsValid() bool {
	switch e {
	case TransferDirectionTo, TransferDirectionFrom, TransferDirectionToOrFrom:
		return true
	}
	return false
}

func (e TransferDirection) String() string {
	return string(e)
}

func (e *TransferDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransferDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransferDirection", str)
	}
	return nil
}

func (e TransferDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
