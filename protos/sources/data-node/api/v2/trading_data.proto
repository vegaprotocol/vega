syntax = "proto3";

package datanode.api.v2;

import "vega/vega.proto";
import "vega/governance.proto";
import "vega/markets.proto";
import "vega/assets.proto";
import "vega/oracle.proto";
import "vega/events/v1/events.proto";
import "vega/commands/v1/validator_commands.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "google/api/httpbody.proto";
import "google/api/field_behavior.proto";

option go_package = "code.vegaprotocol.io/vega/protos/data-node/api/v2";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "Vega data node APIs";
    version: "v0.71.0+dev";
  }
  schemes: [HTTP, HTTPS];
  host: "https://api.testnet.vega.xyz";
  consumes: "application/json";
  responses: { // can add more keys here to specify common errors between all endpoints, can also be overwritten per rpc call
    key: "500";
    value: {
      description: "An internal server error";
      schema: {
        json_schema: {
          ref: ".google.rpc.Status";
        }
      }
    }
  }
};

service TradingDataService {
    // List accounts
    //
    // Returns a list of accounts matching the supplied filter, including their current balances.
    // If a given account has never had a balance, it will be absent from the list.
    rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Accounts";
      };
    }

    // Accounts subscription
    //
    // Subscribe to a stream of accounts
    rpc ObserveAccounts(ObserveAccountsRequest) returns (stream ObserveAccountsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Accounts";
      };
    }

    // Data node info
    //
    // Retrieves information about the data node.
    // Response contains a semver formatted version of the data node and the commit hash, from which the data node was built
  rpc Info(InfoRequest) returns (InfoResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Node information";
      };
    }

    // Get order
    //
    // Gets the current version of an order, or optionally provide a version ID to retrieve a given version if order was amended.
    rpc GetOrder(GetOrderRequest) returns (GetOrderResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Orders";
      };
    }

    // List orders
    //
    // Get a list of orders that match the given filters
    rpc ListOrders(ListOrdersRequest) returns (ListOrdersResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Orders";
      };
    }

    // List order versions
    //
    // List all versions of an order in the order history
    rpc ListOrderVersions(ListOrderVersionsRequest) returns (ListOrderVersionsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Orders";
      };
    }

    // Observe orders
    //
    // Subscribe to a stream of orders
    rpc ObserveOrders(ObserveOrdersRequest) returns (stream ObserveOrdersResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Orders";
      };
    }

    // List positions (deprecated)
    //
    // Get a list of positions by party (public key) using cursor based pagination
    // Deprecated: use ListAllPositions instead
    rpc ListPositions(ListPositionsRequest) returns (ListPositionsResponse) {
      option deprecated = true;
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Positions";
      };
    }

    // List positions
    //
    // Get a list of positions by party (public key) using cursor based pagination
    rpc ListAllPositions(ListAllPositionsRequest) returns (ListAllPositionsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Positions";
      };
    }

    // Observe positions
    //
    // Subscribe to a stream of positions
    rpc ObservePositions(ObservePositionsRequest) returns (stream ObservePositionsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Positions";
      };
    }

    // List ledger entries
    //
    // List ledger entries by asset, market, party, account type and transfer type within the given date range.
    // This query requests and sums the number of ledger entries from a given subset of accounts, specified via the 'filter' argument.
    // It returns a time series (implemented as a list of AggregateLedgerEntry structs), with a row for every time
    // the summed ledger entries of the set of specified accounts changes.
    // Listed entries should be limited to a single party from each side only. If zero or more than one party is provided
    // for each of the sides - sending and receiving accounts, the query returns an error.
    //
    // Entries can be queried by:
    //   - listing ledger entries with filtering on the sending account (market ID, asset ID, account type)
    //   - listing ledger entries with filtering on the receiving account (market ID, asset ID, account type)
    //   - listing ledger entries with filtering on the sending AND receiving account
    //   - listing ledger entries with filtering on the transfer type (on top of above filters or as a standalone option)
    rpc ListLedgerEntries(ListLedgerEntriesRequest) returns (ListLedgerEntriesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Ledger entries";
      };
    }

    // Export ledger entries
    //
    // Export ledger entries records ledger entries to a csv file.
    // May or may not contain a date range - if no date range is provided, list all records for all times.
    //
    // Ledger entries can be exported by:
    //   - export ledger entries for a single party for a given asset within a given time range
    //   - export ledger entries for a single party for a given asset for all times
    rpc ExportLedgerEntries(ExportLedgerEntriesRequest) returns (ExportLedgerEntriesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Ledger entries";
      };
    }

    // List balance changes
    //
    // `ListBalanceChanges` queries the change in account balances over a period of time.
    //
    // An account is defined as a set of (asset_id, type, party_id, market_id).
    // - Every account has an associated asset and type.
    // - Certain account types (for example, the global reward pool) do not have an associated party.
    //   These are denoted by the special party identifier 'network'
    // - Certain account types do not have an associated market (for example general party accounts).
    //   These are denoted by the special market identifier '' (the empty string)
    //
    // `ListBalanceChangesRequest` will return a list of
    // `(vega_time, asset_id, account_type, party_id, market_id, balance)`
    // With a row for each block at which a given account's balance changes.
    rpc ListBalanceChanges(ListBalanceChangesRequest) returns (ListBalanceChangesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Accounts";
      };
    }

    // Get latest market data
    //
    // Get the latest market data for a given market
    rpc GetLatestMarketData(GetLatestMarketDataRequest) returns (GetLatestMarketDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // List latest market data
    //
    // Lists the latest market data for every market
    rpc ListLatestMarketData(ListLatestMarketDataRequest) returns (ListLatestMarketDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Get latest market depth
    //
    // Get the latest market depth for a given market
    rpc GetLatestMarketDepth(GetLatestMarketDepthRequest) returns (GetLatestMarketDepthResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Observe markets depth
    //
    // Subscribe to a stream of the latest market depth for a given market
    rpc ObserveMarketsDepth(ObserveMarketsDepthRequest) returns (stream ObserveMarketsDepthResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Observe markets depth updates
    //
    // Subscribe to a stream of updates on market depth for a given market
    rpc ObserveMarketsDepthUpdates(ObserveMarketsDepthUpdatesRequest) returns (stream ObserveMarketsDepthUpdatesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Observe markets data
    //
    // Subscribe to a stream of data about a given market
    rpc ObserveMarketsData(ObserveMarketsDataRequest) returns (stream ObserveMarketsDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Get market data history
    //
    // Get market data history for a market ID between given dates
    rpc GetMarketDataHistoryByID(GetMarketDataHistoryByIDRequest) returns (GetMarketDataHistoryByIDResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // List transfers
    //
    // List transfers to/from/either a public key
    rpc ListTransfers(ListTransfersRequest) returns (ListTransfersResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Transfers";
      };
    }

    // Get network limits
    //
    // Get the current network limits (is bootstrapping finished, are proposals enabled etc..)
    rpc GetNetworkLimits(GetNetworkLimitsRequest) returns (GetNetworkLimitsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List candle data
    //
    // Get candle data for a given candle ID. You can get a candle ID from the list candle intervals query
    rpc ListCandleData(ListCandleDataRequest) returns (ListCandleDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Candles";
      };
    }

    // Observe candle data
    //
    // Subscribe to a stream of candle updates
    rpc ObserveCandleData(ObserveCandleDataRequest) returns (stream ObserveCandleDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Candles";
      };
    }

    // List candle intervals
    //
    // Get all available intervals for a given market along with the corresponding candle ID
    rpc ListCandleIntervals(ListCandleIntervalsRequest) returns (ListCandleIntervalsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Candles";
      };
    }

    // List votes
    //
    // Get votes for a party ID
    rpc ListVotes(ListVotesRequest) returns (ListVotesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Governance";
      };
    }

    // Observe votes
    //
    // Subscribe to a stream of votes
    rpc ObserveVotes(ObserveVotesRequest) returns (stream ObserveVotesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Governance";
      };
    }

    // List ERC20 multi-sig signer added bundles
    //
    // List the signature bundle to add a particular validator to the signer list of the multisig contract
    rpc ListERC20MultiSigSignerAddedBundles(ListERC20MultiSigSignerAddedBundlesRequest) returns (ListERC20MultiSigSignerAddedBundlesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "ERC20 bridge";
      };
    }

    // List ERC20 multi-sig signer removed bundles
    //
    // List the signatures bundle to remove a particular validator from signer list of the multisig contract
    rpc ListERC20MultiSigSignerRemovedBundles(ListERC20MultiSigSignerRemovedBundlesRequest) returns (ListERC20MultiSigSignerRemovedBundlesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "ERC20 bridge";
      };
    }

    // Get ERC20 list asset bundle
    //
    // Get the signatures bundle to allowlist an ERC20 token in the collateral bridge
    rpc GetERC20ListAssetBundle(GetERC20ListAssetBundleRequest) returns (GetERC20ListAssetBundleResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "ERC20 bridge";
      };
    }

    // Get ERC20 set asset limits bundle
    //
    // Get the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge
    rpc GetERC20SetAssetLimitsBundle(GetERC20SetAssetLimitsBundleRequest) returns (GetERC20SetAssetLimitsBundleResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "ERC20 bridge";
      };
    }

    // Get ERC20 withdrawal approval
    //
    // Get the signature bundle to finalize a withdrawal on ethereum
    rpc GetERC20WithdrawalApproval(GetERC20WithdrawalApprovalRequest) returns (GetERC20WithdrawalApprovalResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "ERC20 bridge";
      };
    }

    // Get latest trade
    //
    // Get latest trade
    rpc GetLastTrade(GetLastTradeRequest) returns (GetLastTradeResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Trades";
      };
    }

    // List trades
    //
    // Get a list of all trades, optionally filtered by party/market/order
    rpc ListTrades(ListTradesRequest) returns (ListTradesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Trades";
      };
    }

    // Observe trades
    //
    // Subscribe to a stream of trades, optionally filtered by party/market
    rpc ObserveTrades(ObserveTradesRequest) returns (stream ObserveTradesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Trades";
      };
    }

    // Get oracle spec
    //
    // Get an oracle spec by ID. Use the oracle spec list to query for oracle spec IDs
    rpc GetOracleSpec(GetOracleSpecRequest) returns (GetOracleSpecResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Data sources";
      };
    }

    // List oracle specs
    //
    // List specs for an oracle
    rpc ListOracleSpecs(ListOracleSpecsRequest) returns (ListOracleSpecsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Data sources";
      };
    }

    // List oracle data
    //
    // Get all oracle data
    rpc ListOracleData(ListOracleDataRequest) returns (ListOracleDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Data sources";
      };
    }

    // Get market
    //
    // Get information about a specific market using its ID. Use the market lists query to get a market's ID
    rpc GetMarket(GetMarketRequest) returns (GetMarketResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // List markets
    //
    // Get markets using a cursor based pagination
    rpc ListMarkets(ListMarketsRequest) returns (ListMarketsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Get party
    //
    // Get a single party
    rpc GetParty(GetPartyRequest) returns (GetPartyResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Parties";
      };
    }

    // List parties
    //
    // Get parties
    rpc ListParties(ListPartiesRequest) returns (ListPartiesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Parties";
      };
    }

    // List margin levels
    //
    // Get margin levels
    rpc ListMarginLevels(ListMarginLevelsRequest) returns (ListMarginLevelsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Margin levels";
      };
    }

    // Observe margin levels
    //
    // Subscribe to a stream of margin levels
    rpc ObserveMarginLevels(ObserveMarginLevelsRequest) returns (stream ObserveMarginLevelsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Margin levels";
      };
    }

    // List rewards
    //
    // List rewards
    rpc ListRewards(ListRewardsRequest) returns (ListRewardsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Rewards";
      };
    }

    // List reward summaries
    //
    // Get reward summaries
    rpc ListRewardSummaries(ListRewardSummariesRequest) returns (ListRewardSummariesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Rewards";
      };
    }

    // List epoch reward summaries
    //
    // List reward summaries by epoch
    rpc ListEpochRewardSummaries(ListEpochRewardSummariesRequest) returns (ListEpochRewardSummariesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Rewards";
      };
    }

    // Get deposit
    //
    // Get a deposit by its identifier
    rpc GetDeposit(GetDepositRequest) returns (GetDepositResponse)  {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Assets";
      };
    }

    // List deposits
    //
    // Get a list of deposits for a given party.
    // If a date range is provided, filtering will be based on the last time the deposit
    // has been updated (in Vega time).
    rpc ListDeposits(ListDepositsRequest) returns (ListDepositsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Assets";
      };
    }

    // Get withdrawal
    //
    // Get a withdrawal by its ID. Use the withdrawls list query to get withdrawal IDs
    rpc GetWithdrawal(GetWithdrawalRequest) returns (GetWithdrawalResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Assets";
      };
    }

    // List withdrawals
    //
    // Get a list of withdrawals for a given party
    rpc ListWithdrawals(ListWithdrawalsRequest) returns (ListWithdrawalsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Assets";
      };
    }

    // Get asset
    //
    // Get a single asset using its ID. Use the assets list query to get an asset's ID
    rpc GetAsset(GetAssetRequest) returns (GetAssetResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Assets";
      };
    }

    // List assets
    //
    // Get a list of assets using cursor based pagination
    rpc ListAssets(ListAssetsRequest) returns (ListAssetsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Assets";
      };
    }

    // List liquidity provisions
    //
    // Get a list of liquidity provisions for a given market using a cursor based pagination
    rpc ListLiquidityProvisions(ListLiquidityProvisionsRequest) returns (ListLiquidityProvisionsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Liquidity provisions";
      };
    }

    // Observe liquidity provisions
    //
    // Get a liquidity provision subscription for a given market and party
    rpc ObserveLiquidityProvisions(ObserveLiquidityProvisionsRequest) returns (stream ObserveLiquidityProvisionsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Liquidity provisions";
      };
    }

    // Get governance data
    //
    // Get a single proposal's details
    rpc GetGovernanceData(GetGovernanceDataRequest) returns (GetGovernanceDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Governance";
      };
    }

    // List governance data
    //
    // List proposals
    rpc ListGovernanceData(ListGovernanceDataRequest) returns (ListGovernanceDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Governance";
      };
    }

    // Observe governance
    //
    // Subscribe to a stream of governance proposals
    rpc ObserveGovernance(ObserveGovernanceRequest) returns (stream ObserveGovernanceResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Governance";
      };
    }

    // List delegations
    //
    // List the token delegations on the network
    rpc ListDelegations(ListDelegationsRequest) returns (ListDelegationsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get network data
    //
    // Get data regarding the nodes of the network
    rpc GetNetworkData(GetNetworkDataRequest) returns (GetNetworkDataResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get node
    //
    // Get information about a given node
    rpc GetNode(GetNodeRequest) returns (GetNodeResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List nodes
    //
    // List information about the nodes on the network
    rpc ListNodes(ListNodesRequest) returns (ListNodesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List node signatures
    //
    // List an aggregate of signatures from all the nodes of the network
    rpc ListNodeSignatures(ListNodeSignaturesRequest) returns (ListNodeSignaturesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "ERC20 bridge";
      };
    }

    // Get epoch
    //
    // Get data for a specific epoch, if ID is omitted, it retrieves the current epoch
    rpc GetEpoch(GetEpochRequest) returns (GetEpochResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Estimate fee
    //
    // Estimate the fee that would be incurred for submitting an order
    // with the specified price and size on the market.
    rpc EstimateFee(EstimateFeeRequest) returns (EstimateFeeResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Orders";
      };
    }

    // Estimate margin
    //
    // Estimate the margin that would be required for submitting this order
    rpc EstimateMargin(EstimateMarginRequest) returns (EstimateMarginResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Orders";
      };
    }

    // List network parameters
    //
    // Get the network parameters
    rpc ListNetworkParameters(ListNetworkParametersRequest) returns (ListNetworkParametersResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get network parameter
    //
    // Get a single network parameter
    rpc GetNetworkParameter(GetNetworkParameterRequest) returns (GetNetworkParameterResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List checkpoints
    //
    // List information about checkpoint generated by the network
    rpc ListCheckpoints(ListCheckpointsRequest) returns (ListCheckpointsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get Stake
    //
    // Retrieve staking information for a given party
    rpc GetStake(GetStakeRequest) returns (GetStakeResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get risk factors
    //
    // Get risk factor data for a given market
    rpc GetRiskFactors(GetRiskFactorsRequest) returns (GetRiskFactorsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Markets";
      };
    }

    // Observe event bus
    //
    // Subscribe to a stream of events from the core
    rpc ObserveEventBus(stream ObserveEventBusRequest) returns (stream ObserveEventBusResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Events";
      };
    }

    // Observe ledger movements
    //
    // Subscribe to a stream of transfer responses
    rpc ObserveLedgerMovements(ObserveLedgerMovementsRequest) returns (stream ObserveLedgerMovementsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Ledger movements";
      };
    }

    // List key rotations
    //
    // Get information about Vega key rotations that have been performed by validator nodes
    rpc ListKeyRotations(ListKeyRotationsRequest) returns (ListKeyRotationsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List Ethereum key rotations
    //
    // Get information about Ethereum key rotations that have been performed by validator nodes
    rpc ListEthereumKeyRotations(ListEthereumKeyRotationsRequest) returns (ListEthereumKeyRotationsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get Vega time
    //
    // Get the current time of the network, displayed as a Unix timestamp in nano seconds
    rpc GetVegaTime(GetVegaTimeRequest) returns (GetVegaTimeResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Get protocol upgrade status
    //
    // Get status of a protocol upgrade
    rpc GetProtocolUpgradeStatus(GetProtocolUpgradeStatusRequest) returns (GetProtocolUpgradeStatusResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List protocol upgrade proposals
    //
    // List protocol upgrade proposals, optionally filtering on status or approver.
    rpc ListProtocolUpgradeProposals(ListProtocolUpgradeProposalsRequest) returns (ListProtocolUpgradeProposalsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // List snapshots
    //
    // List core snapshots taken
    rpc ListCoreSnapshots(ListCoreSnapshotsRequest) returns (ListCoreSnapshotsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network";
      };
    }

    // Network History
    //
    // Network history allows the data node to reach out to peer nodes and fetch the most recent history, as well as
    // older history if desired, such that it can quickly get itself up to the latest block height of the network and start
    // to consume events for the latest block from the Vega core.
    // See https://github.com/vegaprotocol/vega/tree/develop/datanode/networkhistory/README.md for a full description of network history

    // Get most recent network history segment
    //
    // Get the network's most recently history segment
    rpc GetMostRecentNetworkHistorySegment(GetMostRecentNetworkHistorySegmentRequest) returns (GetMostRecentNetworkHistorySegmentResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network history";
      };
    }

    // List all network history segments
    //
    // List all history segments stored by the data node you're connected to
    rpc ListAllNetworkHistorySegments(ListAllNetworkHistorySegmentsRequest) returns (ListAllNetworkHistorySegmentsResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network history";
      };
    }

    // Get active network history peer addresses
    //
    // List the addresses of all active network history peers
    rpc GetActiveNetworkHistoryPeerAddresses(GetActiveNetworkHistoryPeerAddressesRequest) returns (GetActiveNetworkHistoryPeerAddressesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network history";
      };
    }

    // Network history status
    //
    // Retrieves information about the current state of network history
    // Response contains the network history status
    rpc GetNetworkHistoryStatus(GetNetworkHistoryStatusRequest) returns (GetNetworkHistoryStatusResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network history";
      };
    }

    // Network history bootstrap peers
    //
    // Retrieves the bootstrap peers for data nodes.
    // Response contains the bootstrap peers
    rpc GetNetworkHistoryBootstrapPeers(GetNetworkHistoryBootstrapPeersRequest) returns (GetNetworkHistoryBootstrapPeersResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network history";
      };
    }

    // List entities
    //
    // List all entities created by transaction hash
    rpc ListEntities(ListEntitiesRequest) returns (ListEntitiesResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Explorer";
      };
    }

    // Export network history as CSV
    //
    // Extract CSV table data from network history between two block heights.
    //
    // The requested block heights must fall on network history segment boundaries, which can
    // be discovered by calling the API to list all network history segments. By default
    // segments contain 1000 blocks. In that case ranges such as (1, 1000), (1001, 2000), (1, 3000)
    // would all fall on segment boundaries and be valid.
    //
    // The generated CSV file is compressed into a ZIP file and returned, with the file name
    // in the following format: [chain id]-[table name]-[start block]-[end block].zip
    //
    // In gRPC, results are returned in a chunked stream of base64 encoded data.
    //
    // Through the REST gateway, the base64 data chunks are decoded and streamed as a
    // `content-type: application/zip` HTTP response.
    //
    // The CSV exported data uses a comma as a DELIMITER between fields, and " for QUOTE-ing fields.
    //
    // If a value contains any of: DELIMITER, QUOTE, carriage return, or line feed then the whole
    // value is prefixed and suffixed by the QUOTE character and any occurrence within
    // the value of a QUOTE character preceded by another QUOTE.
    //
    // A NULL is output as the NULL parameter string and is not quoted, while a non-NULL value
    // matching the NULL parameter string is quoted.
    //
    // For example, with the default settings, a NULL is written as an unquoted empty string,
    // while an empty string data value is written with double quotes ("").
    //
    // Note that CSV files produced may contain quoted values containing embedded carriage returns and line feeds.
    // Thus the files are not strictly one line per table row like text-format files.
    //
    // The first row of the CSV file is a header that allows you to identify the columns
    // of subsequent rows.
    //
    // Usually the ZIP file will contain only a single CSV file. However it is possible that
    // the (from_block, to_block) request spans over a range of blocks in which the underlying
    // schema of the database changes. For example, a column may have been added, removed, or renamed.
    //
    // If this happens, the CSV file will be split at the point of the schema change and the zip
    // file will contain multiple CSV files, with a potentially different set of headers. The
    // 'version' number of the database schema is part of the in the CSV filename:
    //
    //  [chain id]-[table name]-[schema version]-[start block]-[end block].zip
    //
    // For example, a zip file might be called mainnet-sometable-000001-003000.zip
    //
    // And contain two CSV files: mainnet-sometable-1-000001-002000.csv:
    //
    // timestamp, value
    // 1, foo
    // 2, bar
    //
    // And mainnet-sometable-2-002001-003000.csv:
    //
    // timestamp, value, extra_value
    // 3, baz, apple
    //
    // It is worth noting that the schema will not change within a single network history segment.
    // buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
    rpc ExportNetworkHistory(ExportNetworkHistoryRequest) returns (stream google.api.HttpBody) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Network history";
      };
    }

    // Ping
    //
    // Ping the data node
    rpc Ping(PingRequest) returns (PingResponse) {
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
	tags: "Misc";
      };
    }

}

// -- Pagination --

// Cursor information for cursor based pagination requests
message Pagination {
    optional int32 first = 1;
    optional string after = 2;
    optional int32 last = 3;
    optional string before = 4;
    // Newest records first, older records last, default is true.
    optional bool newest_first = 5;
}

// Page information for cursor based pagination
message PageInfo {
    // Indicator if there is a next page.
    bool has_next_page = 1;
    // Indicator if there is a previous page.
    bool has_previous_page = 2;
    // Start cursor.
    string start_cursor = 3;
    // End cursor.
    string end_cursor = 4;
}

// -- Accounts --

// Represents the current balance of an account for an asset on Vega, for a particular owner or party
message AccountBalance {
    // Unique account identifier (used internally by Vega)
    // string id = 1;
    // The party that owns the account.
    // Special values include `network` - represents the Vega network and is
    // most commonly seen during liquidation of a distressed trading position.
    string owner = 2;
    // Asset balance represented as an integer, for example `123456` is a correctly
    // formatted price of `1.23456` assuming market configured to 5 decimal places.
    // Balances cannot be negative.
    string balance = 3;
    // Asset identifier for the account.
    string asset = 4;
    // Market identifier for the account, this field will be empty if the asset is in a general account.
    string market_id = 5;
    // The account type of this account.
    vega.AccountType type = 6;
}

// Request that is sent when listing accounts
message ListAccountsRequest {
    // AccountFilter contains all filter conditions and values that can be applied to the listing.
    AccountFilter filter = 1;
    // Optional pagination control.
    optional Pagination pagination = 2;
}

// Response that is received from listing accounts query
message ListAccountsResponse {
    // Page with accounts data for 0 or more accounts.
    AccountsConnection accounts = 1;
}

// Represents the list of accounts with the corresponding page information
message AccountsConnection {
    // The list of accounts and their cursors.
    repeated AccountEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Represents the account with corresponding cursor for it
message AccountEdge {
    // The account balance data.
    AccountBalance node = 1;
    // A cursor which can be used to fetch further pages with reference to this account.
    string cursor = 2;
}

// Request that is sent when getting a subscription to a stream of accounts
message ObserveAccountsRequest {
    // Market identifier.
    string market_id = 1;
    // Party identifier.
    string party_id = 2;
    // Asset identifier.
    string asset = 3;
    // Account type to subscribe to, required field.
    vega.AccountType type = 4;
}

// The response that is received when subscribing to a stream of accounts
message ObserveAccountsResponse {
    oneof response {
        // An 'initial image' snapshot containing current account balances.
        AccountSnapshotPage snapshot = 1;
        // A list of account updates in the last block.
        AccountUpdates updates = 2;
    }
}

// An 'initial image' snapshot containing current account balances - may be sent over several response messages
message AccountSnapshotPage{
    // List of account balances.
    repeated AccountBalance accounts = 1;
    // Indicator if the current page is the last one or not.
    bool last_page = 2;
}

// A list of account updates in the last block
message AccountUpdates{
    // List of account balances.
    repeated AccountBalance accounts = 1;
}

// -- Data node info --

// Request that is sent when querying node info
message InfoRequest {}

// Response that is received from the node info query
message InfoResponse {
    // A semver formatted version of the data node.
    string version = 1;
    // The commit hash from which the data node was built.
    string commit_hash = 2;
}

// -- Orders --

// A request that is sent when executing the query for getting a single order
message GetOrderRequest {
  // Order identifier.
  string order_id = 1 [(google.api.field_behavior) = REQUIRED];

  // Optional version of the order.
  optional int32 version = 2;
}

// The response received from the query for getting a single order
message GetOrderResponse {
    // The order, if one was found.
    vega.Order order = 1;
}

// Order filter that contains all filtering conditions and values that are applied to the orders listing
message OrderFilter {
    // The list of order statuses the orders can be filtered by.
    repeated vega.Order.Status statuses = 1;
    // The list of order types the orders can be filtered by.
    repeated vega.Order.Type types = 2;
    // The list of timings the orders can be filtered by.
    repeated vega.Order.TimeInForce time_in_forces = 3;
    // Indicator if liquidity provision orders should be included or not in the list.
    bool exclude_liquidity = 4;
    // List of party IDs to filter on.
    repeated string party_ids = 5;
    // List of market IDs to filter on.
    repeated string market_ids = 6;
    // Reference.
    optional string reference = 7;
    // The date range of the orders being listed.
    optional DateRange date_range = 8;
    // Indicator for listing only live orders, if set to true.
    optional bool live_only = 9;
}

// A request that is sent when executing a query for a list of orders
message ListOrdersRequest {
    // Optional pagination control.
    optional Pagination pagination = 2;
    // The order filter contains all filtering conditions and values that are applied to the orders listing.
    optional OrderFilter filter = 5;
}

// A response that is received from the query to list orders
message ListOrdersResponse {
    // Paged orders data with 0 or more orders.
    OrderConnection orders = 1;
}

// A request that is sent when listing possible order versions
message ListOrderVersionsRequest {
    // Order identifier as string.
    string order_id = 1 [(google.api.field_behavior) = REQUIRED];

    // Optional pagination control.
    optional Pagination pagination = 4;
}

// A response that is received when listing possible order versions
message ListOrderVersionsResponse {
    // Paged orders data with 0 or more order versions.
    OrderConnection orders = 1;
}

// Request to subscribe to a stream of orders
//
// The fields for market identifier and party identifier are optional filters:
// If omitted all orders, for all parties on all markets will be returned on the stream
// If a market identifier is provided, the orders from that market will be returned on the stream
// If a party identifier is provided, the orders from that party will be returned on the stream
// Both filters can be combined
message ObserveOrdersRequest {
    // Market identifier.
    repeated string market_ids = 1;
    // Party identifier.
    repeated string party_ids = 2;
    // Exclude liquidity.
    optional bool exclude_liquidity = 3;
}

// The response that is received from an orders subscription
message ObserveOrdersResponse {
    oneof response {
        // An 'initial image' snapshot containing current live orders.
        OrderSnapshotPage snapshot = 1;
        // A list of order updates in the last block.
        OrderUpdates updates = 2;
    }
}

// 'Initial image' of live orders, may be sent over multiple response messages
message OrderSnapshotPage{
    // List of order data parts.
    repeated vega.Order orders = 1;
    // Indicator if the last page is reached or not.
    bool last_page = 2;
}

// List of order updates in the last block
message OrderUpdates{
    // List of orders data.
    repeated vega.Order orders = 1;
}

// -- Positions --

// Request used to list all positions for a party
// Optionally, if a market identifier is set, the results will be filtered for that market only
message ListPositionsRequest {
    option deprecated = true;
    // Party identifier, required field.
    string party_id = 1;
    // Market identifier.
    string market_id = 2;
    // Optional pagination control.
    optional Pagination pagination = 3;
}

// Response for a list of positions for a party
message ListPositionsResponse {
    option deprecated = true;
    // A list of 0 or more positions.
    PositionConnection positions = 1;
}

// Filter to apply to the ListAllPositionsRequest
message PositionsFilter {
    // List of party IDs to filter on.
    repeated string party_ids = 1;
    // List of market IDs to filter on.
    repeated string market_ids = 2;
}

// Request to list positions, given the position filter is supplied.
message ListAllPositionsRequest {
    // Filter to apply to the positions.
    PositionsFilter filter = 1;
    // Optional pagination control.
    optional Pagination pagination = 2;
}

// Response to query for listing of positions, given the filter is supplied
message ListAllPositionsResponse {
    // A list of 0 or more positions.
    PositionConnection positions = 1;
}

// Represents the position data with corresponding cursor for it
message PositionEdge {
    // Represents position data for a party on the specified market on Vega.
    vega.Position node = 1;
    // A cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of positions with the corresponding page information
message PositionConnection {
    // List of positions data.
    repeated PositionEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request that is used to subscribe to a stream of positions
message ObservePositionsRequest {
    // Optional party ID.
    optional string party_id = 1;
    // Optional market ID.
    optional string market_id = 2;
}

// A response that is received from a positions subscription request
message ObservePositionsResponse {
    oneof response {
        // An 'initial image' snapshot containing current positions.
        PositionSnapshotPage snapshot = 1;
        // A list of position updates in the last block.
        PositionUpdates updates = 2;
    }
}

// 'Initial image' of current positions, may be sent over multiple response messages
message PositionSnapshotPage{
    // List of positions data.
    repeated vega.Position positions = 1;
    // Indicator if last page is reached or not.
    bool last_page = 2;
}

// A list of position updates in the last block
message PositionUpdates{
    // List of positions data.
    repeated vega.Position positions = 1;
}

// Ledger entry filter sets filters on returned set of ledger entries.
// Ledger entry data can be filtered by asset ID, market ID, party ID for sending and receiving account, as well as by transfer type.
message LedgerEntryFilter {
    // close_on_account_filters determines whether an entry must have accounts matching both the account_from_filter
    // and the account_to_filter. If set to 'true', entries must have matches in both filters.
    // If set to `false`, entries matching only the account_from_filter or the account_to_filter will also be included.
    bool close_on_account_filters = 1;
    // `AccountFilter` object used to set values for filtering sender accounts.
    AccountFilter from_account_filter = 2;
    // `AccountFilter` object used to set values for filtering receiver accounts.
    AccountFilter to_account_filter = 3;
    // A list of transfer types that is used for filtering sender and receiver accounts.
    repeated vega.TransferType transfer_types = 5;
}

// A list of fields for a ledger entry
enum LedgerEntryField {
    LEDGER_ENTRY_FIELD_UNSPECIFIED = 0;
    LEDGER_ENTRY_FIELD_ACCOUNT_FROM_ID = 1;
    LEDGER_ENTRY_FIELD_ACCOUNT_TO_ID = 2;
    LEDGER_ENTRY_FIELD_TRANSFER_TYPE = 3;
}

// Represents an aggregated view of ledger entry data, sender and receiver accounts,
// details and balances for both sides after the transfer has been made
message AggregatedLedgerEntry {
    // Removed ID field as it is not used, there is no ID for an aggregated ledger entry
    reserved 1;
    // Timestamp to of block the result is referring to, in nanoseconds.
    int64 timestamp = 2;
    // The amount of ledger entries for the set of requested accounts at the time above.
    string quantity = 3;
    // The transfer type.
    vega.TransferType transfer_type = 4;
    // The asset ID.
    optional string asset_id = 5;
    // The type of account sent from.
    vega.AccountType from_account_type = 6;
    // The type of account received to.
    vega.AccountType to_account_type = 7;
    // The sender's party ID.
    optional string from_account_party_id = 8;
    // The receiver's party ID.
    optional string to_account_party_id = 9;
    // The sender market ID.
    optional string from_account_market_id = 10;
    // The receiver market ID.
    optional string to_account_market_id = 11;
    // Sender account balance after the transfer.
    string from_account_balance = 12;
    // Receiver account balance after the transfer.
    string to_account_balance = 13;
}

// -- LedgerEntries --

// A request that is sent when listing ledger entries
message ListLedgerEntriesRequest {
    // 'LedgerEntryFilter' that contains all values and conditions according to which
    // the listing of ledger entries is filtered.
    LedgerEntryFilter filter = 1;
    // Optional pagination control.
    optional Pagination pagination = 2;
    // Date range for which to list ledger entries.
    optional DateRange date_range = 3;
}

// A request that is sent when exporting ledger entries to csv
message ExportLedgerEntriesRequest {
    // Party ID to export ledger entries for.
    string party_id = 1 [(google.api.field_behavior) = REQUIRED];
    // Asset ID to export ledger entries for.
    string asset_id = 2;
    // Optional pagination control.
    optional Pagination pagination = 3;
    // Date range to export ledger entries for.
    optional DateRange date_range = 4;
}

// A response that is received when listing ledger entries
message ListLedgerEntriesResponse {
    // Represents the list of aggregated ledger entries data with the corresponding page information.
    AggregatedLedgerEntriesConnection ledger_entries = 1;
}

// A response that is received when exporting ledger entries
message ExportLedgerEntriesResponse {
    // Exported ledger entries data as byte stream.
    bytes data = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Represents the aggregated ledger entry data with corresponding cursor for it
message AggregatedLedgerEntriesEdge {
    // 'AggregatedLedgerEntry' data.
    AggregatedLedgerEntry node = 1;
    // A cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of aggregated ledger entries data with the corresponding page information
message AggregatedLedgerEntriesConnection {
    // List of 'AggregatedLedgerEntry' data.
    repeated AggregatedLedgerEntriesEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// A request that is received when querying balances changes
message ListBalanceChangesRequest{
    // Limit the accounts considered according to the filter supplied.
    AccountFilter filter = 1;
    // Pagination controls.
    optional Pagination pagination = 5;
    // Date range over which to query.
    optional DateRange date_range = 6;
}

// A response that is received when querying balances changes
message ListBalanceChangesResponse {
    // The list of aggregated balances with the corresponding page information.
    AggregatedBalanceConnection balances = 1;
}


// -- Balances --

// A request that is used when querying balance history
message GetBalanceHistoryRequest {
    // AccountFilter contains values that can be set in order to limit balance history data to them.
    AccountFilter filter = 1;
    // By default the net balances of all the accounts specified by the filter are returned.
    // If a list of fields is given in group_by, split out those balances by the supplied criteria.
    repeated AccountField group_by = 2;
    optional Pagination pagination = 3;
    optional DateRange date_range = 4;
}

// A response that is received when querying for balance history
message GetBalanceHistoryResponse {
    // The list of aggregated balances with the corresponding page information.
    AggregatedBalanceConnection balances = 1;
}

// Represents the AggregatedBalanceEdge data with corresponding cursor for it
message AggregatedBalanceEdge {
    // AggregatedBalance data.
    AggregatedBalance node = 1;
     // A cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of aggregated balance objects with the corresponding page information
message AggregatedBalanceConnection {
    // List of aggregated balance data chunks.
    repeated AggregatedBalanceEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// The filter that is used to filter account data by asset ID, party ID, market ID and account type
message AccountFilter{
    // Restrict accounts to those holding balances in this asset ID.
    string asset_id = 1;
    // Restrict accounts to those owned by the parties in this list (pass an empty list for no filter).
    repeated string party_ids = 2;
    // Restrict accounts to those connected to the markets in this list (pass an empty list for no filter).
    repeated string market_ids = 3;
    // Restrict accounts to those connected to any of the types in this list (pass an empty list for no filter).
    repeated vega.AccountType account_types = 4;
}

// A list of the properties of an account, used for grouping
enum AccountField {
    ACCOUNT_FIELD_UNSPECIFIED = 0;
    ACCOUNT_FIELD_ID = 1;
    ACCOUNT_FIELD_PARTY_ID = 2;
    ACCOUNT_FIELD_ASSET_ID = 3;
    ACCOUNT_FIELD_MARKET_ID = 4;
    ACCOUNT_FIELD_TYPE = 5;
}

// AggregatedBalance data contains the balance of the set of requested accounts combined with corresponding
// party ID, market ID and account type details
message AggregatedBalance {
    // Timestamp to of block the balance is referring to, in nanoseconds.
    int64 timestamp = 1;
    // The balance of the set of requested accounts at the time above.
    string balance = 2;
    // If grouping by party, the party ID.
    optional string party_id = 4;
    // If grouping by asset, the asset ID.
    optional string asset_id = 5;
    // If grouping by market, the market ID
    optional string market_id = 6;
    // If grouping by account type, the account type.
    optional vega.AccountType account_type = 7;
}

// -- Market Data --

// Request that is sent to get market depth subscription
message ObserveMarketsDepthRequest {
    // List of market IDs to be obtained in the subscription.
    repeated string market_ids = 1;
}

// Response that is received for MarketDepth subscription.
message ObserveMarketsDepthResponse {
    // List of market depth data.
    repeated vega.MarketDepth market_depth = 1;
}

// Request that is sent for market depth update subscription
message ObserveMarketsDepthUpdatesRequest {
    // List of market IDs to be obtained in the subscription.
    repeated string market_ids = 1;
}

// Response that is received for market depth update subscription
message ObserveMarketsDepthUpdatesResponse {
    // List of market depth update data.
    repeated vega.MarketDepthUpdate update = 1;
}

// Request that is sent for market data subscription
message ObserveMarketsDataRequest {
    // List of market IDs to be obtained in the subscription.
    repeated string market_ids = 1;
}

// Response that is received for market data subscription
message ObserveMarketsDataResponse {
    // List of market data.
    repeated vega.MarketData market_data = 1;
}

// Request that is sent when requesting latest market depth data
message GetLatestMarketDepthRequest {
    // Market identifier, required field.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];

    // An optional field to indicate the maximum market depth.
    optional uint64 max_depth = 2;
}

// Response that is received when latest market depth data is queried
message GetLatestMarketDepthResponse {
    // Market identifier.
    string market_id = 1;
    // Zero or more price levels for the buy side of the market depth data.
    repeated vega.PriceLevel buy = 2;
    // Zero or more price levels for the sell side of the market depth data.
    repeated vega.PriceLevel sell = 3;
    // Last trade recorded on Vega at the time of retrieving the `MarketDepthResponse`.
    vega.Trade last_trade = 4;
    // Sequence number incremented after each update.
    uint64 sequence_number = 5;
}

// Request that is sent when listing the latest market data for every market
message ListLatestMarketDataRequest {
}

// Response that is received when listing the latest market data for every market
message ListLatestMarketDataResponse {
    repeated vega.MarketData markets_data = 1;
}

// Request that is sent when listing the latest market data for a given market
message GetLatestMarketDataRequest {
    // Market identifier, required field.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when listing the latest market data for a given market
message GetLatestMarketDataResponse {
    // Market identifier, required field.
    vega.MarketData market_data = 1;
}

// Request that is sent for getting Market Data History
message GetMarketDataHistoryByIDRequest {
  reserved 5;

  // Market identifier, required field.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Optional Unix time in nanoseconds.
  optional int64 start_timestamp = 2;
  // Optional Unix time in nanoseconds.
  optional int64 end_timestamp = 3;
  // Optional pagination control.
  optional Pagination pagination = 4;
}

// Response that is received when querying Market Data History
message GetMarketDataHistoryByIDResponse {
    // The list of market data history with the corresponding page information.
    MarketDataConnection market_data = 1;
}

// Represents the market data with corresponding cursor for it
message MarketDataEdge {
    // 'MarketData'.
    vega.MarketData node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of market data objects with the corresponding page information
message MarketDataConnection {
    // List of market data chunks.
    repeated MarketDataEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Transfers --

// The direction of a transfer
enum TransferDirection {
    TRANSFER_DIRECTION_UNSPECIFIED = 0;
    TRANSFER_DIRECTION_TRANSFER_FROM = 1;
    TRANSFER_DIRECTION_TRANSFER_TO = 2;
    TRANSFER_DIRECTION_TRANSFER_TO_OR_FROM = 3;
}

// Request that is sent to list transfers
message ListTransfersRequest {
    // Public key for which to request transfers.
    optional string pubkey = 1;
    // Transfer directions (sender, receiver) to include in the response data
    TransferDirection direction = 2;
    // Optional pagination control
    optional Pagination pagination = 3;
}

// Response that is received when listing  transfers
message ListTransfersResponse {
    TransferConnection transfers = 1;
}

// Represents the transfers data with a corresponding cursor for it
message TransferEdge {
    // Transfer data.
    vega.events.v1.Transfer node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of transfers data objects with the corresponding page information
message TransferConnection {
    // List of transfers data chunks.
    repeated TransferEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Network Limits --

// Request that is used to query current network limits
message GetNetworkLimitsRequest {}

// Response received when querying the current network limits
message GetNetworkLimitsResponse {
    // List of received network limits.
    vega.NetworkLimits limits = 1;
}

// -- Candles --

// Request that is used to fetch a list of supported intervals for the given market along with the corresponding candle ID
message ListCandleIntervalsRequest {
    // The unique identifier for the market.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Maps an interval for a given market to its corresponding candle ID
message IntervalToCandleId {
    // The interval for the candle.
    string interval = 1;

    // The unique id of the candle.
    string candle_id=2;
}

// A list of mapped pairs `interval` -> `candle ID` for a given market
message ListCandleIntervalsResponse {
    // List of the mappings.
    repeated IntervalToCandleId interval_to_candle_id = 1;
}

// Represents the high, low, open, and closing prices for an interval of trading,
// referred to commonly as a candlestick or candle
message Candle {
    // Timestamp for the point in time when the candle was initially created/opened, in nanoseconds.
    int64 start = 1;
    // Timestamp for the point in time when the candle was last updated, in nanoseconds.
    int64 last_update = 2;
    // Highest price for trading during the candle interval.
    string high = 3;
    // Lowest price for trading during the candle interval.
    string low = 4;
    // Open trade price.
    string open = 5;
    // Closing trade price.
    string close = 6;
    // Total trading volume during the candle interval.
    uint64 volume = 7;
}

// Request that is used to subscribe to a stream of candles
message ObserveCandleDataRequest {
    // The unique identifier for the candle.
    string candle_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when subscribing to a stream of candles
message ObserveCandleDataResponse {
    // Candle data.
    Candle candle = 1;
}

// Request that is used when listing candles for a market at an interval
message ListCandleDataRequest {
    reserved 4;
    // Candle ID, required field.
    string candle_id = 1 [(google.api.field_behavior) = REQUIRED];
    // Timestamp to retrieve candles since, in nanoseconds since the epoch.
    int64 from_timestamp = 2;
    // Timestamp to retrieve candles to, in nanoseconds since the epoch.
    int64 to_timestamp = 3;
    // pagination controls
    optional Pagination pagination = 5;
}

// Response for list of candles for a market at an interval
message ListCandleDataResponse {
    // A list of 0 or more candles.
    CandleDataConnection candles = 1;
}

// Represents the candle data with the corresponding cursor for it
message CandleEdge {
    // List of candle data chunks.
    Candle node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of candles with the page information of the listing
message CandleDataConnection {
    // List of candle data.
    repeated CandleEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Votes --

// Request that is used to list governance votes
message ListVotesRequest {
  // Party for which the votes are requested.
  optional string party_id = 1;
  // A proposal ID to list votes for.
  optional string proposal_id = 2;

  // Optional pagination control.
  optional Pagination pagination = 3;
}

// Response that is received when listing Votes
message ListVotesResponse {
    // Votes data received.
    VoteConnection votes = 1;
}

// Votes data with the corresponding cursor for it
message VoteEdge {
    // Vote data.
    vega.Vote node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of Vote data chunks with the corresponding list page information
message VoteConnection {
    // List of Vote data.
    repeated VoteEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request that is sent to subscribe to votes
message ObserveVotesRequest {
    // Party ID for which the votes are requested.
    optional string party_id = 1;
    // Option proposal ID for which the votes are requested.
    optional string proposal_id = 2;
}

// Response that is received from votes subscription
message ObserveVotesResponse {
    // Vote data.
    vega.Vote vote = 1;
}

// Request for adding a signature bundle to the signer list of a multisig contract for a particular validator
message ListERC20MultiSigSignerAddedBundlesRequest {

    // The node ID of the validator for which a signature bundle is required.
    string node_id = 1;

    // The ethereum address of the validator which will submit the bundle.
    string submitter = 2;

    // The epoch which generated the bundle i.e the epoch in which the node was promoted to tendermint validator.
    string epoch_seq = 3;

    // Pagination controls.
    Pagination pagination = 4;
}

// Response from adding a signature bundle to the signer list of a multisig contract for a particular validator
message ListERC20MultiSigSignerAddedBundlesResponse {
    // List of bundles for that validator, it may have been added multiple times if removed in between.
    ERC20MultiSigSignerAddedConnection bundles = 1;
}

// Represents the signature data that is to be added with the corresponding cursor for it
message ERC20MultiSigSignerAddedEdge {
    // Signature data to be added.
    vega.events.v1.ERC20MultiSigSignerAdded node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the signature bundle data that is to be added the corresponding cursor for it
message ERC20MultiSigSignerAddedBundleEdge {
    // Signature bundle data to be added.
    ERC20MultiSigSignerAddedBundle node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of signature data chunks to be added with the corresponding list page information
message ERC20MultiSigSignerAddedConnection {
    // List of signature bundle data parts.
    repeated ERC20MultiSigSignerAddedBundleEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Signature bundle data to be added
message ERC20MultiSigSignerAddedBundle {

    // The ethereum address of the signer to be removed.
    string new_signer = 1;

    // The ethereum address of the submitter.
    string submitter = 2;

    // The nonce used in the signing operation.
    string nonce = 4;

    // unixnano timestamp for when the validator was added.
    int64 timestamp = 5;

    // The bundle of signatures from current validators to sign in the new signer.
    string signatures = 6;

    // The epoch in which the validator was added.
    string epoch_seq = 3;

}

// Request for removing a signature bundle from the signer list of the multisig contract for a particular validator
message ListERC20MultiSigSignerRemovedBundlesRequest {
    // The node ID of the validator of which a signature bundle is required.
    string node_id = 1;

    // The ethereum address of the validator which will submit the bundle.
    string submitter = 2;

    // The epoch which generated the bundle i.e the epoch in which the node was demoted from a tendermint validator.
    string epoch_seq = 3;

    // Pagination controls.
    Pagination pagination = 4;
}

// Response when removing a signature bundle from the signer list of the multisig contract for a particular validator
message ListERC20MultiSigSignerRemovedBundlesResponse {
    // List of signer bundle data parts for that validator.
    ERC20MultiSigSignerRemovedConnection bundles = 1;
}

// Represents the signature data to be removed with the corresponding cursor for it
message ERC20MultiSigSignerRemovedEdge {
    // Signature data to be removed.
    vega.events.v1.ERC20MultiSigSignerRemoved node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the signature bundle data to be removed, with the corresponding cursor for it
message ERC20MultiSigSignerRemovedBundleEdge {
    // Signature bundle data to be added.
    ERC20MultiSigSignerRemovedBundle node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Represents the list of signature data chunks to be removed, with the corresponding list page information
message ERC20MultiSigSignerRemovedConnection {
    // List of signature bundle data parts.
    repeated ERC20MultiSigSignerRemovedBundleEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Signature bundle data to be removed
message ERC20MultiSigSignerRemovedBundle {

    // The ethereum address of the signer to be removed.
    string old_signer = 1;

    // The ethereum address of the submitter.
    string submitter = 2;

    // The nonce used in the signing operation.
    string nonce = 4;

    // unixnano timestamp for when the validator was added.
    int64 timestamp = 5;

    // The bundle of signatures from current validators to sign in the new signer.
    string signatures = 6;

    // The epoch in which the validator was removed.
    string epoch_seq = 7;

}

// Request for listing the signature bundle to an ERC-20 token in the collateral bridge
message GetERC20ListAssetBundleRequest {
  // The ID of the asset requested.
  string asset_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from listing the signature bundle to an ERC-20 token in the collateral bridge
message GetERC20ListAssetBundleResponse {
  // The address of the asset on ethereum.
  string asset_source = 1;
  // The ID of the vega asset.
  string vega_asset_id = 2;
  // The nonce, which is actually the internal reference for the proposal.
  string nonce = 3;
   // The signatures bundle as hex encoded data, forward by 0x
  // e.g: 0x + sig1 + sig2 + ... + sixN.
  string signatures = 4;
}

// Request for the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge
message GetERC20SetAssetLimitsBundleRequest {
  // The ID of the proposal to update an asset.
  string proposal_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response for the signature bundle to update the token limits (maxLifetimeDeposit and withdrawThreshold) for a given ERC20 token (already allowlisted) in the collateral bridge
message GetERC20SetAssetLimitsBundleResponse {
  // The address of the asset on ethereum.
  string asset_source = 1;
  // The ID of the vega asset.
  string vega_asset_id = 2;
  // The nonce, which is actually the internal reference for the proposal.
  string nonce = 3;
  // The lifetime limit deposit for this asset.
  string lifetime_limit = 4;
  // The threshold withdraw for this asset.
  string threshold = 5;
  // The signatures bundle as hex encoded data, forward by 0x
  // e.g: 0x + sig1 + sig2 + ... + sixN.
  string signatures = 6;
}

// The request to get all information required to bundle the call to finalise the withdrawal on the erc20 bridge
message GetERC20WithdrawalApprovalRequest {
    // The ID of the withdrawal.
    string withdrawal_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// The response with all information required to bundle the call to finalise the withdrawal on the erc20 bridge
// function withdraw_asset(address asset_source, uint256 asset_id, uint256 amount, uint256 expiry, uint256 nonce, bytes memory signatures)
message GetERC20WithdrawalApprovalResponse {
  reserved 3;
  // The address of asset on ethereum.
  string asset_source = 1;
  // The amount to be withdrawn.
  string amount = 2;
  // The nonce, which is actually the internal reference for the withdrawal.
  string nonce = 4;
  // The signatures bundle as hex encoded data, forward by 0x
  // e.g: 0x + sig1 + sig2 + ... + sixN.
  string signatures = 5;
  // The ethereum address to withdraw the funds to, 0x prefixed.
  string target_address = 6;
  // The creation timestamps.
  int64 creation = 7;
}

// -- Trades --

// Request for the latest trade that occurred on Vega for a given market
message GetLastTradeRequest {
    // Market ID, required field.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response for the latest trade that occurred on Vega for a given market
message GetLastTradeResponse {
    // A trade, if one is found.
    vega.Trade trade = 1;
}

// Request to list trades
message ListTradesRequest {
    // Market ID for which to list trades for, if provided.
    optional string market_id = 1;
    // Order ID for which to list trades for, if provided.
    optional string order_id = 2;
    // Party ID for which to list trades for, if provided.
    optional string party_id = 3;
    // Pagination control.
    optional Pagination pagination = 4;
    // Date range for the listing, if provided.
    optional DateRange date_range = 5;
}

// Response from listing trades
message ListTradesResponse {
    // Listed trades.
    TradeConnection trades = 1;
}

// List of trades with the corresponding list page information
message TradeConnection {
    // List of trades data.
    repeated TradeEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// List of trades
message TradeEdge {
    // Trade data.
    vega.Trade node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Request to subscribe to a stream of trades
message ObserveTradesRequest {
    // The fields for market ID and party ID are optional filters:
    // If omitted all trades, for all parties on all markets will be returned on the stream
    // If market identifier is given, trades from that market will be returned on the stream
    // If party identifier is given, trades from that party will be returned on the stream
    // Both filters can be combined.

    // Market ID.
    optional string market_id = 1;
    // Party ID.
    optional string party_id = 2;
}

// A stream of trades
message ObserveTradesResponse {
    // A list of 0 or more trades.
    repeated vega.Trade trades = 1;
}

// -- Oracles --

// The request to get a specific oracle spec by its ID
message GetOracleSpecRequest {
    // The ID to get the oracle spec for.
    string oracle_spec_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// The response for a oracle spec
message GetOracleSpecResponse {
    // The external data spec matching the ID.
    vega.OracleSpec oracle_spec = 1 ;
}

// The request to get all active oracle specs
message ListOracleSpecsRequest {
    // Pagination controls.
    optional Pagination pagination = 2;
}

// The response to get all active oracle specs
message ListOracleSpecsResponse {
    // The list of active oracle specs.
    OracleSpecsConnection oracle_specs = 1;
}

// The request to get all seen oracle data
message ListOracleDataRequest {
    optional string oracle_spec_id = 1;
    // Pagination controls.
    optional Pagination pagination = 2;
}

// The response to get all seen oracle data
message ListOracleDataResponse {
    // The list of seen oracle data.
    OracleDataConnection oracle_data = 1;
}

// Oracle specs with cursor
message OracleSpecEdge {
    // List of oracle spec data.
    vega.OracleSpec node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Oracle specs with corresponding list page information
message OracleSpecsConnection {
    // Oracle specs.
    repeated OracleSpecEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Oracle data with corresponding cursor
message OracleDataEdge {
    // Oracle data.
    vega.OracleData node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Oracle data with page info
message OracleDataConnection {
    // List of oracle data parts.
    repeated OracleDataEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Markets --

// Request for getting a market by ID
message GetMarketRequest {
    // The market ID.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting a market by ID
message GetMarketResponse {
    // The market.
    vega.Market market = 1;
}

// Request for listing markets
message ListMarketsRequest {
    // Pagination control.
    optional Pagination pagination = 2;
    // Whether or not to include settled markets in the response; default to true if not specified.
    optional bool include_settled = 3;
}

// Response from listing markets
message ListMarketsResponse {
    // List of markets data.
    MarketConnection markets = 1;
}

// Market data with corresponding cursor
message MarketEdge {
    // Market data.
    vega.Market node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Market data list with corresponding list page information
message MarketConnection {
    // List of markets data.
    repeated MarketEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Parties --

// Request to get party by ID
message GetPartyRequest {
    // The party ID.
    string party_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting party by ID
message GetPartyResponse {
    // The party data.
    vega.Party party = 1;
}

// Request to list parties by ID
message ListPartiesRequest {
    // Party ID.
    string party_id = 1;
    // Pagination control.
    Pagination pagination = 2;
}

// Response from listing parties
message ListPartiesResponse {
    // Parties data.
    PartyConnection parties = 1;
}

// Party data with corresponding cursors
message PartyEdge {
    // Party data.
    vega.Party node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of parties data with page info
message PartyConnection {
    // List of parties data.
    repeated PartyEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Order data with corresponding cursor
message OrderEdge {
    // Order data.
    vega.Order node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Request for listing margin levels
message ListMarginLevelsRequest {
    // Party ID for which to list the margin levels
    string party_id = 1;
    // Market ID for which to list the margin levels
    string market_id = 2;
    // Pagination control
    Pagination pagination = 3;
}

// Response from listing margin levels
message ListMarginLevelsResponse {
    // Margin levels data.
    MarginConnection margin_levels = 1;
}

// Request to subscribe to a stream of MarginLevels data.
// If a party ID is provided, the stream will contain margin levels for that party only.
// Optionally, the list can be additionally filtered by market
message ObserveMarginLevelsRequest {
    // Party identifier, required field.
    string party_id = 1;
    // Market identifier.
    optional string market_id = 2;
}

// Response from subscribing to margin levels data
message ObserveMarginLevelsResponse {
    vega.MarginLevels margin_levels = 1;
}

// List of orders data with corresponding page information
message OrderConnection {
    // Orders data list.
    repeated OrderEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Margin data with corresponding cursors
message MarginEdge {
    // Margin levels data.
    vega.MarginLevels node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of margins data with corresponding page information
message MarginConnection {
    // List of margins.
    repeated MarginEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// A request to get reward details for a party
message ListRewardsRequest {
    // Party ID for which to get the list of rewards.
    string party_id = 1;
    // Asset ID for which to get the list of rewards, if provided.
    optional string asset_id = 2;
    // Pagination control.
    optional Pagination pagination = 3;
    // Epoch from which to list the rewards, if provided.
    optional uint64 from_epoch = 4;
    // Epoch up-to-which to list the rewards, if provided.
    optional uint64 to_epoch = 5;
}

// The response for listing reward details for a single party
message ListRewardsResponse {
    // Rewards data.
    RewardsConnection rewards = 1;
}

// Rewards data with corresponding cursor
message RewardEdge {
    // Rewards data.
    vega.Reward node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Paged rewards data with corresponding page information
message RewardsConnection {
    // List of rewards data parts.
    repeated RewardEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// A request to get reward details for a party
message ListRewardSummariesRequest {
    // Party ID for which to list rewards, if provided.
    optional string party_id = 1;
    // Asset ID for which to list rewards, if provided.
    optional string asset_id = 2;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 3;
}

// The response from listing reward details in for a single party
message ListRewardSummariesResponse {
    // Rewards details data.
    repeated vega.RewardSummary summaries = 1;
}

// A filter to restrict the results returned by the ListEpochRewardSummaries
message RewardSummaryFilter {
    // Restrict the results to those connected to the assets in this list (pass an empty list for no filter).
    repeated string asset_ids = 1;
    // Restrict the results to those connected to the markets in this list (pass an empty list for no filter).
    repeated string market_ids = 2;
    // Optional range of epochs to filter on.
    optional uint64 from_epoch = 3;
    // Epoch to which to filter rewards summaries.
    optional uint64 to_epoch = 4;
}

// A request to get summary of reward per epoch for a given range of epochs
message ListEpochRewardSummariesRequest {
    // Limit the results considered according to the filter supplied.
    RewardSummaryFilter filter = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 4;
}

// The return message with reward details in for a single party
message ListEpochRewardSummariesResponse {
    EpochRewardSummaryConnection summaries = 1;
}

// Paged rewards summary data for epoch with corresponding page information
message EpochRewardSummaryConnection {
    // Rewards summary data parts for epochs.
    repeated EpochRewardSummaryEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Rewards summary data for epoch with corresponding cursors
message EpochRewardSummaryEdge {
    // Rewards summary data for epoch.
    vega.EpochRewardSummary node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Request sent for subscribing to rewards
message ObserveRewardsRequest {
    // Asset ID to get rewards data for, if provided.
    optional string asset_id = 1;
    // Party ID to get rewards data for, if provided.
    optional string party_id = 2;
}

// Response that is received from subscribing to rewards data
message ObserveRewardsResponse {
    // Rewards data received.
    vega.Reward reward = 1;
}

// -- Deposits --

// A request to get data about a specific deposit by ID
message GetDepositRequest {
    // The deposit ID, which can be obtained using the List Deposits query.
    string id = 1 [(google.api.field_behavior) = REQUIRED];
}

// A response that is received from getting deposit data
message GetDepositResponse {
    // The deposit matching the ID from the request.
    vega.Deposit deposit = 1 ;
}

// A request to list all deposits for a given party
message ListDepositsRequest {
    // The ID of the party whose deposits are to be retrieved.
    // If not provided, deposits for all parties will be provided.
    string party_id = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
    // Date range of the requested data, if provided.
    optional DateRange date_range = 3;
}

// Response from listing deposits
message ListDepositsResponse {
    // Deposits data.
    DepositsConnection deposits = 1;
}

// Deposits data with corresponding cursor
message DepositEdge {
    // Deposit data.
    vega.Deposit node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Paged deposits data received with the corresponding page information
message DepositsConnection {
    // Deposits data parts.
    repeated DepositEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Withdrawals --

// A request to get a specific withdrawal by identifier
message GetWithdrawalRequest {
    // The ID of the withdrawal to get.
    string id = 1 [(google.api.field_behavior) = REQUIRED];
}

// A response for a withdrawal request
message GetWithdrawalResponse {
    // The withdrawal matching the identifier from the request.
    vega.Withdrawal withdrawal = 1;
}

// List all withdrawals for a given party
message ListWithdrawalsRequest {
    // The party ID whose withdrawals we want to retrieve.
    // If not provided, withdrawals for all parties will be returned.
    string party_id = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
     // Date range of the requested data, if provided.
    optional DateRange date_range = 3;
}

// Response from listing withdrawals data
message ListWithdrawalsResponse {
    // List of withdrawals data parts.
    WithdrawalsConnection withdrawals = 1;
}

// Withdrawals data with corresponding cursor
message WithdrawalEdge {
    // Withdrawals data.
    vega.Withdrawal node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of withdrawals data with corresponding page information
message WithdrawalsConnection {
    // List of withdrawals data parts.
    repeated WithdrawalEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Assets --

// Request for obtaining asset
message GetAssetRequest {
    // Asset ID to get data for.
    string asset_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting an asset
message GetAssetResponse {
    // Asset information that is returned.
    vega.Asset asset = 1;
}

// Request for listing assets data
message ListAssetsRequest {
    // Optional asset ID to list data for.
    optional string asset_id = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
}

// Response from listing assets
message ListAssetsResponse {
    // Assets data with page information.
    AssetsConnection assets = 1;
}

// Assets data with corresponding cursor data
message AssetEdge {
    // The asset data returned.
    vega.Asset node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Paged list of asset data with corresponding page information
message AssetsConnection {
    // List of assets data chunks.
    repeated AssetEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Liquidity Provisions --

// Request for listing liquidity provisions
message ListLiquidityProvisionsRequest {
    // The target market for the liquidity provision orders.
    optional string market_id = 1;
    // The party which submitted the liquidity provision orders.
    optional string party_id = 2;
    // The reference of the liquidity provision.
    optional string reference = 3;
    // The indicator if the listed liquidity provision orders will include live orders or not.
    optional bool live = 4;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 5;
}

// Response from listing liquidity provisions
message ListLiquidityProvisionsResponse {
    // List liquidity provisions data with corresponding page information.
    LiquidityProvisionsConnection liquidity_provisions = 1;
}

// Paged liquidity provision data with corresponding cursor
message LiquidityProvisionsEdge {
    // Liquidity provision data.
    vega.LiquidityProvision node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of liquidity provisions data chunks with corresponding page information
message LiquidityProvisionsConnection {
    repeated LiquidityProvisionsEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request sent to subscribe to liquidity provisions
message ObserveLiquidityProvisionsRequest {
    // The target market to observe for liquidity provision orders.
    optional string market_id = 1;
    // The target party to observe for submitted liquidity provision orders.
    optional string party_id = 2;
}

// Response from liquidity provisions subscription
message ObserveLiquidityProvisionsResponse {
    repeated vega.LiquidityProvision liquidity_provisions = 1;
}

// -- Governance Data --

// Request to get governance data
message GetGovernanceDataRequest {
    // Proposal ID to get governance data for, if provided.
    optional string proposal_id = 1;
    // Reference to get proposal data for, if provided.
    optional string reference = 2;
}

// Response from getting governance data
message GetGovernanceDataResponse {
    // Governance data content.
    vega.GovernanceData data = 1;
}

// Request to list governance data
message ListGovernanceDataRequest {
    // Filter for the type(s) of governance proposals to view
    enum Type {
        TYPE_UNSPECIFIED = 0;
        // List all proposals
        TYPE_ALL = 1;
        // List new market proposals
        TYPE_NEW_MARKET = 2;
        // List update market proposals
        TYPE_UPDATE_MARKET = 3;
        // List change Vega network parameter proposals
        TYPE_NETWORK_PARAMETERS = 4;
        // New asset proposals
        TYPE_NEW_ASSET = 5;
        // Proposals for creating a new free form proposal
        TYPE_NEW_FREE_FORM = 6;
        // Update asset proposals
        TYPE_UPDATE_ASSET = 7;
    }
    // Proposal state to list governance data for, if provided.
    optional vega.Proposal.State proposal_state = 1;
    // Proposal type to list governance data for, if provided.
    optional Type proposal_type = 2;
    // Proposer party ID to list governance data for, if provided.
    optional string proposer_party_id = 3;
    // Proposal reference to list governance data for, if provided.
    optional string proposal_reference = 4;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 5;
}

// Response from listing governance data
message ListGovernanceDataResponse {
    // Paged governance data with corresponding page information.
    GovernanceDataConnection connection = 1;
}

// Governance data with corresponding cursor
message GovernanceDataEdge {
    // Governance data content.
    vega.GovernanceData node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Paged list of governance data with corresponding page information
message GovernanceDataConnection {
    // List of governance data parts with corresponding cursors.
    repeated GovernanceDataEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request for governance subscription
message ObserveGovernanceRequest {
    // Party ID to get the governance subscription for, if provided.
    optional string party_id = 1;
}

// Response from governance subscription
message ObserveGovernanceResponse {
    // Governance data.
    vega.GovernanceData data = 1;
}

// Request for listing delegations
message ListDelegationsRequest {
    // Party ID to list delegations for, if provided.
    optional string party_id = 1;
    // Node ID to list delegations for, if provided.
    optional string node_id = 2;
    // Epoch ID to list delegations for, if provided.
    optional string epoch_id = 3;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 4;
}

// Response from listing delegations
message ListDelegationsResponse {
    // Delegations data with corresponding page information.
    DelegationsConnection delegations = 1;
}

// Delegation data with corresponding cursors
message DelegationEdge {
    // Delegation data.
    vega.Delegation node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of delegations data with corresponding page information
message DelegationsConnection {
    // List of delegations data.
    repeated DelegationEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request to subscribe to all event related to delegations, with the given filters
message ObserveDelegationsRequest {
    // Party ID to get delegations for, if provided.
    optional string party_id = 1;
    // Node ID to get delegations for, if provided.
    optional string node_id = 2;
}

// Response with all events related to delegations, with the given filters
message ObserveDelegationsResponse {
    // Delegation data.
    vega.Delegation delegation = 1;
}

// -- Nodes --

// Represents a basic node without any epoch specific details like delegations, staking, rewards etc.
message NodeBasic {
    // The node ID.
    string id = 1;
    // Node operator's public key.
    string pub_key = 2;
    // Tendermint public key of the node.
    string tm_pub_key = 3;
    // Ethereum public key of the node.
    string ethereum_address = 4;
    // URL that provides more information about the node.
    string info_url = 5;
    // Country code for the location of the node.
    string location = 6;
    // Node status.
    vega.NodeStatus status = 13;
    // Node name.
    string name = 17;
    // Avatar URL.
    string avatar_url = 18;
}

// Request to get network data
message GetNetworkDataRequest {}

// Response from getting network data
message GetNetworkDataResponse {
    // Node data.
    vega.NodeData node_data = 1;
}

// Request to get node data
message GetNodeRequest {
    // Node ID to get data for.
    string id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from getting node
message GetNodeResponse {
    // Node data.
    vega.Node node = 1;
}

// Request to list nodes
message ListNodesRequest {
    // Epoch number to list nodes for, if provided.
    optional uint64 epoch_seq = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
}

// Response from listing nodes
message ListNodesResponse {
    // Node data with corresponding page information.
    NodesConnection nodes = 1;
}

// Node data with corresponding cursor
message NodeEdge {
    // Node data.
    vega.Node node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Paged list of nodes data with corresponding page information
message NodesConnection {
    // List of nodes data.
    repeated NodeEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request to specify the identifier of the resource to retrieve aggregated signatures for
message ListNodeSignaturesRequest {
    // Resource ID, required field.
    string id = 1 [(google.api.field_behavior) = REQUIRED];
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
}

// Response to specify the identifier of the resource to retrieve aggregated signatures for
message ListNodeSignaturesResponse {
    // List of nodes signatures with corresponding page information.
    NodeSignaturesConnection signatures = 1;
}

// Nodes signature edge with corresponding cursor
message NodeSignatureEdge {
    // Node signature data.
    vega.commands.v1.NodeSignature node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of nodes signatures with corresponding page info
message NodeSignaturesConnection {
    // A list of 0 or more signatures.
    repeated NodeSignatureEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Epochs --

// Request to fetch epoch data
message GetEpochRequest {
    // Epoch ID to get, if provided.
   optional uint64 id = 1;
}

// Response from getting epoch
message GetEpochResponse {
    vega.Epoch epoch = 1;
}

// -- Estimates --

// Request to fetch the estimated fee if an order were to trade immediately
message EstimateFeeRequest {
  // Market ID, used to specify the fee factors.
  string market_id = 1 [(google.api.field_behavior) = REQUIRED];
  // Price at which the potential order is expected to trade.
  string price = 2 [(google.api.field_behavior) = REQUIRED];
  // Size at which the potential order is expected to trade.
  uint64 size = 3 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received from EstimateFeeRequest, contains the estimated fees for a given order
message EstimateFeeResponse {
    // Summary of the estimated fees for this order if it were to trade now.
    vega.Fee fee = 2;
}

// Request to fetch the estimated MarginLevels if an order were to trade immediately
message EstimateMarginRequest {
    // Market ID for the order.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];
    // Party ID of the order.
    string party_id = 2 [(google.api.field_behavior) = REQUIRED];
    // Order side - indicator for Seller or Buyer side.
    vega.Side side = 3 [(google.api.field_behavior) = REQUIRED];
    // Type of the order.
    vega.Order.Type type = 4 [(google.api.field_behavior) = REQUIRED];
    // Size of order.
    uint64 size = 5 [(google.api.field_behavior) = REQUIRED];
    // Price of the asset.
    string price = 6 [(google.api.field_behavior) = REQUIRED];
}

// Response to an estimate margin request, containing the estimated margin levels for a given order
message EstimateMarginResponse {
    // Summary of the estimated margins for this order if it were to trade now.
    vega.MarginLevels margin_levels = 2;
}

// A message requesting for the list of all network parameters
message ListNetworkParametersRequest {
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 1;
}

// A response containing all of the vega network parameters
message ListNetworkParametersResponse {
    // List of network parameters with corresponding page info.
    NetworkParameterConnection network_parameters = 1;
}

// A message requesting a single network parameter
message GetNetworkParameterRequest {
  // The key identifying the network parameter.
  string key = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received when getting a network parameter
message GetNetworkParameterResponse {
  // The network parameter key and value.
  vega.NetworkParameter network_parameter = 1;
}

// Network parameter with corresponding cursor
message NetworkParameterEdge {
    // Network parameter data.
    vega.NetworkParameter node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of network parameters with corresponding page information
message NetworkParameterConnection {
    // List of network parameters data.
    repeated NetworkParameterEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Checkpoints --

// The actual data regarding a checkpoint
message Checkpoint {
    // Hash of the checkpoint.
    string hash = 1;
    // Block hash at which the checkpoint is made.
    string block_hash = 2;
    // Block number at which the checkpoint is made.
    uint64 at_block = 3;
}

// Request to get all checkpoints. Currently no fields, probably will be expanded to allow filtering data
message ListCheckpointsRequest {
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 1;
}

// Response message containing all checkpoints requested
message ListCheckpointsResponse {
    // List of checkpoints data with corresponding page information.
    CheckpointsConnection checkpoints = 1;
}

// Checkpoint data with corresponding cursor
message CheckpointEdge {
    // Checkpoint data.
    Checkpoint node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// List of checkpoints data with corresponding page information
message CheckpointsConnection {
    repeated CheckpointEdge edges= 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request to get stake
message GetStakeRequest {
    // Party ID for which the stake information is requested.
    string party_id = 1 [(google.api.field_behavior) = REQUIRED];
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
}

// Response that is received from requesting stake information
message GetStakeResponse {
    // Current stake available info.
    string current_stake_available = 1;
    // Paged list of stake data with corresponding page information.
    StakesConnection stake_linkings = 2;
}

// Stake linking data with corresponding cursor
message StakeLinkingEdge {
    // A stake linking represent the intent from a party to deposit.
    vega.events.v1.StakeLinking node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Paged list of stake data with corresponding page info
message StakesConnection {
    // List of stake data.
    repeated StakeLinkingEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Request to get risk factor
message GetRiskFactorsRequest {
    // Market ID to get the risk factor for.
    string market_id = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response that is received from getting a risk factor
message GetRiskFactorsResponse {
    // A risk factor emitted by the risk model for a given market.
    vega.RiskFactor risk_factor = 1;
}

// -- EventBus --

// Request to subscribe to a stream of one or more event types from the Vega event bus
message ObserveEventBusRequest {
    // One or more types of event, required field.
    repeated vega.events.v1.BusEventType type = 1;
    // Market ID, optional field.
    string market_id = 2;
    // Party ID, optional field.
    string party_id = 3;
    // Batch size,
    // If not specified, any events received will be sent immediately. If the client is not ready
    // for the next data-set, data may be dropped a number of times, and eventually the stream is closed.
    // if specified, the first batch will be sent when ready. To receive the next set of events, the client
    // must write an `ObserveEventBatch` message on the stream to flush the buffer.
    // If no message is received in 5 seconds, the stream is closed.
    // Default: 0, send any and all events when they are available.
    int64 batch_size = 4;
}

// Response to a subscribed stream of events from the Vega event bus
message ObserveEventBusResponse {
    // List of events.
    repeated vega.events.v1.BusEvent events = 1;
}

// -- Transfer Responses --

// Request to subscribe to ledger movements
message ObserveLedgerMovementsRequest {}

// Response from ledger movements subscription
message ObserveLedgerMovementsResponse {
    // Ledger movements data with list of ledger entries and and post-transfer balances.
    vega.LedgerMovement ledger_movement = 1;
}

// -- Key rotations --

// Request to list all key rotations
message ListKeyRotationsRequest {
    // Node identifier to get key rotations for, if provided.
    optional string node_id = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
}

// Response message containing Vega key rotations
message ListKeyRotationsResponse {
    // Key rotations data with corresponding page information.
    KeyRotationConnection rotations = 1;
}

// Key rotation data with corresponding cursor
message KeyRotationEdge {
    // Key rotation data.
    vega.events.v1.KeyRotation node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Key rotations data with corresponding page information
message KeyRotationConnection {
    // Key rotation data with corresponding cursor.
    repeated KeyRotationEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// -- Ethereum key rotations --

// Request to list ethereum key rotations for nodes, optionally filtered by node
message ListEthereumKeyRotationsRequest {
    // Node ID to get the rotation for, if provided.
    optional string node_id = 1;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 2;
}

// Response message containing Ethereum key rotations
message ListEthereumKeyRotationsResponse {
    // List of Ethereum key rotations data with corresponding page information.
    EthereumKeyRotationsConnection key_rotations = 1;
}

// List of Ethereum key rotations data with corresponding page information
message EthereumKeyRotationsConnection {
    // List of Ethereum key rotations data with corresponding cursors.
    repeated EthereumKeyRotationEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Ethereum key rotation data with corresponding cursor
message EthereumKeyRotationEdge {
    // Ethereuem key rotation data.
    vega.events.v1.EthereumKeyRotation node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// -- Vega Time --

// Request to get the current time of the Vega network
message GetVegaTimeRequest {}

// Response for the current consensus coordinated time on the Vega network, referred to as "VegaTime"
message GetVegaTimeResponse {
    // Timestamp representation of current VegaTime as represented in
    // Nanoseconds since the epoch, for example `1580473859111222333` corresponds to `2020-01-31T12:30:59.111222333Z`.
    int64 timestamp = 1;
}

// A date range for queries that can return historical data
// If only the start_timestamp is provided, results from the given start up to the most current timestamp should be returned.
// If only the end_timestamp is provided, results up to the given end should be returned (inclusive).
// If both the start_timestamp and end_timestamp are provided, results from within the date range should be returned (inclusive).
message DateRange {
    // Optional start timestamp in nanoseconds past the epoch.
    optional int64 start_timestamp = 1;
    // Optional end timestamp in nanoseconds past the epoch.
    optional int64 end_timestamp = 2;
}

// Request to get protocol upgrade status
message GetProtocolUpgradeStatusRequest {}

// Response from getting protocol upgrade status
message GetProtocolUpgradeStatusResponse {
    // Indicator if the upgrade is ready or not.
    bool ready = 1;
}

// Request type for ListProtocolUpgradeProposals; fetches a paginated list of protocol upgrade proposals
message ListProtocolUpgradeProposalsRequest {
    // Protocol upgrade proposal status to filter results from listing proposals, if provided.
    optional vega.events.v1.ProtocolUpgradeProposalStatus status = 1;
    // Option to filter listed proposals on being approved or not, if provided.
    optional string approved_by = 2;
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 3;
}

// Response type from a ListProtocolUpgradeProposals RPC call; a paginated list of protocol upgrade proposals
message ListProtocolUpgradeProposalsResponse {
    // A page of protocol upgrade proposals, with page information.
    ProtocolUpgradeProposalConnection protocol_upgrade_proposals = 1;
}

// A page of protocol upgrade proposals, with page information
message ProtocolUpgradeProposalConnection {
    // Protocol upgrade proposals page data.
    repeated ProtocolUpgradeProposalEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// A protocol upgrade proposal data with a corresponding cursor
message ProtocolUpgradeProposalEdge {
    // Protocol upgrade proposal data.
    vega.events.v1.ProtocolUpgradeEvent node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// Request type for ListCoreSnapshots; fetches a paginated list of the core snapshots.
message ListCoreSnapshotsRequest {
    // Optional pagination information to limit the data that is returned.
    optional Pagination pagination = 1;
}

// Response from a ListCoreSnapshots RPC call; a paginated list of the core snapshots.
message ListCoreSnapshotsResponse {
    // A page of core snapshot data, with page information.
    CoreSnapshotConnection core_snapshots = 1;
}

// A page of core snapshot data, with page information
message CoreSnapshotConnection {
    repeated CoreSnapshotEdge edges = 1;
    // Page information that is used for fetching further pages.
    PageInfo page_info = 2;
}

// Core snapshot data with a corresponding cursor
message CoreSnapshotEdge {
    // Core snapshot data.
    vega.events.v1.CoreSnapshotData node = 1;
    // Cursor that can be used to fetch further pages.
    string cursor = 2;
}

// -- Network History --
// Network History allows the data-node to reach out to peer nodes to fetch the most recent history, as well as
// older history if desired, such that it can quickly get itself up to the latest block height of the network and start
// to consume events for the latest block from the Vega core.
// See https://github.com/vegaprotocol/vega/tree/develop/datanode/networkhistory/README.md for a full description of Network History

// Describes a network history segment
message HistorySegment {
    // Starting height of the history segment.
    int64 from_height = 1;
    // Ending height of the history segment.
    int64 to_height = 2;
    // ID of the history segment.
    string history_segment_id = 3;
    // ID of the previous history segment.
    string previous_history_segment_id = 4;
    // Database schema version of the history segment.
    int64 database_version = 5;
    // Chain ID of the history segment.
    string chain_id = 6;

}

// Request to get the most recent history segment
message GetMostRecentNetworkHistorySegmentRequest {
}

// Response from getting most recent history segment
message GetMostRecentNetworkHistorySegmentResponse {
    // HistorySegment data.
    HistorySegment segment = 1;
    // Key seed for the swarm section.
    string swarm_key_seed  = 2;
}

// Request to list all the nodes history segments
message ListAllNetworkHistorySegmentsRequest {
}

// Response with a list of all the nodes history segments
message ListAllNetworkHistorySegmentsResponse {
    // List of history segments data.
    repeated HistorySegment segments = 1;
}

// Request to get the addresses of active network history peers
message GetActiveNetworkHistoryPeerAddressesRequest {
}

// Response containing the addresses of active network history peers
message GetActiveNetworkHistoryPeerAddressesResponse {
    // List of IP addresses for the active peers.
    repeated string ip_addresses = 1;
}

// Request to get the status of network history
message GetNetworkHistoryStatusRequest {}

// Response containing the status of network history
message GetNetworkHistoryStatusResponse {
    // The IPFS address of the data node you're connecting to.
    string ipfs_address = 1;
    // The swarm key.
    string swarm_key = 2;
    // The swarm key seed.
    string swarm_key_seed = 3;
    // The connected peers.
    repeated string connected_peers = 5;
}

// Request to get the nodes network history bootstrap peers
message GetNetworkHistoryBootstrapPeersRequest {}

// Response containing the nodes network history bootstrap peers
message GetNetworkHistoryBootstrapPeersResponse {
    // The bootstrap peers.
    repeated string bootstrap_peers = 1;
}

enum Table {
    TABLE_UNSPECIFIED  = 0;
    TABLE_BALANCES = 1;
    TABLE_CHECKPOINTS = 2;
    TABLE_DELEGATIONS = 3;
    TABLE_LEDGER = 4;
    TABLE_ORDERS = 5;
    TABLE_TRADES = 6;
    TABLE_MARKET_DATA = 7;
    TABLE_MARGIN_LEVELS = 8;
    TABLE_POSITIONS = 9;
    TABLE_LIQUIDITY_PROVISIONS = 10;
    TABLE_MARKETS = 11;
    TABLE_DEPOSITS = 12;
    TABLE_WITHDRAWALS = 13;
    TABLE_BLOCKS = 14;
    TABLE_REWARDS = 15;
}

// Request to export network history data in CSV format
message ExportNetworkHistoryRequest {
    // Block to begin exporting from. Must be the first block of a history segment,
    // which by default are 1000 blocks each; in that case - 1, 1001, 2001 etc. are valid values
    // you can check by first calling the API to list all network history segments.
    int64 from_block = 1;
    // Last block to export up to and including. Must be the last block of a history segment
    // which by default are 1000 blocks each; in that case - 1000, 2000, 3000 etc. are valid values
    // you can check by first calling the API to list all network history segments.
    int64 to_block = 2;
    // The table you would like to export data from.
    Table table = 3;
}


// Request to list all entities that were created by the given transaction hash
message ListEntitiesRequest {
    string transaction_hash = 1 [(google.api.field_behavior) = REQUIRED];
}

// Response from listing entities that were created for a given transaction hash
message ListEntitiesResponse {
    repeated vega.Account accounts = 1;
    repeated vega.Order orders = 2;
    repeated vega.Position positions = 3;
    repeated vega.LedgerEntry ledger_entries = 4;
    repeated AccountBalance balance_changes = 5;
    repeated vega.events.v1.Transfer transfers = 6;
    repeated vega.Vote votes = 7;
    repeated ERC20MultiSigSignerAddedBundle erc20_multi_sig_signer_added_bundles = 8;
    repeated ERC20MultiSigSignerRemovedBundle erc20_multi_sig_signer_removed_bundles = 9;
    repeated vega.Trade trades = 10;
    repeated vega.OracleSpec oracle_specs = 11;
    repeated vega.OracleData oracle_data = 12;
    repeated vega.Market markets = 13;
    repeated vega.Party parties = 14;
    repeated vega.MarginLevels margin_levels = 15;
    repeated vega.Reward rewards = 16;
    repeated vega.Deposit deposits = 17;
    repeated vega.Withdrawal withdrawals = 18;
    repeated vega.Asset assets = 19;
    repeated vega.LiquidityProvision liquidity_provisions = 20;
    repeated vega.Proposal proposals = 21;
    repeated vega.Delegation delegations = 22;
    repeated NodeBasic nodes = 23;
    repeated vega.commands.v1.NodeSignature node_signatures = 24;
    repeated vega.NetworkParameter network_parameters = 25;
    repeated vega.events.v1.KeyRotation key_rotations = 26;
    repeated vega.events.v1.EthereumKeyRotation ethereum_key_rotations = 27;
    repeated vega.events.v1.ProtocolUpgradeEvent protocol_upgrade_proposals = 28;
}

// Request to ping the data node
message PingRequest {
}

// Ping response from the data node
message PingResponse {
}
