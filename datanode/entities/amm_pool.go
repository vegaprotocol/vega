// Copyright (C) 2023 Gobalsky Labs Limited
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package entities

import (
	"encoding/json"
	"fmt"
	"time"

	"code.vegaprotocol.io/vega/libs/num"
	v2 "code.vegaprotocol.io/vega/protos/data-node/api/v2"
	eventspb "code.vegaprotocol.io/vega/protos/vega/events/v1"
)

type _AMMPoolID struct{}

type AMMPoolID = ID[_AMMPoolID]

type AMMPool struct {
	PartyID                           PartyID
	MarketID                          MarketID
	PoolID                            AMMPoolID
	SubAccount                        AccountID
	Commitment                        num.Decimal
	Status                            AMMPoolStatus
	StatusReason                      AMMPoolStatusReason
	ParametersBase                    num.Decimal
	ParametersLowerBound              num.Decimal
	ParametersUpperBound              num.Decimal
	ParametersMarginRatioAtLowerBound num.Decimal
	ParametersMarginRatioAtUpperBound num.Decimal
	CreatedAt                         time.Time
	LastUpdated                       time.Time
}

type AMMPoolsFilter interface {
	*PartyID | *MarketID | *AMMPoolID | *AccountID | *AMMPoolStatus

	// Where clause generated by the filter to be used in SQL queries.
	// Optionally override the default field name defined on the implemented filter
	// with the provided field name by providing a not nil value for the field name
	Where(fieldName *string, nextBindVar func(*[]any, any) string, args ...any) (string, []any)
}

func AMMPoolFromProto(pool *eventspb.AMMPool, vegaTime time.Time) (AMMPool, error) {
	var (
		commitment,
		parametersBase,
		parametersLowerBound,
		parametersUpperBound,
		parametersMarginRatioAtLowerBound,
		parametersMarginRatioAtUpperBound num.Decimal
		err error
	)
	partyID := PartyID(pool.PartyId)
	marketID := MarketID(pool.MarketId)
	poolID := AMMPoolID(pool.PoolId)
	accountID := AccountID(pool.SubAccount)
	if commitment, err = num.DecimalFromString(pool.Commitment); err != nil {
		return AMMPool{}, err
	}
	status := AMMPoolStatus(pool.Status)
	statusReason := AMMPoolStatusReason(pool.StatusReason)
	if parametersBase, err = num.DecimalFromString(pool.Parameters.Base); err != nil {
		return AMMPool{}, err
	}
	if parametersLowerBound, err = num.DecimalFromString(pool.Parameters.LowerBound); err != nil {
		return AMMPool{}, err
	}
	if parametersUpperBound, err = num.DecimalFromString(pool.Parameters.UpperBound); err != nil {
		return AMMPool{}, err
	}
	if parametersMarginRatioAtLowerBound, err = num.DecimalFromString(pool.Parameters.MarginRatioAtLowerBound); err != nil {
		return AMMPool{}, err
	}
	if parametersMarginRatioAtUpperBound, err = num.DecimalFromString(pool.Parameters.MarginRatioAtUpperBound); err != nil {
		return AMMPool{}, err
	}

	return AMMPool{
		PartyID:                           partyID,
		MarketID:                          marketID,
		PoolID:                            poolID,
		SubAccount:                        accountID,
		Commitment:                        commitment,
		Status:                            status,
		StatusReason:                      statusReason,
		ParametersBase:                    parametersBase,
		ParametersLowerBound:              parametersLowerBound,
		ParametersUpperBound:              parametersUpperBound,
		ParametersMarginRatioAtLowerBound: parametersMarginRatioAtLowerBound,
		ParametersMarginRatioAtUpperBound: parametersMarginRatioAtUpperBound,
		CreatedAt:                         vegaTime,
		LastUpdated:                       vegaTime,
	}, nil
}

func (p AMMPool) ToProto() *eventspb.AMMPool {
	return &eventspb.AMMPool{
		PartyId:      p.PartyID.String(),
		MarketId:     p.MarketID.String(),
		PoolId:       p.PoolID.String(),
		SubAccount:   p.SubAccount.String(),
		Commitment:   p.Commitment.String(),
		Status:       eventspb.AMMPool_Status(p.Status),
		StatusReason: eventspb.AMMPool_StatusReason(p.StatusReason),
		Parameters: &eventspb.AMMPool_ConcentratedLiquidityParameters{
			Base:                    p.ParametersBase.String(),
			LowerBound:              p.ParametersLowerBound.String(),
			UpperBound:              p.ParametersUpperBound.String(),
			MarginRatioAtLowerBound: p.ParametersMarginRatioAtLowerBound.String(),
			MarginRatioAtUpperBound: p.ParametersMarginRatioAtUpperBound.String(),
		},
	}
}

type AMMPoolCursor struct {
	CreatedAt  time.Time
	PartyID    PartyID
	MarketID   MarketID
	PoolID     AMMPoolID
	SubAccount AccountID
}

func (c AMMPoolCursor) String() string {
	bs, err := json.Marshal(c)
	if err != nil {
		panic(fmt.Errorf("could not marshal AMM pool cursor: %v", err))
	}
	return string(bs)
}

func (c *AMMPoolCursor) Parse(cursorString string) error {
	if cursorString == "" {
		return nil
	}
	return json.Unmarshal([]byte(cursorString), c)
}

func (p AMMPool) Cursor() *Cursor {
	pc := AMMPoolCursor{
		CreatedAt:  p.CreatedAt,
		PartyID:    p.PartyID,
		MarketID:   p.MarketID,
		PoolID:     p.PoolID,
		SubAccount: p.SubAccount,
	}
	return NewCursor(pc.String())
}

func (p AMMPool) ToProtoEdge(_ ...any) (*v2.AMMPoolEdge, error) {
	return &v2.AMMPoolEdge{
		Node:   p.ToProto(),
		Cursor: p.Cursor().Encode(),
	}, nil
}
