// Copyright (c) 2022 Gobalsky Labs Limited
//
// Use of this software is governed by the Business Source License included
// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.
//
// Change Date: 18 months from the later of the date of the first publicly
// available Distribution of this version of the repository, and 25 June 2022.
//
// On the date above, in accordance with the Business Source License, use
// of this software will be governed by version 3 or later of the GNU General
// Public License.

package liquidity_test

import (
	"context"
	"testing"
	"time"

	"code.vegaprotocol.io/vega/core/idgeneration"
	"code.vegaprotocol.io/vega/core/types"
	"code.vegaprotocol.io/vega/libs/crypto"
	"code.vegaprotocol.io/vega/libs/num"
	snapshotpb "code.vegaprotocol.io/vega/protos/vega/snapshot/v1"
	"github.com/golang/mock/gomock"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"code.vegaprotocol.io/vega/libs/proto"
)

func TestEngineSnapshot(t *testing.T) {
	originalEngine := newTestEngine(t)

	ctx := context.Background()
	idgen := idgeneration.New(crypto.RandomHash())

	party1 := "party-1"
	commitment1 := 1000000
	party1Orders := []*types.Order{
		{Side: types.SideBuy, Price: num.NewUint(98), Size: 5103},
		{Side: types.SideBuy, Price: num.NewUint(93), Size: 5377},
		{Side: types.SideSell, Price: num.NewUint(102), Size: 4902},
		{Side: types.SideSell, Price: num.NewUint(107), Size: 4673},
	}

	party2 := "party-2"
	commitment2 := 3000000
	party2Orders := []*types.Order{
		{Side: types.SideBuy, Price: num.NewUint(98), Size: 15307},
		{Side: types.SideBuy, Price: num.NewUint(93), Size: 16130},
		{Side: types.SideSell, Price: num.NewUint(102), Size: 14706},
		{Side: types.SideSell, Price: num.NewUint(107), Size: 14019},
	}

	party3 := "party-3"
	commitment3 := 2000000
	party3Provision := &types.LiquidityProvisionSubmission{
		MarketID:         originalEngine.marketID,
		CommitmentAmount: num.NewUint(uint64(commitment3)),
		Fee:              num.DecimalFromFloat(0.5),
	}

	// Adding some state.
	originalEngine.broker.EXPECT().Send(gomock.Any()).AnyTimes()
	originalEngine.auctionState.EXPECT().InAuction().Return(false).AnyTimes()

	// Adding provisions.
	// This helper method flush the initially pending provisions as "on-going"
	// provisions.
	originalEngine.submitLiquidityProvisionAndCreateOrders(t, ctx, party1, commitment1, idgen, party1Orders)
	originalEngine.submitLiquidityProvisionAndCreateOrders(t, ctx, party2, commitment2, idgen, party2Orders)
	// Adding pending provisions.
	// When not calling `ApplyPendingProvisions()`, the submitted provision is
	// automatically pending if market is not in auction.
	provisioned, err := originalEngine.engine.SubmitLiquidityProvision(ctx, party3Provision, party3, idgen)
	require.NoError(t, err)
	require.False(t, provisioned, "this will help testing the pending provisions, so it should not directly be added as provision")

	// Verifying we can salvage the state for each key, and they are a valid
	// Payload.
	engine1Keys := originalEngine.engine.Keys()
	stateResults1 := map[string]stateResult{}
	for _, key := range engine1Keys {
		// Salvage the state.
		state, additionalProviders, err := originalEngine.engine.GetState(key)
		require.NoError(t, err)
		assert.Nil(t, additionalProviders, "No additional provider should be generated by this engine")
		require.NotNil(t, state)
		require.NotEmpty(t, state)

		// Deserialize the state to Payload.
		var p snapshotpb.Payload
		require.NoError(t, proto.Unmarshal(state, &p))

		stateResults1[key] = stateResult{
			state:   state,
			payload: types.PayloadFromProto(&p),
		}
	}

	// Another engine to test determinism and consistency.
	otherEngine := newTestEngine(t)
	otherEngine.broker.EXPECT().Send(gomock.Any()).AnyTimes()
	otherEngine.broker.EXPECT().SendBatch(gomock.Any()).AnyTimes()
	otherEngine.auctionState.EXPECT().InAuction().Return(false).AnyTimes()

	// Just to verify the keys are deterministic.
	require.Equal(t, engine1Keys, otherEngine.engine.Keys())

	// Reloading previous payload in another engine.
	for _, key := range engine1Keys {
		additionalProviders, err := otherEngine.engine.LoadState(ctx, stateResults1[key].payload)
		require.NoError(t, err)
		require.Nil(t, additionalProviders, "No additional provider should be generated by this engine")
	}

	for _, key1 := range engine1Keys {
		// Salvage the state from other engine to test determinism.
		state2, additionalProviders, err := otherEngine.engine.GetState(key1)
		require.NoError(t, err)
		require.Nil(t, additionalProviders, "No additional provider should be generated by this engine")
		require.NotNil(t, state2)
		require.NotEmpty(t, state2)

		var p snapshotpb.Payload
		require.NoError(t, proto.Unmarshal(state2, &p))
		require.Equalf(t, stateResults1[key1].state, state2, "State for key %q between two engines must match", key1)
	}

	// Check that the restored state is complete, and lead to the same results.
	now := time.Now()

	penalties1 := originalEngine.engine.CalculateSLAPenalties(now)
	penalties2 := otherEngine.engine.CalculateSLAPenalties(now)
	assert.Equal(t, penalties1.AllPartiesHaveFullFeePenalty, penalties2.AllPartiesHaveFullFeePenalty)
	assert.Equal(t, len(penalties1.PenaltiesPerParty), len(penalties2.PenaltiesPerParty))

	for k, p1 := range penalties1.PenaltiesPerParty {
		p2, ok := penalties2.PenaltiesPerParty[k]
		assert.True(t, ok)
		assert.Equal(t, p1.Bond.String(), p2.Bond.String())
		assert.Equal(t, p1.Fee.String(), p2.Fee.String())
	}

	assert.Equal(t,
		originalEngine.engine.CalculateSuppliedStake(),
		otherEngine.engine.CalculateSuppliedStake(),
	)
}

func TestStopSnapshotTaking(t *testing.T) {
	te := newTestEngine(t)
	keys := te.engine.Keys()

	// signal to kill the engine's snapshots
	te.engine.StopSnapshots()

	s, _, err := te.engine.GetState(keys[0])
	assert.NoError(t, err)
	assert.Nil(t, s)
	assert.True(t, te.engine.Stopped())
}

type stateResult struct {
	state   []byte
	payload *types.Payload
}
