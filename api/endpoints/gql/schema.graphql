## GQL - TODO
###############
# Trades subscription
# Orders subscription
#   >>> open orders filter (future?)
# Candles subscription
# Positions subscription
# Depth subscription


# Represents a date/time
scalar DateTime

schema {
    query: Query,
    subscription: Subscription
}

# Mutations are similar to GraphQL queries, however they allow a caller to change or mutate data.
type Mutation {
    
    # Send a create order request into VEGA network, this does not immediately create the order.
    # It validates and sends the request out for consensus. Price and Size will be converted to uint64 internally.
    orderCreate(market: String!, party: String!, price: String!, size: String!, side: Side!, type: OrderType!): PreConsensus!

    # Send a cancel order request into VEGA network, this does not immediately cancel an order.
    # It validates and sends the request out for consensus.
    orderCancel(id: ID!, market: String!, party: String!): PreConsensus!
}

# Queries allow a caller to read data and filter data via GraphQL.
type Query {
    # Int64 not yet supported, strings are returned and will need to be handled by clients:
    # https://github.com/graphql-go/graphql/issues/257
    
    # VEGA root query
    vega: Vega!
}

# Subscriptions allow a caller to receive new information as it is available from the VEGA platform.
type Subscription {
    candles(market: String!, interval: Int!): Candle!
    orders(market: String, party: String): Order!
    trades(market: String, party: String): Trade!
    positions(party: String!): Position!
    marketDepth(market: String!): MarketDepth!
}

# An operation that is run before passing on to consensus, e.g. cancelling an order, will report whether it was accepted.
type PreConsensus {

    # If true then the operation was validated and passed on for consensus with other nodes on the VEGA platform.
    accepted: Boolean!
}

# VEGA the world's premier distributed derivatives trading platform
type Vega {
    
    # An instrument that is trading on the VEGA network
    markets(name: String): [Market!]

    # An entity that is trading on the VEGA network
    parties(name: String): [Party!]
}

# Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market {
    
    # Market full name
    name: String!

    # Orders on a market
    orders: [Order!]

    # Trades on a market
    trades: [Trade!]

    # Current depth on the orderbook for this market
    depth: MarketDepth!
}

# Market Depth is a measure of the number of open buy and sell orders for a security or currency at different prices.
# The depth of market measure provides an indication of the liquidity and depth for the instrument.
type MarketDepth {

    # Market name
    name: String!

    # Buy side price levels if available
    buy: [PriceLevel!]
    
    # Sell side price levels (if available)
    sell: [PriceLevel!]
}


# Represents a price on either the buy or sell side and all the orders at that price
type PriceLevel {

    # The price of all the orders at this level (uint64)
    price: String!

    # The total remaining size of all orders at this level (uint64)
    volume: String!

    # The number of orders at this price level (uint64)
    numberOfOrders: String!

    # The cumulative total volume to this price level (uint64)
    cumulativeVolume: String!
}

# Candle stick representation of trading
type Candle {

    # The date and time for the candlestick
    date: DateTime!

    # High price (uint64)
    high: String!

    # Low price (uint64)
    low: String!

    # Open price (uint64)
    open: String!

    # Close price (uint64)
    close: String!

    # Volume price (uint64)
    volume: String!

    # The block number of the opening trade (uint64)
    openBlockNumber: String!

    # The block number of the closing trade (uint64)
    closeBlockNumber: String!
}

# Represents a party on Vega, could be an ethereum wallet address in the future
type Party {
    # Party identifier
    name: String!

    # Orders relating to a party
    orders: [Order!]

    # Trading positions relating to a party
    positions: [Position!]
}


# An individual trader at any point in time is considered net long or net short.
# This refers to their Open Volume, calculated using FIFO. This volume should now be signed as either
# negative for LONG positions and positive for SHORT positions. A single trade may end up "splitting" with some
# of its volume matched into closed volume and some of its volume remaining as open volume. This is why we don't
# refer to positions being comprised of trades, rather of volume.
type Position {

    # Market relating to this position
    market: Market!

    # Realised volume (uint64)
    realisedVolume: String!

    # Realised Profit and Loss (int64, will be converted to uint64 with +ve/-ve indicator in future)
    realisedProfitValue: String!

    # Realised Profit or Loss direction
    realisedProfitDirection: ValueDirection!

    # Unrealised volume (uint64)
    unrealisedVolume: String!

    # Unrealised Profit and Loss  (int64, will be converted to uint64 with +ve/-ve indicator in future)
    unrealisedProfitValue: String!

    # Unrealised Profit or Loss direction
    unrealisedProfitDirection: ValueDirection!

    # Average entry price for this position
    averageEntryPrice: String!

    # Minimum margin for this position
    minimumMargin: String!
}


# An order in Vega, if active it will be on the OrderBoook for the market
type Order {

    # Hash of the order data
    id: ID!

    # The worst price the order will trade at (e.g. buy for price or less, sell for price or more) (uint64)
    price: String!

    # The type of order (determines how and if it executes, and whether it persists on the book)
    type: OrderType!

    # Whether the order is to buy or sell
    side: Side!

    # The market the order is trading on (probably stored internally as a hash of the market details)
    market: Market!

    # Total number of contracts that may be bought or sold (immutable) (uint64)
    size: String!

    # Number of contracts remaining of the total that have not yet been bought or sold (uint64)
    remaining: String!

    # The trader who place the order (probably stored internally as the trader's public key)
    party: String!

    # If the order was added to the book or uncrossed at any point, the timestamp when that was done
    timestamp: String!

    # The status of an order, for example 'Active'
    status: OrderStatus!
}


# A trade on Vega, the result of two orders being "matched" in the market
type Trade {

    # The hash of the trade data
    id: ID!

    # The market the trade occurred on
    market: Market!

    # The order that bought
    buyer: String!

    # The order that sold
    seller: String!

    # The aggressor indicates whether this trade was related to a BUY or SELL
    aggressor: Side!

    # The price of the trade (probably initially the passive order price, other determination algorithms are possible though) (uint64)
    price: String!

    # The number of contracts trades, will always be <= the remaining size of both orders immediately before the trade (uint64)
    size: String!

    # When the trade occured, probably the timestamp of the agressive order
    timestamp: String!
}

# Valid order types, these determine what happens when an order is added to the book
enum OrderType {

    # The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
    FOK,

    # The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
    ENE,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
    GTC,

    # This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
    # NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
    GTT,
}

# Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
enum OrderStatus {

    # The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
    # Active does not necessarily mean it's still on the order book.
    Active,

    # The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
    Cancelled,

    # This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
    Expired,
}

# Whether the placer of an order is aiming to buy or sell on the market
enum Side {
    Buy
    Sell
}

# Whether the position etc value is in profit (positive) or loss (negative).
enum ValueDirection {
    Positive
    Negative
}


