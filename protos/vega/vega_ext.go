// vega_ext provides extra methods to the types generated by protobuf.

package vega

import (
	fmt "fmt"
	"strconv"
	"time"
)

// Float64Fee tries to parse the Fee (string) into a float64.
// If parsing fails 0 is returned.
func (l *LiquidityProvision) Float64Fee() float64 {
	v, err := strconv.ParseFloat(l.Fee, 64)
	if err != nil {
		return 0
	}
	return v
}

func (o *Order) IsLiquidityOrder() bool {
	return len(o.LiquidityProvisionId) > 0
}

// Create sets the creation time (CreatedAt) to t and returns the
// updated order.
func (o *Order) Create(t time.Time) *Order {
	o.CreatedAt = t.UnixNano()
	return o
}

// Update sets the modification time (UpdatedAt) to t and returns the
// updated order.
func (o *Order) Update(t time.Time) *Order {
	o.UpdatedAt = t.UnixNano()
	return o
}

// IsPersistent returns true if the order is persistent.
// A persistent order is a Limit type order that might be
// matched in the future.
func (o *Order) IsPersistent() bool {
	return (o.TimeInForce == Order_TIME_IN_FORCE_GTC ||
		o.TimeInForce == Order_TIME_IN_FORCE_GTT ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFN ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFA) &&
		o.Type == Order_TYPE_LIMIT &&
		o.Remaining > 0
}

func (o *Order) IsExpireable() bool {
	return (o.TimeInForce == Order_TIME_IN_FORCE_GFN ||
		o.TimeInForce == Order_TIME_IN_FORCE_GTT ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFA) &&
		o.ExpiresAt > 0
}

// IsFinished returns true if an order
// is in any state different to ACTIVE and PARKED
// Basically any order which is never gonna
// trade anymore.
func (o *Order) IsFinished() bool {
	return o.Status != Order_STATUS_ACTIVE && o.Status != Order_STATUS_PARKED
}

func (o *Order) HasTraded() bool {
	return o.Size != o.Remaining
}

func (t *Trade) SetIDs(aggressive, passive *Order, idx int) {
	t.Id = fmt.Sprintf("%s-%010d", aggressive.Id, idx)
	if aggressive.Side == Side_SIDE_BUY {
		t.BuyOrder = aggressive.Id
		t.SellOrder = passive.Id
		return
	}
	t.SellOrder = aggressive.Id
	t.BuyOrder = passive.Id
}
