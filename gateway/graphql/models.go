// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/protos/vega"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

// union type for wrapped events in stream PROPOSAL is mapped to governance data, something to keep in mind
type Event interface {
	IsEvent()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type TransferKind interface {
	IsTransferKind()
}

type UpdateMarketRiskParameters interface {
	IsUpdateMarketRiskParameters()
}

type WithdrawalDetails interface {
	IsWithdrawalDetails()
}

// An auction duration is used to configure 3 auction periods:
// 1. `duration > 0`, `volume == 0`:
// The auction will last for at least N seconds.
// 2. `duration == 0`, `volume > 0`:
// The auction will end once we can close with given traded volume.
// 3. `duration > 0`, `volume > 0`:
// The auction will take at least N seconds, but can end sooner if we can trade a certain volume.
type AuctionDuration struct {
	// Duration of the auction in seconds
	DurationSecs int `json:"durationSecs"`
	// Target uncrossing trading volume
	Volume int `json:"volume"`
}

// A vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// Maximum amount that can be requested by a party through the built-in asset faucet at a time
	MaxFaucetAmountMint string `json:"maxFaucetAmountMint"`
}

func (BuiltinAsset) IsAssetSource() {}

type BusEvent struct {
	// the id for this event
	EventID string `json:"eventId"`
	// the block hash
	Block string `json:"block"`
	// the type of event we're dealing with
	Type BusEventType `json:"type"`
	// the payload - the wrapped event
	Event Event `json:"event"`
}

// A mode where Vega tries to execute orders as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

type DispatchStrategy struct {
	// What to contribution is measured
	DispatchMetric DispatchMetric `json:"dispatchMetric"`
	// The asset to use for measuring contibution to the metric
	DispatchMetricAssetID string `json:"dispatchMetricAssetId"`
	// Scope the dispatch to this markets only under the metric asset
	MarketIdsInScope []string `json:"marketIdsInScope"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
	// The lifetime limits deposit per address
	// Note: this is a temporary measure for restricted mainnet
	LifetimeLimit string `json:"lifetimeLimit"`
	// The maximum allowed per withdraw
	// Note: this is a temporary measure for restricted mainnet
	WithdrawThreshold string `json:"withdrawThreshold"`
}

func (Erc20) IsAssetSource() {}

type EpochParticipation struct {
	Epoch *vega.Epoch `json:"epoch"`
	// RFC3339 timestamp
	Offline *string `json:"offline"`
	// RFC3339 timestamp
	Online       *string  `json:"online"`
	TotalRewards *float64 `json:"totalRewards"`
}

// All the data related to the approval of a withdrawal from the network
type Erc20WithdrawalApproval struct {
	// The source asset in the ethereum network
	AssetSource string `json:"assetSource"`
	// The amount to be withdrawn
	Amount string `json:"amount"`
	// Timestamp in seconds for expiry of the approval
	Expiry string `json:"expiry"`
	// The nonce to be used in the request
	Nonce string `json:"nonce"`
	// Signature aggregate from the nodes, in the following format:
	// 0x + sig1 + sig2 + ... + sigN
	Signatures string `json:"signatures"`
	// The target address which will receive the funds
	TargetAddress string `json:"targetAddress"`
	// Timestamp at which the withdrawal was created
	Creation string `json:"creation"`
}

// Specific details for an erc20 withdrawal
type Erc20WithdrawalDetails struct {
	// The ethereum address of the receiver of the asset funds
	ReceiverAddress string `json:"receiverAddress"`
}

func (Erc20WithdrawalDetails) IsWithdrawalDetails() {}

// An Ethereum oracle
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

type LedgerEntry struct {
	// account from which the asset was taken
	FromAccount string `json:"fromAccount"`
	// account to which the balance was transferred
	ToAccount string `json:"toAccount"`
	// the amount transferred
	Amount string `json:"amount"`
	// The transfer reference
	Reference string `json:"reference"`
	// Type of ledger entry
	Type string `json:"type"`
	// RFC3339Nano time at which the transfer was made
	Timestamp string `json:"timestamp"`
}

// Configuration of a market liquidity monitoring parameters
type LiquidityMonitoringParameters struct {
	// Specifies parameters related to target stake calculation
	TargetStakeParameters *TargetStakeParameters `json:"targetStakeParameters"`
	// Specifies the triggering ratio for entering liquidity auction
	TriggeringRatio float64 `json:"triggeringRatio"`
}

// The equity like share of liquidity fee for each liquidity provider
type LiquidityProviderFeeShare struct {
	// The liquidity provider party id
	Party *vega.Party `json:"party"`
	// The share own by this liquidity provider (float)
	EquityLikeShare string `json:"equityLikeShare"`
	// the average entry valuation of the liquidity provider for the market
	AverageEntryValuation string `json:"averageEntryValuation"`
}

type LossSocialization struct {
	// the market ID where loss socialization happened
	MarketID string `json:"marketId"`
	// the party that was part of the loss socialization
	PartyID string `json:"partyId"`
	// the amount lost
	Amount string `json:"amount"`
}

func (LossSocialization) IsEvent() {}

// The MM commitments for this market
type MarketDataCommitments struct {
	// a set of liquidity sell orders to meet the liquidity provision obligation, see MM orders spec.
	Sells []*vega.LiquidityOrderReference `json:"sells"`
	// a set of liquidity buy orders to meet the liquidity provision obligation, see MM orders spec.
	Buys []*vega.LiquidityOrderReference `json:"buys"`
}

type MarketEvent struct {
	// the market ID
	MarketID string `json:"marketId"`
	// the message - market events are used for logging
	Payload string `json:"payload"`
}

func (MarketEvent) IsEvent() {}

type MarketTick struct {
	// the market ID
	MarketID string `json:"marketId"`
	// the block time
	Time string `json:"time"`
}

func (MarketTick) IsEvent() {}

type OffsetPagination struct {
	// Skip the number of records specified, default is 0
	Skip int `json:"skip"`
	// Limit the number of returned records to the value specified, default is 50
	Limit int `json:"limit"`
	// Descending reverses the order of the records returned
	// default is true, if false the results will be returned in ascending order
	Descending bool `json:"descending"`
}

// An estimate of the fee to be paid by the order
type OrderEstimate struct {
	// The estimated fee if the order was to trade
	Fee *TradeFee `json:"fee"`
	// The total estimated amount of fee if the order was to trade
	TotalFeeAmount string `json:"totalFeeAmount"`
	// The margin requirement for this order
	MarginLevels *vega.MarginLevels `json:"marginLevels"`
}

type PositionResolution struct {
	// the market ID where position resolution happened
	MarketID string `json:"marketId"`
	// number of distressed parties on market
	Distressed int `json:"distressed"`
	// number of parties closed out
	Closed int `json:"closed"`
	// the mark price at which parties were distressed/closed out
	MarkPrice string `json:"markPrice"`
}

func (PositionResolution) IsEvent() {}

// Range of valid prices and the associated price monitoring trigger
type PriceMonitoringBounds struct {
	// Minimum price that isn't currently breaching the specified price monitoring trigger
	MinValidPrice string `json:"minValidPrice"`
	// Maximum price that isn't currently breaching the specified price monitoring trigger
	MaxValidPrice string `json:"maxValidPrice"`
	// Price monitoring trigger associated with the bounds
	Trigger *PriceMonitoringTrigger `json:"trigger"`
	// Reference price used to calculate the valid price range
	ReferencePrice string `json:"referencePrice"`
}

// PriceMonitoringParameters holds a list of triggers
type PriceMonitoringParameters struct {
	// The list of triggers for this price monitoring
	Triggers []*PriceMonitoringTrigger `json:"triggers"`
}

// Configuration of a market price monitoring auctions triggers
type PriceMonitoringSettings struct {
	// Specified a set of PriceMonitoringParameters to be use for price monitoring purposes
	Parameters *PriceMonitoringParameters `json:"parameters"`
	// How often (in seconds) the price monitoring bounds should be updated
	UpdateFrequencySecs int `json:"updateFrequencySecs"`
}

// PriceMonitoringParameters holds together price projection horizon τ, probability level p, and auction extension duration
type PriceMonitoringTrigger struct {
	// Price monitoring projection horizon τ in seconds (> 0).
	HorizonSecs int `json:"horizonSecs"`
	// Price monitoring probability level p. (>0 and < 1)
	Probability float64 `json:"probability"`
	// Price monitoring auction extension duration in seconds should the price
	// breach it's theoretical level over the specified horizon at the specified
	// probability level (> 0)
	AuctionExtensionSecs int `json:"auctionExtensionSecs"`
}

type ProposalVote struct {
	// Cast vote
	Vote *vega.Vote `json:"vote"`
	// Proposal casting the vote on
	ProposalID string `json:"proposalId"`
}

type ProposalVoteSide struct {
	// All votes casted for this side
	Votes []*vega.Vote `json:"votes"`
	// Total number of votes casted for this side
	TotalNumber string `json:"totalNumber"`
	// Total weight of governance token from the votes casted for this side
	TotalWeight string `json:"totalWeight"`
	// Total tokens of governance token from the votes casted for this side
	TotalTokens string `json:"totalTokens"`
}

type ProposalVotes struct {
	// Yes votes cast for this proposal
	Yes *ProposalVoteSide `json:"yes"`
	// No votes cast for this proposal
	No *ProposalVoteSide `json:"no"`
}

type SettleDistressed struct {
	// the market in which a position was closed out
	MarketID string `json:"marketId"`
	// the party who closed out
	PartyID string `json:"partyId"`
	// the margin taken from distressed party
	Margin string `json:"margin"`
	// the price at which position was closed out
	Price string `json:"price"`
}

func (SettleDistressed) IsEvent() {}

type SettlePosition struct {
	// the market in which a position was settled
	MarketID string `json:"marketId"`
	// the party who settled a position
	PartyID string `json:"partyId"`
	// the settle price
	Price string `json:"price"`
	// the trades that were settled to close the overall position
	TradeSettlements []*TradeSettlement `json:"tradeSettlements"`
}

func (SettlePosition) IsEvent() {}

// TargetStakeParameters contains parameters used in target stake calculation
type TargetStakeParameters struct {
	// Specifies length of time window expressed in seconds for target stake calculation
	TimeWindow int `json:"timeWindow"`
	// Specifies scaling factors used in target stake calculation
	ScalingFactor float64 `json:"scalingFactor"`
}

type TimeUpdate struct {
	// RFC3339Nano time of new block time
	Timestamp string `json:"timestamp"`
}

func (TimeUpdate) IsEvent() {}

// The fee paid by the party when a trade occurs
type TradeFee struct {
	// The maker fee, aggressive party to the other party (the one who had an order in the book)
	MakerFee string `json:"makerFee"`
	// The infrastructure fee, a fee paid to the node runner to maintain the vega network
	InfrastructureFee string `json:"infrastructureFee"`
	// The fee paid to the market makers to provide liquidity in the market
	LiquidityFee string `json:"liquidityFee"`
}

type TradeSettlement struct {
	// the size of the trade
	Size int `json:"size"`
	// the price of the trade
	Price string `json:"price"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

type TransferBalance struct {
	// Account involved in transfer
	Account *vega.Account `json:"account"`
	// The new balance of the account
	Balance string `json:"balance"`
}

type TransferResponse struct {
	// the ledger entries and balances resulting from a transfer request
	Transfers []*LedgerEntry `json:"transfers"`
	// the balances of accounts involved in the transfer
	Balances []*TransferBalance `json:"balances"`
}

type TransferResponses struct {
	// a group of transfer responses - events from core
	Responses []*TransferResponse `json:"responses"`
}

func (TransferResponses) IsEvent() {}

type UpdateInstrumentConfiguration struct {
	Code    string                    `json:"code"`
	Product *vega.UpdateFutureProduct `json:"product"`
}

type AssetStatus string

const (
	// Asset is proposed to be added to the network
	AssetStatusProposed AssetStatus = "Proposed"
	// Asset has been rejected
	AssetStatusRejected AssetStatus = "Rejected"
	// Asset is pending listing on the ethereum bridge
	AssetStatusPendingListing AssetStatus = "PendingListing"
	// Asset can be used on the vega network
	AssetStatusEnabled AssetStatus = "Enabled"
)

var AllAssetStatus = []AssetStatus{
	AssetStatusProposed,
	AssetStatusRejected,
	AssetStatusPendingListing,
	AssetStatusEnabled,
}

func (e AssetStatus) IsValid() bool {
	switch e {
	case AssetStatusProposed, AssetStatusRejected, AssetStatusPendingListing, AssetStatusEnabled:
		return true
	}
	return false
}

func (e AssetStatus) String() string {
	return string(e)
}

func (e *AssetStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetStatus", str)
	}
	return nil
}

func (e AssetStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuctionTrigger string

const (
	// Invalid trigger (or no auction)
	AuctionTriggerUnspecified AuctionTrigger = "Unspecified"
	// Auction because market is trading FBA
	AuctionTriggerBatch AuctionTrigger = "Batch"
	// Opening auction
	AuctionTriggerOpening AuctionTrigger = "Opening"
	// Price monitoring
	AuctionTriggerPrice AuctionTrigger = "Price"
	// Liquidity monitoring
	AuctionTriggerLiquidity AuctionTrigger = "Liquidity"
)

var AllAuctionTrigger = []AuctionTrigger{
	AuctionTriggerUnspecified,
	AuctionTriggerBatch,
	AuctionTriggerOpening,
	AuctionTriggerPrice,
	AuctionTriggerLiquidity,
}

func (e AuctionTrigger) IsValid() bool {
	switch e {
	case AuctionTriggerUnspecified, AuctionTriggerBatch, AuctionTriggerOpening, AuctionTriggerPrice, AuctionTriggerLiquidity:
		return true
	}
	return false
}

func (e AuctionTrigger) String() string {
	return string(e)
}

func (e *AuctionTrigger) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuctionTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuctionTrigger", str)
	}
	return nil
}

func (e AuctionTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BusEventType string

const (
	// Vega Time has changed
	BusEventTypeTimeUpdate BusEventType = "TimeUpdate"
	// A balance has been transferred between accounts
	BusEventTypeTransferResponses BusEventType = "TransferResponses"
	// A position resolution event has occurred
	BusEventTypePositionResolution BusEventType = "PositionResolution"
	// An order has been created or updated
	BusEventTypeOrder BusEventType = "Order"
	// An account has been updated
	BusEventTypeAccount BusEventType = "Account"
	// A party has been updated
	BusEventTypeParty BusEventType = "Party"
	// A trade has been created
	BusEventTypeTrade BusEventType = "Trade"
	// Margin levels have changed for a position
	BusEventTypeMarginLevels BusEventType = "MarginLevels"
	// A governance proposal has been created or updated
	BusEventTypeProposal BusEventType = "Proposal"
	// A vote has been placed on a governance proposal
	BusEventTypeVote BusEventType = "Vote"
	// Market data has been updated
	BusEventTypeMarketData BusEventType = "MarketData"
	// Validator nodes signatures for an event
	BusEventTypeNodeSignature BusEventType = "NodeSignature"
	// A position has been closed without sufficient insurance pool balance to cover it
	BusEventTypeLossSocialization BusEventType = "LossSocialization"
	// A position has been settled
	BusEventTypeSettlePosition BusEventType = "SettlePosition"
	// A distressed position has been settled
	BusEventTypeSettleDistressed BusEventType = "SettleDistressed"
	// A new market has been created
	BusEventTypeMarketCreated BusEventType = "MarketCreated"
	// A market has been updated
	BusEventTypeMarketUpdated BusEventType = "MarketUpdated"
	// An asset has been created or update
	BusEventTypeAsset BusEventType = "Asset"
	// A market has progressed by one tick
	BusEventTypeMarketTick BusEventType = "MarketTick"
	// A market has either entered or exited auction
	BusEventTypeAuction BusEventType = "Auction"
	// A risk factor adjustment was made
	BusEventTypeRiskFactor BusEventType = "RiskFactor"
	// A liquidity commitment change occurred
	BusEventTypeLiquidityProvision BusEventType = "LiquidityProvision"
	// Collateral has deposited in to this Vega network via the bridge
	BusEventTypeDeposit BusEventType = "Deposit"
	// Collateral has been withdrawn from this Vega network via the bridge
	BusEventTypeWithdrawal BusEventType = "Withdrawal"
	// An oracle spec has been registered
	BusEventTypeOracleSpec BusEventType = "OracleSpec"
	// constant for market events - mainly used for logging
	BusEventTypeMarket BusEventType = "Market"
)

var AllBusEventType = []BusEventType{
	BusEventTypeTimeUpdate,
	BusEventTypeTransferResponses,
	BusEventTypePositionResolution,
	BusEventTypeOrder,
	BusEventTypeAccount,
	BusEventTypeParty,
	BusEventTypeTrade,
	BusEventTypeMarginLevels,
	BusEventTypeProposal,
	BusEventTypeVote,
	BusEventTypeMarketData,
	BusEventTypeNodeSignature,
	BusEventTypeLossSocialization,
	BusEventTypeSettlePosition,
	BusEventTypeSettleDistressed,
	BusEventTypeMarketCreated,
	BusEventTypeMarketUpdated,
	BusEventTypeAsset,
	BusEventTypeMarketTick,
	BusEventTypeAuction,
	BusEventTypeRiskFactor,
	BusEventTypeLiquidityProvision,
	BusEventTypeDeposit,
	BusEventTypeWithdrawal,
	BusEventTypeOracleSpec,
	BusEventTypeMarket,
}

func (e BusEventType) IsValid() bool {
	switch e {
	case BusEventTypeTimeUpdate, BusEventTypeTransferResponses, BusEventTypePositionResolution, BusEventTypeOrder, BusEventTypeAccount, BusEventTypeParty, BusEventTypeTrade, BusEventTypeMarginLevels, BusEventTypeProposal, BusEventTypeVote, BusEventTypeMarketData, BusEventTypeNodeSignature, BusEventTypeLossSocialization, BusEventTypeSettlePosition, BusEventTypeSettleDistressed, BusEventTypeMarketCreated, BusEventTypeMarketUpdated, BusEventTypeAsset, BusEventTypeMarketTick, BusEventTypeAuction, BusEventTypeRiskFactor, BusEventTypeLiquidityProvision, BusEventTypeDeposit, BusEventTypeWithdrawal, BusEventTypeOracleSpec, BusEventTypeMarket:
		return true
	}
	return false
}

func (e BusEventType) String() string {
	return string(e)
}

func (e *BusEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusEventType", str)
	}
	return nil
}

func (e BusEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Comparator describes the type of comparison.
type ConditionOperator string

const (
	// Verify if the property values are strictly equal or not.
	ConditionOperatorOperatorEquals ConditionOperator = "OperatorEquals"
	// Verify if the oracle data value is greater than the Condition value.
	ConditionOperatorOperatorGreaterThan ConditionOperator = "OperatorGreaterThan"
	// Verify if the oracle data value is greater than or equal to the Condition
	// value.
	ConditionOperatorOperatorGreaterThanOrEqual ConditionOperator = "OperatorGreaterThanOrEqual"
	//  Verify if the oracle data value is less than the Condition value.
	ConditionOperatorOperatorLessThan ConditionOperator = "OperatorLessThan"
	// Verify if the oracle data value is less or equal to than the Condition
	// value.
	ConditionOperatorOperatorLessThanOrEqual ConditionOperator = "OperatorLessThanOrEqual"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorOperatorEquals,
	ConditionOperatorOperatorGreaterThan,
	ConditionOperatorOperatorGreaterThanOrEqual,
	ConditionOperatorOperatorLessThan,
	ConditionOperatorOperatorLessThanOrEqual,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorOperatorEquals, ConditionOperatorOperatorGreaterThan, ConditionOperatorOperatorGreaterThanOrEqual, ConditionOperatorOperatorLessThan, ConditionOperatorOperatorLessThanOrEqual:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a deposit
type DepositStatus string

const (
	// The deposit is open and being processed by the network
	DepositStatusOpen DepositStatus = "Open"
	// The deposit have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	DepositStatusCancelled DepositStatus = "Cancelled"
	// The deposit was finalized, it was first valid, the foreign chain has executed it and the network updated all accounts
	DepositStatusFinalized DepositStatus = "Finalized"
)

var AllDepositStatus = []DepositStatus{
	DepositStatusOpen,
	DepositStatusCancelled,
	DepositStatusFinalized,
}

func (e DepositStatus) IsValid() bool {
	switch e {
	case DepositStatusOpen, DepositStatusCancelled, DepositStatusFinalized:
		return true
	}
	return false
}

func (e DepositStatus) String() string {
	return string(e)
}

func (e *DepositStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DepositStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DepositStatus", str)
	}
	return nil
}

func (e DepositStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DispatchMetric string

const (
	DispatchMetricMarketTradingValue DispatchMetric = "MarketTradingValue"
	DispatchMetricMakerFeesReceived  DispatchMetric = "MakerFeesReceived"
	DispatchMetricTakerFeesPaid      DispatchMetric = "TakerFeesPaid"
	DispatchMetricLPFeesReceived     DispatchMetric = "LPFeesReceived"
)

var AllDispatchMetric = []DispatchMetric{
	DispatchMetricMarketTradingValue,
	DispatchMetricMakerFeesReceived,
	DispatchMetricTakerFeesPaid,
	DispatchMetricLPFeesReceived,
}

func (e DispatchMetric) IsValid() bool {
	switch e {
	case DispatchMetricMarketTradingValue, DispatchMetricMakerFeesReceived, DispatchMetricTakerFeesPaid, DispatchMetricLPFeesReceived:
		return true
	}
	return false
}

func (e DispatchMetric) String() string {
	return string(e)
}

func (e *DispatchMetric) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DispatchMetric(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DispatchMetric", str)
	}
	return nil
}

func (e DispatchMetric) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval for trade candles when subscribing via VEGA graphql, default is I15M
type Interval string

const (
	// 1 minute interval
	IntervalI1m Interval = "I1M"
	// 5 minute interval
	IntervalI5m Interval = "I5M"
	// 15 minute interval (default)
	IntervalI15m Interval = "I15M"
	// 1 hour interval
	IntervalI1h Interval = "I1H"
	// 6 hour interval
	IntervalI6h Interval = "I6H"
	// 1 day interval
	IntervalI1d Interval = "I1D"
)

var AllInterval = []Interval{
	IntervalI1m,
	IntervalI5m,
	IntervalI15m,
	IntervalI1h,
	IntervalI6h,
	IntervalI1d,
}

func (e Interval) IsValid() bool {
	switch e {
	case IntervalI1m, IntervalI5m, IntervalI15m, IntervalI1h, IntervalI6h, IntervalI1d:
		return true
	}
	return false
}

func (e Interval) String() string {
	return string(e)
}

func (e *Interval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Interval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Interval", str)
	}
	return nil
}

func (e Interval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a liquidity provision order
type LiquidityProvisionStatus string

const (
	// An active liquidity provision
	LiquidityProvisionStatusActive LiquidityProvisionStatus = "Active"
	// A liquidity provision stopped by the network
	LiquidityProvisionStatusStopped LiquidityProvisionStatus = "Stopped"
	// A Cancelled Liquidity provision
	LiquidityProvisionStatusCancelled LiquidityProvisionStatus = "Cancelled"
	// A liquidity provision was invalid and got rejected
	LiquidityProvisionStatusRejected LiquidityProvisionStatus = "Rejected"
	// The liquidity provision is valid and accepted by network, but orders aren't deployed
	LiquidityProvisionStatusUndeployed LiquidityProvisionStatus = "Undeployed"
	// The liquidity provision is valid and accepted by network, but orders aren't deployed.
	// but have never been deployed. I when it's possible to deploy them for the first time
	// margin check fails, then they will be cancelled without any penalties.
	LiquidityProvisionStatusPending LiquidityProvisionStatus = "Pending"
)

var AllLiquidityProvisionStatus = []LiquidityProvisionStatus{
	LiquidityProvisionStatusActive,
	LiquidityProvisionStatusStopped,
	LiquidityProvisionStatusCancelled,
	LiquidityProvisionStatusRejected,
	LiquidityProvisionStatusUndeployed,
	LiquidityProvisionStatusPending,
}

func (e LiquidityProvisionStatus) IsValid() bool {
	switch e {
	case LiquidityProvisionStatusActive, LiquidityProvisionStatusStopped, LiquidityProvisionStatusCancelled, LiquidityProvisionStatusRejected, LiquidityProvisionStatusUndeployed, LiquidityProvisionStatusPending:
		return true
	}
	return false
}

func (e LiquidityProvisionStatus) String() string {
	return string(e)
}

func (e *LiquidityProvisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LiquidityProvisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LiquidityProvisionStatus", str)
	}
	return nil
}

func (e LiquidityProvisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The current state of a market
type MarketState string

const (
	// The Governance proposal valid and accepted
	MarketStateProposed MarketState = "Proposed"
	// Outcome of governance votes is to reject the market
	MarketStateRejected MarketState = "Rejected"
	// Governance vote passes/wins
	MarketStatePending MarketState = "Pending"
	// Market triggers cancellation condition or governance
	// votes to close before market becomes Active
	MarketStateCancelled MarketState = "Cancelled"
	// Enactment date reached and usual auction exit checks pass
	MarketStateActive MarketState = "Active"
	// Price monitoring or liquidity monitoring trigger
	MarketStateSuspended MarketState = "Suspended"
	// Governance vote (to close)
	MarketStateClosed MarketState = "Closed"
	// Defined by the product (i.e. from a product parameter,
	// specified in market definition, giving close date/time)
	MarketStateTradingTerminated MarketState = "TradingTerminated"
	// Settlement triggered and completed as defined by product
	MarketStateSettled MarketState = "Settled"
)

var AllMarketState = []MarketState{
	MarketStateProposed,
	MarketStateRejected,
	MarketStatePending,
	MarketStateCancelled,
	MarketStateActive,
	MarketStateSuspended,
	MarketStateClosed,
	MarketStateTradingTerminated,
	MarketStateSettled,
}

func (e MarketState) IsValid() bool {
	switch e {
	case MarketStateProposed, MarketStateRejected, MarketStatePending, MarketStateCancelled, MarketStateActive, MarketStateSuspended, MarketStateClosed, MarketStateTradingTerminated, MarketStateSettled:
		return true
	}
	return false
}

func (e MarketState) String() string {
	return string(e)
}

func (e *MarketState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketState", str)
	}
	return nil
}

func (e MarketState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// What market trading mode are we in
type MarketTradingMode string

const (
	// Continuous trading where orders are processed and potentially matched on arrival
	MarketTradingModeContinuous MarketTradingMode = "Continuous"
	// Auction trading where orders are uncrossed at the end of the opening auction period
	MarketTradingModeOpeningAuction MarketTradingMode = "OpeningAuction"
	// Auction as normal trading mode for the market, where orders are uncrossed periodically
	MarketTradingModeBatchAuction MarketTradingMode = "BatchAuction"
	// Auction triggered by price/liquidity monitoring
	MarketTradingModeMonitoringAuction MarketTradingMode = "MonitoringAuction"
)

var AllMarketTradingMode = []MarketTradingMode{
	MarketTradingModeContinuous,
	MarketTradingModeOpeningAuction,
	MarketTradingModeBatchAuction,
	MarketTradingModeMonitoringAuction,
}

func (e MarketTradingMode) IsValid() bool {
	switch e {
	case MarketTradingModeContinuous, MarketTradingModeOpeningAuction, MarketTradingModeBatchAuction, MarketTradingModeMonitoringAuction:
		return true
	}
	return false
}

func (e MarketTradingMode) String() string {
	return string(e)
}

func (e *MarketTradingMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketTradingMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketTradingMode", str)
	}
	return nil
}

func (e MarketTradingMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type signature provided by a node
type NodeSignatureKind string

const (
	// A signature for proposing a new asset into the network
	NodeSignatureKindAssetNew NodeSignatureKind = "AssetNew"
	// A signature for allowing a withdrawal of funds
	NodeSignatureKindAssetWithdrawal NodeSignatureKind = "AssetWithdrawal"
)

var AllNodeSignatureKind = []NodeSignatureKind{
	NodeSignatureKindAssetNew,
	NodeSignatureKindAssetWithdrawal,
}

func (e NodeSignatureKind) IsValid() bool {
	switch e {
	case NodeSignatureKindAssetNew, NodeSignatureKindAssetWithdrawal:
		return true
	}
	return false
}

func (e NodeSignatureKind) String() string {
	return string(e)
}

func (e *NodeSignatureKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeSignatureKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeSignatureKind", str)
	}
	return nil
}

func (e NodeSignatureKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeStatus string

const (
	// The node is non-validating
	NodeStatusNonValidator NodeStatus = "NonValidator"
	// The node is validating
	NodeStatusValidator NodeStatus = "Validator"
)

var AllNodeStatus = []NodeStatus{
	NodeStatusNonValidator,
	NodeStatusValidator,
}

func (e NodeStatus) IsValid() bool {
	switch e {
	case NodeStatusNonValidator, NodeStatusValidator:
		return true
	}
	return false
}

func (e NodeStatus) String() string {
	return string(e)
}

func (e *NodeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatus", str)
	}
	return nil
}

func (e NodeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status describe the status of the oracle spec
type OracleSpecStatus string

const (
	// StatusActive describes an active oracle spec.
	OracleSpecStatusStatusActive OracleSpecStatus = "StatusActive"
	// StatusUnused describes an oracle spec that is not listening to data
	// anymore.
	OracleSpecStatusStatusUnused OracleSpecStatus = "StatusUnused"
)

var AllOracleSpecStatus = []OracleSpecStatus{
	OracleSpecStatusStatusActive,
	OracleSpecStatusStatusUnused,
}

func (e OracleSpecStatus) IsValid() bool {
	switch e {
	case OracleSpecStatusStatusActive, OracleSpecStatusStatusUnused:
		return true
	}
	return false
}

func (e OracleSpecStatus) String() string {
	return string(e)
}

func (e *OracleSpecStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OracleSpecStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OracleSpecStatus", str)
	}
	return nil
}

func (e OracleSpecStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the order being rejected by the core node
type OrderRejectionReason string

const (
	// Market id is invalid
	OrderRejectionReasonInvalidMarketID OrderRejectionReason = "InvalidMarketId"
	// Order id is invalid
	OrderRejectionReasonInvalidOrderID OrderRejectionReason = "InvalidOrderId"
	// Order is out of sequence
	OrderRejectionReasonOrderOutOfSequence OrderRejectionReason = "OrderOutOfSequence"
	// Remaining size in the order is invalid
	OrderRejectionReasonInvalidRemainingSize OrderRejectionReason = "InvalidRemainingSize"
	// Time has failed us
	OrderRejectionReasonTimeFailure OrderRejectionReason = "TimeFailure"
	// Unable to remove the order
	OrderRejectionReasonOrderRemovalFailure OrderRejectionReason = "OrderRemovalFailure"
	// Expiration time is invalid
	OrderRejectionReasonInvalidExpirationTime OrderRejectionReason = "InvalidExpirationTime"
	// Order reference is invalid
	OrderRejectionReasonInvalidOrderReference OrderRejectionReason = "InvalidOrderReference"
	// Edit is not allowed
	OrderRejectionReasonEditNotAllowed OrderRejectionReason = "EditNotAllowed"
	// Order amend fail
	OrderRejectionReasonOrderAmendFailure OrderRejectionReason = "OrderAmendFailure"
	// Order does not exist
	OrderRejectionReasonOrderNotFound OrderRejectionReason = "OrderNotFound"
	// Party id is invalid
	OrderRejectionReasonInvalidPartyID OrderRejectionReason = "InvalidPartyId"
	// Market is closed
	OrderRejectionReasonMarketClosed OrderRejectionReason = "MarketClosed"
	// Margin check failed
	OrderRejectionReasonMarginCheckFailed OrderRejectionReason = "MarginCheckFailed"
	// Order missing general account
	OrderRejectionReasonMissingGeneralAccount OrderRejectionReason = "MissingGeneralAccount"
	// An internal error happened
	OrderRejectionReasonInternalError OrderRejectionReason = "InternalError"
	// Invalid size
	OrderRejectionReasonInvalidSize OrderRejectionReason = "InvalidSize"
	// Invalid persistence
	OrderRejectionReasonInvalidPersistence OrderRejectionReason = "InvalidPersistence"
	// Invalid type
	OrderRejectionReasonInvalidType OrderRejectionReason = "InvalidType"
	// Self trading
	OrderRejectionReasonSelfTrading OrderRejectionReason = "SelfTrading"
	// Insufficient funds to pay fees
	OrderRejectionReasonInsufficientFundsToPayFees OrderRejectionReason = "InsufficientFundsToPayFees"
	// Invalid Time In Force
	OrderRejectionReasonInvalidTimeInForce OrderRejectionReason = "InvalidTimeInForce"
	// Attempt to amend order to GTT without ExpiryAt
	OrderRejectionReasonAmendToGTTWithoutExpiryAt OrderRejectionReason = "AmendToGTTWithoutExpiryAt"
	// Attempt to amend ExpiryAt to a value before CreatedAt
	OrderRejectionReasonExpiryAtBeforeCreatedAt OrderRejectionReason = "ExpiryAtBeforeCreatedAt"
	// Attempt to amend to GTC without an ExpiryAt value
	OrderRejectionReasonGTCWithExpiryAtNotValid OrderRejectionReason = "GTCWithExpiryAtNotValid"
	// Amending to FOK or IOC is invalid
	OrderRejectionReasonCannotAmendToFOKOrIoc OrderRejectionReason = "CannotAmendToFOKOrIOC"
	// Amending to GFA or GFN is invalid
	OrderRejectionReasonCannotAmendToGFAOrGfn OrderRejectionReason = "CannotAmendToGFAOrGFN"
	// Amending from GFA or GFN is invalid
	OrderRejectionReasonCannotAmendFromGFAOrGfn OrderRejectionReason = "CannotAmendFromGFAOrGFN"
	// Invalid Market Type
	OrderRejectionReasonInvalidMarketType OrderRejectionReason = "InvalidMarketType"
	// Good for normal order received during an auction
	OrderRejectionReasonGFNOrderDuringAuction OrderRejectionReason = "GFNOrderDuringAuction"
	// Good for auction order received during continuous trading
	OrderRejectionReasonGFAOrderDuringContinuousTrading OrderRejectionReason = "GFAOrderDuringContinuousTrading"
	// IOC orders are not allowed during auction
	OrderRejectionReasonIOCOrderDuringAuction OrderRejectionReason = "IOCOrderDuringAuction"
	// FOK orders are not allowed during auction
	OrderRejectionReasonFOKOrderDuringAuction OrderRejectionReason = "FOKOrderDuringAuction"
	// Pegged orders must be LIMIT orders
	OrderRejectionReasonPeggedOrderMustBeLimitOrder OrderRejectionReason = "PeggedOrderMustBeLimitOrder"
	// Pegged orders can only have TIF GTC or GTT
	OrderRejectionReasonPeggedOrderMustBeGTTOrGtc OrderRejectionReason = "PeggedOrderMustBeGTTOrGTC"
	// Pegged order must have a reference price
	OrderRejectionReasonPeggedOrderWithoutReferencePrice OrderRejectionReason = "PeggedOrderWithoutReferencePrice"
	// Buy pegged order cannot reference best ask price
	OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice OrderRejectionReason = "PeggedOrderBuyCannotReferenceBestAskPrice"
	// Pegged order offset must be >= 0
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero OrderRejectionReason = "PeggedOrderOffsetMustBeGreaterOrEqualToZero"
	// Sell pegged order cannot reference best bid price
	OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice OrderRejectionReason = "PeggedOrderSellCannotReferenceBestBidPrice"
	// Pegged order offset must be > zero
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero OrderRejectionReason = "PeggedOrderOffsetMustBeGreaterThanZero"
	// Insufficient balance to submit the order (no deposit made)
	OrderRejectionReasonInsufficientAssetBalance OrderRejectionReason = "InsufficientAssetBalance"
	// Cannot change pegged order fields on a non pegged order
	OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder OrderRejectionReason = "CannotAmendPeggedOrderDetailsOnNonPeggedOrder"
	// Unable to reprice a pegged order
	OrderRejectionReasonUnableToRepricePeggedOrder OrderRejectionReason = "UnableToRepricePeggedOrder"
	// Unable to amend pegged order price
	OrderRejectionReasonUnableToAmendPeggedOrderPrice OrderRejectionReason = "UnableToAmendPeggedOrderPrice"
	// Non-persistent order exceeds price bounds
	OrderRejectionReasonNonPersistentOrderExceedsPriceBounds OrderRejectionReason = "NonPersistentOrderExceedsPriceBounds"
)

var AllOrderRejectionReason = []OrderRejectionReason{
	OrderRejectionReasonInvalidMarketID,
	OrderRejectionReasonInvalidOrderID,
	OrderRejectionReasonOrderOutOfSequence,
	OrderRejectionReasonInvalidRemainingSize,
	OrderRejectionReasonTimeFailure,
	OrderRejectionReasonOrderRemovalFailure,
	OrderRejectionReasonInvalidExpirationTime,
	OrderRejectionReasonInvalidOrderReference,
	OrderRejectionReasonEditNotAllowed,
	OrderRejectionReasonOrderAmendFailure,
	OrderRejectionReasonOrderNotFound,
	OrderRejectionReasonInvalidPartyID,
	OrderRejectionReasonMarketClosed,
	OrderRejectionReasonMarginCheckFailed,
	OrderRejectionReasonMissingGeneralAccount,
	OrderRejectionReasonInternalError,
	OrderRejectionReasonInvalidSize,
	OrderRejectionReasonInvalidPersistence,
	OrderRejectionReasonInvalidType,
	OrderRejectionReasonSelfTrading,
	OrderRejectionReasonInsufficientFundsToPayFees,
	OrderRejectionReasonInvalidTimeInForce,
	OrderRejectionReasonAmendToGTTWithoutExpiryAt,
	OrderRejectionReasonExpiryAtBeforeCreatedAt,
	OrderRejectionReasonGTCWithExpiryAtNotValid,
	OrderRejectionReasonCannotAmendToFOKOrIoc,
	OrderRejectionReasonCannotAmendToGFAOrGfn,
	OrderRejectionReasonCannotAmendFromGFAOrGfn,
	OrderRejectionReasonInvalidMarketType,
	OrderRejectionReasonGFNOrderDuringAuction,
	OrderRejectionReasonGFAOrderDuringContinuousTrading,
	OrderRejectionReasonIOCOrderDuringAuction,
	OrderRejectionReasonFOKOrderDuringAuction,
	OrderRejectionReasonPeggedOrderMustBeLimitOrder,
	OrderRejectionReasonPeggedOrderMustBeGTTOrGtc,
	OrderRejectionReasonPeggedOrderWithoutReferencePrice,
	OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice,
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero,
	OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice,
	OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero,
	OrderRejectionReasonInsufficientAssetBalance,
	OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder,
	OrderRejectionReasonUnableToRepricePeggedOrder,
	OrderRejectionReasonUnableToAmendPeggedOrderPrice,
	OrderRejectionReasonNonPersistentOrderExceedsPriceBounds,
}

func (e OrderRejectionReason) IsValid() bool {
	switch e {
	case OrderRejectionReasonInvalidMarketID, OrderRejectionReasonInvalidOrderID, OrderRejectionReasonOrderOutOfSequence, OrderRejectionReasonInvalidRemainingSize, OrderRejectionReasonTimeFailure, OrderRejectionReasonOrderRemovalFailure, OrderRejectionReasonInvalidExpirationTime, OrderRejectionReasonInvalidOrderReference, OrderRejectionReasonEditNotAllowed, OrderRejectionReasonOrderAmendFailure, OrderRejectionReasonOrderNotFound, OrderRejectionReasonInvalidPartyID, OrderRejectionReasonMarketClosed, OrderRejectionReasonMarginCheckFailed, OrderRejectionReasonMissingGeneralAccount, OrderRejectionReasonInternalError, OrderRejectionReasonInvalidSize, OrderRejectionReasonInvalidPersistence, OrderRejectionReasonInvalidType, OrderRejectionReasonSelfTrading, OrderRejectionReasonInsufficientFundsToPayFees, OrderRejectionReasonInvalidTimeInForce, OrderRejectionReasonAmendToGTTWithoutExpiryAt, OrderRejectionReasonExpiryAtBeforeCreatedAt, OrderRejectionReasonGTCWithExpiryAtNotValid, OrderRejectionReasonCannotAmendToFOKOrIoc, OrderRejectionReasonCannotAmendToGFAOrGfn, OrderRejectionReasonCannotAmendFromGFAOrGfn, OrderRejectionReasonInvalidMarketType, OrderRejectionReasonGFNOrderDuringAuction, OrderRejectionReasonGFAOrderDuringContinuousTrading, OrderRejectionReasonIOCOrderDuringAuction, OrderRejectionReasonFOKOrderDuringAuction, OrderRejectionReasonPeggedOrderMustBeLimitOrder, OrderRejectionReasonPeggedOrderMustBeGTTOrGtc, OrderRejectionReasonPeggedOrderWithoutReferencePrice, OrderRejectionReasonPeggedOrderBuyCannotReferenceBestAskPrice, OrderRejectionReasonPeggedOrderOffsetMustBeGreaterOrEqualToZero, OrderRejectionReasonPeggedOrderSellCannotReferenceBestBidPrice, OrderRejectionReasonPeggedOrderOffsetMustBeGreaterThanZero, OrderRejectionReasonInsufficientAssetBalance, OrderRejectionReasonCannotAmendPeggedOrderDetailsOnNonPeggedOrder, OrderRejectionReasonUnableToRepricePeggedOrder, OrderRejectionReasonUnableToAmendPeggedOrderPrice, OrderRejectionReasonNonPersistentOrderExceedsPriceBounds:
		return true
	}
	return false
}

func (e OrderRejectionReason) String() string {
	return string(e)
}

func (e *OrderRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderRejectionReason", str)
	}
	return nil
}

func (e OrderRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
type OrderStatus string

const (
	// The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
	// Active does not necessarily mean it's still on the order book.
	OrderStatusActive OrderStatus = "Active"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
	OrderStatusExpired OrderStatus = "Expired"
	// The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
	OrderStatusCancelled OrderStatus = "Cancelled"
	// This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity.
	OrderStatusStopped OrderStatus = "Stopped"
	// This order is fully filled with remaining equals zero.
	OrderStatusFilled OrderStatus = "Filled"
	// This order was rejected while being processed in the core.
	OrderStatusRejected OrderStatus = "Rejected"
	// This order was partially filled.
	OrderStatusPartiallyFilled OrderStatus = "PartiallyFilled"
	// This order has been removed from the order book and applies to pegged orders only
	OrderStatusParked OrderStatus = "Parked"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusActive,
	OrderStatusExpired,
	OrderStatusCancelled,
	OrderStatusStopped,
	OrderStatusFilled,
	OrderStatusRejected,
	OrderStatusPartiallyFilled,
	OrderStatusParked,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusActive, OrderStatusExpired, OrderStatusCancelled, OrderStatusStopped, OrderStatusFilled, OrderStatusRejected, OrderStatusPartiallyFilled, OrderStatusParked:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order types, these determine what happens when an order is added to the book
type OrderTimeInForce string

const (
	// The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
	OrderTimeInForceFok OrderTimeInForce = "FOK"
	// The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
	OrderTimeInForceIoc OrderTimeInForce = "IOC"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
	OrderTimeInForceGtc OrderTimeInForce = "GTC"
	// This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
	// NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
	OrderTimeInForceGtt OrderTimeInForce = "GTT"
	// This order is only accepted during an auction period
	OrderTimeInForceGfa OrderTimeInForce = "GFA"
	// This order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
	OrderTimeInForceGfn OrderTimeInForce = "GFN"
)

var AllOrderTimeInForce = []OrderTimeInForce{
	OrderTimeInForceFok,
	OrderTimeInForceIoc,
	OrderTimeInForceGtc,
	OrderTimeInForceGtt,
	OrderTimeInForceGfa,
	OrderTimeInForceGfn,
}

func (e OrderTimeInForce) IsValid() bool {
	switch e {
	case OrderTimeInForceFok, OrderTimeInForceIoc, OrderTimeInForceGtc, OrderTimeInForceGtt, OrderTimeInForceGfa, OrderTimeInForceGfn:
		return true
	}
	return false
}

func (e OrderTimeInForce) String() string {
	return string(e)
}

func (e *OrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTimeInForce", str)
	}
	return nil
}

func (e OrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderType string

const (
	// the default order type
	OrderTypeMarket OrderType = "Market"
	// mentioned in ticket, but as yet unused order type
	OrderTypeLimit OrderType = "Limit"
	// Used for distressed parties, an order placed by the network to close out distressed parties
	// similar to Market order, only no party is attached to the order.
	OrderTypeNetwork OrderType = "Network"
)

var AllOrderType = []OrderType{
	OrderTypeMarket,
	OrderTypeLimit,
	OrderTypeNetwork,
}

func (e OrderType) IsValid() bool {
	switch e {
	case OrderTypeMarket, OrderTypeLimit, OrderTypeNetwork:
		return true
	}
	return false
}

func (e OrderType) String() string {
	return string(e)
}

func (e *OrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderType", str)
	}
	return nil
}

func (e OrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid references used for pegged orders.
type PeggedReference string

const (
	// Peg the order against the mid price of the order book
	PeggedReferenceMid PeggedReference = "Mid"
	// Peg the order against the best bid price of the order book
	PeggedReferenceBestBid PeggedReference = "BestBid"
	// Peg the order against the best ask price of the order book
	PeggedReferenceBestAsk PeggedReference = "BestAsk"
)

var AllPeggedReference = []PeggedReference{
	PeggedReferenceMid,
	PeggedReferenceBestBid,
	PeggedReferenceBestAsk,
}

func (e PeggedReference) IsValid() bool {
	switch e {
	case PeggedReferenceMid, PeggedReferenceBestBid, PeggedReferenceBestAsk:
		return true
	}
	return false
}

func (e PeggedReference) String() string {
	return string(e)
}

func (e *PeggedReference) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeggedReference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeggedReference", str)
	}
	return nil
}

func (e PeggedReference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type describes the type of properties that are supported by the oracle
// engine.
type PropertyKeyType string

const (
	// Any type.
	PropertyKeyTypeTypeEmpty PropertyKeyType = "TypeEmpty"
	// Integer type.
	PropertyKeyTypeTypeInteger PropertyKeyType = "TypeInteger"
	// String type.
	PropertyKeyTypeTypeString PropertyKeyType = "TypeString"
	// Boolean type.
	PropertyKeyTypeTypeBoolean PropertyKeyType = "TypeBoolean"
	// Any floating point decimal type.
	PropertyKeyTypeTypeDecimal PropertyKeyType = "TypeDecimal"
	// Timestamp date type.
	PropertyKeyTypeTypeTimestamp PropertyKeyType = "TypeTimestamp"
)

var AllPropertyKeyType = []PropertyKeyType{
	PropertyKeyTypeTypeEmpty,
	PropertyKeyTypeTypeInteger,
	PropertyKeyTypeTypeString,
	PropertyKeyTypeTypeBoolean,
	PropertyKeyTypeTypeDecimal,
	PropertyKeyTypeTypeTimestamp,
}

func (e PropertyKeyType) IsValid() bool {
	switch e {
	case PropertyKeyTypeTypeEmpty, PropertyKeyTypeTypeInteger, PropertyKeyTypeTypeString, PropertyKeyTypeTypeBoolean, PropertyKeyTypeTypeDecimal, PropertyKeyTypeTypeTimestamp:
		return true
	}
	return false
}

func (e PropertyKeyType) String() string {
	return string(e)
}

func (e *PropertyKeyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertyKeyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertyKeyType", str)
	}
	return nil
}

func (e PropertyKeyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the proposal being rejected by the core node
type ProposalRejectionReason string

const (
	// The specified close time is too early based on network parameters
	ProposalRejectionReasonCloseTimeTooSoon ProposalRejectionReason = "CloseTimeTooSoon"
	// The specified close time is too late based on network parameters
	ProposalRejectionReasonCloseTimeTooLate ProposalRejectionReason = "CloseTimeTooLate"
	// The specified enactment time is too early based on network parameters
	ProposalRejectionReasonEnactTimeTooSoon ProposalRejectionReason = "EnactTimeTooSoon"
	// The specified enactment time is too late based on network parameters
	ProposalRejectionReasonEnactTimeTooLate ProposalRejectionReason = "EnactTimeTooLate"
	// The proposer for this proposal has insufficient token
	ProposalRejectionReasonInsufficientTokens ProposalRejectionReason = "InsufficientTokens"
	// The instrument quote name and base name were the same
	ProposalRejectionReasonInvalidInstrumentSecurity ProposalRejectionReason = "InvalidInstrumentSecurity"
	// The proposal has no product specified
	ProposalRejectionReasonNoProduct ProposalRejectionReason = "NoProduct"
	// The specified product is not supported
	ProposalRejectionReasonUnsupportedProduct ProposalRejectionReason = "UnsupportedProduct"
	// Invalid future maturity timestamp (expect RFC3339)
	ProposalRejectionReasonInvalidFutureMaturityTimestamp ProposalRejectionReason = "InvalidFutureMaturityTimestamp"
	// The product maturity is already in the past
	ProposalRejectionReasonProductMaturityIsPassed ProposalRejectionReason = "ProductMaturityIsPassed"
	// The proposal has no trading mode
	ProposalRejectionReasonNoTradingMode ProposalRejectionReason = "NoTradingMode"
	// The proposal has an unsupported trading mode
	ProposalRejectionReasonUnsupportedTradingMode ProposalRejectionReason = "UnsupportedTradingMode"
	// The proposal failed node validation
	ProposalRejectionReasonNodeValidationFailed ProposalRejectionReason = "NodeValidationFailed"
	// A builtin asset configuration is missing
	ProposalRejectionReasonMissingBuiltinAssetField ProposalRejectionReason = "MissingBuiltinAssetField"
	// The ERC20 contract address is missing from an ERC20 asset proposal
	ProposalRejectionReasonMissingERC20ContractAddress ProposalRejectionReason = "MissingERC20ContractAddress"
	// The specified asset for the market proposal is invalid
	ProposalRejectionReasonInvalidAsset ProposalRejectionReason = "InvalidAsset"
	// proposal terms timestamps are not compatible (Validation < Closing < Enactment)
	ProposalRejectionReasonIncompatibleTimestamps ProposalRejectionReason = "IncompatibleTimestamps"
	// Risk parameters are missing from the market proposal
	ProposalRejectionReasonNoRiskParameters ProposalRejectionReason = "NoRiskParameters"
	// Invalid key in update network parameter proposal
	ProposalRejectionReasonNetworkParameterInvalidKey ProposalRejectionReason = "NetworkParameterInvalidKey"
	// Invalid value in update network parameter proposal
	ProposalRejectionReasonNetworkParameterInvalidValue ProposalRejectionReason = "NetworkParameterInvalidValue"
	// Validation failed for network parameter proposal
	ProposalRejectionReasonNetworkParameterValidationFailed ProposalRejectionReason = "NetworkParameterValidationFailed"
	// Opening auction duration is less than the network minimum opening auction time
	ProposalRejectionReasonOpeningAuctionDurationTooSmall ProposalRejectionReason = "OpeningAuctionDurationTooSmall"
	// Opening auction duration is more than the network minimum opening auction time
	ProposalRejectionReasonOpeningAuctionDurationTooLarge ProposalRejectionReason = "OpeningAuctionDurationTooLarge"
	// Market proposal is missing a liquidity commitment
	ProposalRejectionReasonMarketMissingLiquidityCommitment ProposalRejectionReason = "MarketMissingLiquidityCommitment"
	// Market proposal market could not be instantiate in execution
	ProposalRejectionReasonCouldNotInstantiateMarket ProposalRejectionReason = "CouldNotInstantiateMarket"
	// Market proposal market contained invalid product definition
	ProposalRejectionReasonInvalidFutureProduct ProposalRejectionReason = "InvalidFutureProduct"
	// Market proposal is missing commitment amount
	ProposalRejectionReasonMissingCommitmentAmount ProposalRejectionReason = "MissingCommitmentAmount"
	// Market proposal have invalid fee amount
	ProposalRejectionReasonInvalidFeeAmount ProposalRejectionReason = "InvalidFeeAmount"
	// Market proposal have one or more invalid shape
	ProposalRejectionReasonInvalidShape ProposalRejectionReason = "InvalidShape"
	// Market proposal use an invalid risk parameter
	ProposalRejectionReasonInvalidRiskParameter ProposalRejectionReason = "InvalidRiskParameter"
	// Proposal declined because the majority threshold was not reached
	ProposalRejectionReasonMajorityThresholdNotReached ProposalRejectionReason = "MajorityThresholdNotReached"
	// Proposal declined because the participation threshold was not reached
	ProposalRejectionReasonParticipationThresholdNotReached ProposalRejectionReason = "ParticipationThresholdNotReached"
	// Asset details are invalid
	ProposalRejectionReasonInvalidAssetDetails ProposalRejectionReason = "InvalidAssetDetails"
)

var AllProposalRejectionReason = []ProposalRejectionReason{
	ProposalRejectionReasonCloseTimeTooSoon,
	ProposalRejectionReasonCloseTimeTooLate,
	ProposalRejectionReasonEnactTimeTooSoon,
	ProposalRejectionReasonEnactTimeTooLate,
	ProposalRejectionReasonInsufficientTokens,
	ProposalRejectionReasonInvalidInstrumentSecurity,
	ProposalRejectionReasonNoProduct,
	ProposalRejectionReasonUnsupportedProduct,
	ProposalRejectionReasonInvalidFutureMaturityTimestamp,
	ProposalRejectionReasonProductMaturityIsPassed,
	ProposalRejectionReasonNoTradingMode,
	ProposalRejectionReasonUnsupportedTradingMode,
	ProposalRejectionReasonNodeValidationFailed,
	ProposalRejectionReasonMissingBuiltinAssetField,
	ProposalRejectionReasonMissingERC20ContractAddress,
	ProposalRejectionReasonInvalidAsset,
	ProposalRejectionReasonIncompatibleTimestamps,
	ProposalRejectionReasonNoRiskParameters,
	ProposalRejectionReasonNetworkParameterInvalidKey,
	ProposalRejectionReasonNetworkParameterInvalidValue,
	ProposalRejectionReasonNetworkParameterValidationFailed,
	ProposalRejectionReasonOpeningAuctionDurationTooSmall,
	ProposalRejectionReasonOpeningAuctionDurationTooLarge,
	ProposalRejectionReasonMarketMissingLiquidityCommitment,
	ProposalRejectionReasonCouldNotInstantiateMarket,
	ProposalRejectionReasonInvalidFutureProduct,
	ProposalRejectionReasonMissingCommitmentAmount,
	ProposalRejectionReasonInvalidFeeAmount,
	ProposalRejectionReasonInvalidShape,
	ProposalRejectionReasonInvalidRiskParameter,
	ProposalRejectionReasonMajorityThresholdNotReached,
	ProposalRejectionReasonParticipationThresholdNotReached,
	ProposalRejectionReasonInvalidAssetDetails,
}

func (e ProposalRejectionReason) IsValid() bool {
	switch e {
	case ProposalRejectionReasonCloseTimeTooSoon, ProposalRejectionReasonCloseTimeTooLate, ProposalRejectionReasonEnactTimeTooSoon, ProposalRejectionReasonEnactTimeTooLate, ProposalRejectionReasonInsufficientTokens, ProposalRejectionReasonInvalidInstrumentSecurity, ProposalRejectionReasonNoProduct, ProposalRejectionReasonUnsupportedProduct, ProposalRejectionReasonInvalidFutureMaturityTimestamp, ProposalRejectionReasonProductMaturityIsPassed, ProposalRejectionReasonNoTradingMode, ProposalRejectionReasonUnsupportedTradingMode, ProposalRejectionReasonNodeValidationFailed, ProposalRejectionReasonMissingBuiltinAssetField, ProposalRejectionReasonMissingERC20ContractAddress, ProposalRejectionReasonInvalidAsset, ProposalRejectionReasonIncompatibleTimestamps, ProposalRejectionReasonNoRiskParameters, ProposalRejectionReasonNetworkParameterInvalidKey, ProposalRejectionReasonNetworkParameterInvalidValue, ProposalRejectionReasonNetworkParameterValidationFailed, ProposalRejectionReasonOpeningAuctionDurationTooSmall, ProposalRejectionReasonOpeningAuctionDurationTooLarge, ProposalRejectionReasonMarketMissingLiquidityCommitment, ProposalRejectionReasonCouldNotInstantiateMarket, ProposalRejectionReasonInvalidFutureProduct, ProposalRejectionReasonMissingCommitmentAmount, ProposalRejectionReasonInvalidFeeAmount, ProposalRejectionReasonInvalidShape, ProposalRejectionReasonInvalidRiskParameter, ProposalRejectionReasonMajorityThresholdNotReached, ProposalRejectionReasonParticipationThresholdNotReached, ProposalRejectionReasonInvalidAssetDetails:
		return true
	}
	return false
}

func (e ProposalRejectionReason) String() string {
	return string(e)
}

func (e *ProposalRejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalRejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalRejectionReason", str)
	}
	return nil
}

func (e ProposalRejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Various states a proposal can transition through:
// Open ->
// - Passed -> Enacted.
// - Rejected.
// Proposal can enter Failed state from any other state.
type ProposalState string

const (
	// Proposal became invalid and cannot be processed
	ProposalStateFailed ProposalState = "Failed"
	// Proposal is open for voting
	ProposalStateOpen ProposalState = "Open"
	// Proposal has gained enough support to be executed
	ProposalStatePassed ProposalState = "Passed"
	// Proposal didn't get enough votes
	ProposalStateDeclined ProposalState = "Declined"
	// Proposal could not gain enough support to be executed
	ProposalStateRejected ProposalState = "Rejected"
	// Proposal has been executed and the changes under this proposal have now been applied
	ProposalStateEnacted ProposalState = "Enacted"
	// Proposal is waiting for the node to run validation
	ProposalStateWaitingForNodeVote ProposalState = "WaitingForNodeVote"
)

var AllProposalState = []ProposalState{
	ProposalStateFailed,
	ProposalStateOpen,
	ProposalStatePassed,
	ProposalStateDeclined,
	ProposalStateRejected,
	ProposalStateEnacted,
	ProposalStateWaitingForNodeVote,
}

func (e ProposalState) IsValid() bool {
	switch e {
	case ProposalStateFailed, ProposalStateOpen, ProposalStatePassed, ProposalStateDeclined, ProposalStateRejected, ProposalStateEnacted, ProposalStateWaitingForNodeVote:
		return true
	}
	return false
}

func (e ProposalState) String() string {
	return string(e)
}

func (e *ProposalState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalState", str)
	}
	return nil
}

func (e ProposalState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether the placer of an order is aiming to buy or sell on the market
type Side string

const (
	// The Placer of the order is aiming to buy
	SideBuy Side = "Buy"
	// The placer of the order is aiming to sell
	SideSell Side = "Sell"
)

var AllSide = []Side{
	SideBuy,
	SideSell,
}

func (e Side) IsValid() bool {
	switch e {
	case SideBuy, SideSell:
		return true
	}
	return false
}

func (e Side) String() string {
	return string(e)
}

func (e *Side) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Side(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Side", str)
	}
	return nil
}

func (e Side) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the stake linking
type StakeLinkingStatus string

const (
	// The stake linking is pending in the vega network, this means that
	// the vega network have seen a StakeLinking, but is still to confirm
	// it's valid on the ethereum chain, and accepted by all nodes of the network
	StakeLinkingStatusPending StakeLinkingStatus = "Pending"
	// The stake linking has been accepted and processed fully (balance updated) by the network
	StakeLinkingStatusAccepted StakeLinkingStatus = "Accepted"
	// The vega network have rejected this stake linking
	StakeLinkingStatusRejected StakeLinkingStatus = "Rejected"
)

var AllStakeLinkingStatus = []StakeLinkingStatus{
	StakeLinkingStatusPending,
	StakeLinkingStatusAccepted,
	StakeLinkingStatusRejected,
}

func (e StakeLinkingStatus) IsValid() bool {
	switch e {
	case StakeLinkingStatusPending, StakeLinkingStatusAccepted, StakeLinkingStatusRejected:
		return true
	}
	return false
}

func (e StakeLinkingStatus) String() string {
	return string(e)
}

func (e *StakeLinkingStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakeLinkingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakeLinkingStatus", str)
	}
	return nil
}

func (e StakeLinkingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of stake linking
type StakeLinkingType string

const (
	// The stake is being linked (deposited) to a vega stake account
	StakeLinkingTypeLink StakeLinkingType = "Link"
	// The stake is being unlined (removed) from a vega stake account
	StakeLinkingTypeUnlink StakeLinkingType = "Unlink"
)

var AllStakeLinkingType = []StakeLinkingType{
	StakeLinkingTypeLink,
	StakeLinkingTypeUnlink,
}

func (e StakeLinkingType) IsValid() bool {
	switch e {
	case StakeLinkingTypeLink, StakeLinkingTypeUnlink:
		return true
	}
	return false
}

func (e StakeLinkingType) String() string {
	return string(e)
}

func (e *StakeLinkingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakeLinkingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakeLinkingType", str)
	}
	return nil
}

func (e StakeLinkingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid trade types
type TradeType string

const (
	// Default trade type
	TradeTypeDefault TradeType = "Default"
	// Network close-out - good
	TradeTypeNetworkCloseOutGood TradeType = "NetworkCloseOutGood"
	// Network close-out - bad
	TradeTypeNetworkCloseOutBad TradeType = "NetworkCloseOutBad"
)

var AllTradeType = []TradeType{
	TradeTypeDefault,
	TradeTypeNetworkCloseOutGood,
	TradeTypeNetworkCloseOutBad,
}

func (e TradeType) IsValid() bool {
	switch e {
	case TradeTypeDefault, TradeTypeNetworkCloseOutGood, TradeTypeNetworkCloseOutBad:
		return true
	}
	return false
}

func (e TradeType) String() string {
	return string(e)
}

func (e *TradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeType", str)
	}
	return nil
}

func (e TradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransferStatus string

const (
	// Indicate a transfer still being processed
	TransferStatusPending TransferStatus = "Pending"
	// Indicate of an transfer accepted by the vega network
	TransferStatusDone TransferStatus = "Done"
	// Indicate of an transfer rejected by the vega network
	TransferStatusRejected TransferStatus = "Rejected"
	// Indicate of a transfer stopped by the vega network
	// e.g: no funds left to cover the transfer
	TransferStatusStopped TransferStatus = "Stopped"
	// Indicate of a transfer cancel by the user
	TransferStatusCancelled TransferStatus = "Cancelled"
)

var AllTransferStatus = []TransferStatus{
	TransferStatusPending,
	TransferStatusDone,
	TransferStatusRejected,
	TransferStatusStopped,
	TransferStatusCancelled,
}

func (e TransferStatus) IsValid() bool {
	switch e {
	case TransferStatusPending, TransferStatusDone, TransferStatusRejected, TransferStatusStopped, TransferStatusCancelled:
		return true
	}
	return false
}

func (e TransferStatus) String() string {
	return string(e)
}

func (e *TransferStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransferStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransferStatus", str)
	}
	return nil
}

func (e TransferStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteValue string

const (
	// No reject a proposal
	VoteValueNo VoteValue = "No"
	// Yes accept a proposal
	VoteValueYes VoteValue = "Yes"
)

var AllVoteValue = []VoteValue{
	VoteValueNo,
	VoteValueYes,
}

func (e VoteValue) IsValid() bool {
	switch e {
	case VoteValueNo, VoteValueYes:
		return true
	}
	return false
}

func (e VoteValue) String() string {
	return string(e)
}

func (e *VoteValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteValue", str)
	}
	return nil
}

func (e VoteValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a withdrawal
type WithdrawalStatus string

const (
	// The withdrawal is open and being processed by the network
	WithdrawalStatusOpen WithdrawalStatus = "Open"
	// The withdrawal have been cancelled by the network, either because it expired, or something went wrong with the foreign chain
	WithdrawalStatusRejected WithdrawalStatus = "Rejected"
	// The withdrawal was finalized, it was first valid, the foreign chain have executed it and the network updated all accounts
	WithdrawalStatusFinalized WithdrawalStatus = "Finalized"
)

var AllWithdrawalStatus = []WithdrawalStatus{
	WithdrawalStatusOpen,
	WithdrawalStatusRejected,
	WithdrawalStatusFinalized,
}

func (e WithdrawalStatus) IsValid() bool {
	switch e {
	case WithdrawalStatusOpen, WithdrawalStatusRejected, WithdrawalStatusFinalized:
		return true
	}
	return false
}

func (e WithdrawalStatus) String() string {
	return string(e)
}

func (e *WithdrawalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WithdrawalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WithdrawalStatus", str)
	}
	return nil
}

func (e WithdrawalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
