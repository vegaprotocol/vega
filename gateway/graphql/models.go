// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"

	"code.vegaprotocol.io/vega/proto"
)

// One of the possible asset sources
type AssetSource interface {
	IsAssetSource()
}

type Oracle interface {
	IsOracle()
}

type Product interface {
	IsProduct()
}

type ProposalChange interface {
	IsProposalChange()
}

type RiskModel interface {
	IsRiskModel()
}

type TradingMode interface {
	IsTradingMode()
}

// Represents an asset in vega
type Asset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
	// The origin source of the asset (e.g: an erc20 asset)
	Source AssetSource `json:"source"`
}

// A vega builtin asset, mostly for testing purpose
type BuiltinAsset struct {
	// The id of the asset
	ID string `json:"id"`
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
}

func (BuiltinAsset) IsAssetSource() {}

// A vega builtin asset, mostly for testing purpose
type BuiltinAssetInput struct {
	// The full name of the asset (e.g: Great British Pound)
	Name string `json:"name"`
	// The symbol of the asset (e.g: GBP)
	Symbol string `json:"symbol"`
	// The total supply of the market
	TotalSupply string `json:"totalSupply"`
	// The precision of the asset
	Decimals int `json:"decimals"`
}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTrading struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (ContinuousTrading) IsTradingMode() {}

// A mode where Vega try to execute order as soon as they are received
type ContinuousTradingInput struct {
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// Frequent batch auctions trading mode
type DiscreteTrading struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

func (DiscreteTrading) IsTradingMode() {}

// Frequent batch auctions trading mode
type DiscreteTradingInput struct {
	// Duration of the discrete trading batch in nanoseconds. Maximum 1 month.
	Duration int `json:"duration"`
	// Size of an increment in price in terms of the quote currency
	TickSize string `json:"tickSize"`
}

// An asset originated from an Ethereum ERC20 Token
type Erc20 struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

func (Erc20) IsAssetSource() {}

// An asset originated from an Ethereum ERC20 Token
type ERC20Input struct {
	// The address of the erc20 contract
	ContractAddress string `json:"contractAddress"`
}

// An Ethereum oracle
type EthereumEvent struct {
	// The ID of the ethereum contract to use (string)
	ContractID string `json:"contractId"`
	// Name of the Ethereum event to listen to. (string)
	Event string `json:"event"`
}

func (EthereumEvent) IsOracle() {}

// A Future product
type Future struct {
	// The maturity date of the product (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// The name of the asset (string)
	Asset string `json:"asset"`
	// The oracle used for this product (Oracle union)
	Oracle Oracle `json:"oracle"`
}

func (Future) IsProduct() {}

type FutureProduct struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	Asset string `json:"asset"`
}

// Future product configuration
type FutureProductInput struct {
	// Future product maturity (ISO8601/RFC3339 timestamp)
	Maturity string `json:"maturity"`
	// Product asset name
	Asset string `json:"asset"`
}

// Describe something that can be traded on Vega
type Instrument struct {
	// Uniquely identify an instrument accrods all instruments available on Vega (string)
	ID string `json:"id"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18) (string)
	Code string `json:"code"`
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Metadata for this instrument
	Metadata *InstrumentMetadata `json:"metadata"`
	// A reference to or instance of a fully specified product, including all required product parameters for that product (Product union)
	Product Product `json:"product"`
}

type InstrumentConfiguration struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Future product specification
	FutureProduct *FutureProduct `json:"futureProduct"`
}

type InstrumentConfigurationInput struct {
	// Full and fairly descriptive name for the instrument
	Name string `json:"name"`
	// A short non necessarily unique code used to easily describe the instrument (e.g: FX:BTCUSD/DEC18)
	Code string `json:"code"`
	// String representing the base (e.g. BTCUSD -> BTC is base)
	BaseName string `json:"baseName"`
	// String representing the quote (e.g. BTCUSD -> USD is quote)
	QuoteName string `json:"quoteName"`
	// Future product specification
	FutureProduct *FutureProductInput `json:"futureProduct"`
}

// A set of metadata to associate to an instruments
type InstrumentMetadata struct {
	// An arbitrary list of tags to associated to associate to the Instrument (string list)
	Tags []string `json:"tags"`
}

// Parameters for the log normal risk model
type LogNormalModelParams struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

type LogNormalModelParamsInput struct {
	// mu parameter
	Mu float64 `json:"mu"`
	// r parameter
	R float64 `json:"r"`
	// sigma parameter
	Sigma float64 `json:"sigma"`
}

// A type of risk model for futures trading
type LogNormalRiskModel struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParams `json:"params"`
}

func (LogNormalRiskModel) IsRiskModel() {}

type LogNormalRiskModelInput struct {
	// Lambda parameter of the risk model
	RiskAversionParameter float64 `json:"riskAversionParameter"`
	// Tau parameter of the risk model
	Tau float64 `json:"tau"`
	// Params for the log normal risk model
	Params *LogNormalModelParamsInput `json:"params"`
}

type MarginCalculator struct {
	// The scaling factors that will be used for margin calculation
	ScalingFactors *ScalingFactors `json:"scalingFactors"`
}

// Represents a product & associated parameters that can be traded on Vega, has an associated OrderBook and Trade history
type Market struct {
	// Market ID
	ID   string `json:"id"`
	Name string `json:"name"`
	// An instance of or reference to a tradable instrument.
	TradableInstrument *TradableInstrument `json:"tradableInstrument"`
	// Definitions and required configuration for the trading mode
	TradingMode TradingMode `json:"tradingMode"`
	// decimalPlaces indicates the number of decimal places that an integer must be shifted by in order to get a correct
	// number denominated in the currency of the Market. (uint64)
	//
	// Examples:
	//   Currency     Balance  decimalPlaces  Real Balance
	//   GBP              100              0       GBP 100
	//   GBP              100              2       GBP   1.00
	//   GBP              100              4       GBP   0.01
	//   GBP                1              4       GBP   0.0001   (  0.01p  )
	//
	//   GBX (pence)      100              0       GBP   1.00     (100p     )
	//   GBX (pence)      100              2       GBP   0.01     (  1p     )
	//   GBX (pence)      100              4       GBP   0.0001   (  0.01p  )
	//   GBX (pence)        1              4       GBP   0.000001 (  0.0001p)
	DecimalPlaces int `json:"decimalPlaces"`
	// Orders on a market
	Orders []*proto.Order `json:"orders"`
	// Get account for a party or market
	Accounts []*proto.Account `json:"accounts"`
	// Trades on a market
	Trades []*proto.Trade `json:"trades"`
	// Current depth on the orderbook for this market
	Depth *proto.MarketDepth `json:"depth"`
	// Candles on a market, for the 'last' n candles, at 'interval' seconds as specified by params
	Candles []*proto.Candle `json:"candles"`
	// Query an order by reference for the given market
	OrderByReference *proto.Order `json:"orderByReference"`
	// marketData for the given market
	Data *proto.MarketData `json:"data"`
}

// A new asset proposal change
type NewAsset struct {
	// the source of the new Asset
	Source AssetSource `json:"source"`
}

func (NewAsset) IsProposalChange() {}

// A new asset to be added into vega
type NewAssetInput struct {
	// A new builtin assed to be created
	BuiltinAsset *BuiltinAssetInput `json:"builtinAsset"`
	// A new ERC20 asset to be created
	Erc20 *ERC20Input `json:"erc20"`
}

type NewMarket struct {
	// New market instrument configuration
	Instrument *InstrumentConfiguration `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters RiskModel `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// Trading mode
	TradingMode TradingMode `json:"tradingMode"`
}

func (NewMarket) IsProposalChange() {}

// Allows creating new markets on the network
type NewMarketInput struct {
	// New market instrument configuration
	Instrument *InstrumentConfigurationInput `json:"instrument"`
	// Decimal places used for the new market
	DecimalPlaces int `json:"decimalPlaces"`
	// New market risk configuration
	RiskParameters *RiskParametersInput `json:"riskParameters"`
	// Metadata for this instrument, tags
	Metadata []string `json:"metadata"`
	// A mode where Vega try to execute order as soon as they are received. Valid only if discreteTrading is not set
	ContinuousTrading *ContinuousTradingInput `json:"continuousTrading"`
	// Frequent batch auctions trading mode. Valid only if continuousTrading is not set
	DiscreteTrading *DiscreteTradingInput `json:"discreteTrading"`
}

type PreparedAmendOrder struct {
	// blob: the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedCancelOrder struct {
	// blob: the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedProposal struct {
	// Raw transaction data to sign & submit
	Blob string `json:"blob"`
	// The pending proposal
	PendingProposal *proto.GovernanceData `json:"pendingProposal"`
}

type PreparedSubmitOrder struct {
	// blob: the raw transaction to sign & submit
	Blob string `json:"blob"`
}

type PreparedVote struct {
	// Raw, serialised vote to be signed
	Blob string `json:"blob"`
	// The vote serialised in the blob field
	Vote *ProposalVote `json:"vote"`
}

type ProposalTerms struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Actual change being introduced by the proposal - action the proposal triggers if passed and enacted.
	Change ProposalChange `json:"change"`
}

// Proposal terms input. Only one kind of change is expected. Proposals with no changes or more than one will not be accepted.
type ProposalTermsInput struct {
	// ISO-8601 time and date when voting closes for this proposal.
	// Constrained by "minCloseInSeconds" and "maxCloseInSeconds" network parameters.
	ClosingDatetime string `json:"closingDatetime"`
	// ISO-8601 time and date when this proposal is executed (if passed). Note that it has to be after closing date time.
	// Constrained by "minEnactInSeconds" and "maxEnactInSeconds" network parameters.
	EnactmentDatetime string `json:"enactmentDatetime"`
	// Field defining new market change - the proposal will create new market if passed and enacted.
	// It can only be set if "updateMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	NewMarket *NewMarketInput `json:"newMarket"`
	// Field defining update market change - the proposal will update existing market if passed and enacted.
	// It can only be set if "newMarket" and "updateNetwork" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateMarket *UpdateMarketInput `json:"updateMarket"`
	// Field defining update network change - the proposal will update Vega network parameters if passed and enacted.
	// It can only be set if "newMarket" and "updateMarket" are not set (the proposal will be rejected otherwise).
	// One of "newMarket", "updateMarket", "updateNetwork" must be set (the proposal will be rejected otherwise).
	UpdateNetwork *UpdateNetworkInput `json:"updateNetwork"`
	// a new Asset proposal, this will create a new asset to be used in the vega network
	NewAsset *NewAssetInput `json:"newAsset"`
}

type ProposalVote struct {
	// Cast vote
	Vote *Vote `json:"vote"`
	// Proposal casting the vote on
	ProposalID string `json:"proposalID"`
}

type RiskParametersInput struct {
	// Simple risk model parameters. Set only if risk model is Simple
	Simple *SimpleRiskModelParamsInput `json:"simple"`
	// Log normal risk model parameters. Set only if risk model is LogNormal
	LogNormal *LogNormalRiskModelInput `json:"logNormal"`
}

type ScalingFactors struct {
	// the scaling factor that determines the margin level at which we have to search for more money
	SearchLevel float64 `json:"searchLevel"`
	// the scaling factor that determines the optimal margin level
	InitialMargin float64 `json:"initialMargin"`
	// The scaling factor that determines the overflow margin level
	CollateralRelease float64 `json:"collateralRelease"`
}

// A type of simple/dummy risk model where we can specify the risk factor long and short in params
type SimpleRiskModel struct {
	// Params for the simple risk model
	Params *SimpleRiskModelParams `json:"params"`
}

func (SimpleRiskModel) IsRiskModel() {}

// Parameters for the simple risk model
type SimpleRiskModelParams struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

type SimpleRiskModelParamsInput struct {
	// Risk factor for long
	FactorLong float64 `json:"factorLong"`
	// Risk factor for short
	FactorShort float64 `json:"factorShort"`
}

// A tradable instrument is a combination of an instrument and a risk model
type TradableInstrument struct {
	// An instance of or reference to a fully specified instrument.
	Instrument *Instrument `json:"instrument"`
	// A reference to a risk model that is valid for the instrument
	RiskModel RiskModel `json:"riskModel"`
	// Margin calculation info, currently only the scaling factors (search, initial, release) for this tradable instrument
	MarginCalculator *MarginCalculator `json:"marginCalculator"`
}

type TransactionSubmitted struct {
	Success bool `json:"success"`
}

// Incomplete change definition for governance proposal terms
// TODO: complete the type
type UpdateMarket struct {
	MarketID string `json:"marketId"`
}

func (UpdateMarket) IsProposalChange() {}

type UpdateMarketInput struct {
	MarketID string `json:"marketId"`
}

// Allows submitting a proposal for changing governance network parameters
type UpdateNetwork struct {
	// Network parameter that restricts when the earliest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MinCloseInSeconds *int `json:"minCloseInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MaxCloseInSeconds *int `json:"maxCloseInSeconds"`
	// Network parameter that restricts when the earliest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MinEnactInSeconds *int `json:"minEnactInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MaxEnactInSeconds *int `json:"maxEnactInSeconds"`
	// Network parameter that sets participation level required for any proposal to pass.
	// Value from 0 to 1.
	RequiredParticipation *float64 `json:"requiredParticipation"`
	// Network parameter that sets majority level required for any proposal to pass.
	// Value from 0.5 to 1.
	RequiredMajority *float64 `json:"requiredMajority"`
	// Network parameter that sets minimum balance required for a party
	// to be able to submit a new proposal. Value greater than 0 to 1.
	MinProposerBalance *float64 `json:"minProposerBalance"`
	// Network parameter that sets minimum balance required for a party
	// to be able to cast a vote.  Value greater than 0 to 1.
	MinVoterBalance *float64 `json:"minVoterBalance"`
}

func (UpdateNetwork) IsProposalChange() {}

// Allows submitting a proposal for changing governance network parameters
type UpdateNetworkInput struct {
	// Network parameter that restricts when the earliest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MinCloseInSeconds *int `json:"minCloseInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to close voting. Value represents duration in seconds.
	MaxCloseInSeconds *int `json:"maxCloseInSeconds"`
	// Network parameter that restricts when the earliest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MinEnactInSeconds *int `json:"minEnactInSeconds"`
	// Network parameter that restricts when the latest a proposal
	// can be set to be executed (if that proposal passed).
	// Value represents duration in seconds.
	MaxEnactInSeconds *int `json:"maxEnactInSeconds"`
	// Network parameter that sets participation level required for any proposal to pass.
	// Value from 0 to 1.
	RequiredParticipation *float64 `json:"requiredParticipation"`
	// Network parameter that sets majority level required for any proposal to pass.
	// Value from 0.5 to 1.
	RequiredMajority *float64 `json:"requiredMajority"`
	// Network parameter that sets minimum balance required for a party
	// to be able to submit a new proposal. Value greater than 0 to 1.
	MinProposerBalance *float64 `json:"minProposerBalance"`
	// Network parameter that sets minimum balance required for a party
	// to be able to cast a vote.  Value greater than 0 to 1.
	MinVoterBalance *float64 `json:"minVoterBalance"`
}

type Vote struct {
	// The vote value cast
	Value VoteValue `json:"value"`
	// The party casting the vote
	Party *proto.Party `json:"party"`
	// ISO-8601 time and date when the vote reached Vega network
	Datetime string `json:"datetime"`
}

// The various account types we have (used by collateral)
type AccountType string

const (
	// Insurance pool account - only for 'system' party
	AccountTypeInsurance AccountType = "Insurance"
	// Settlement - only for 'system' party
	AccountTypeSettlement AccountType = "Settlement"
	// Margin - The leverage account for traders
	AccountTypeMargin AccountType = "Margin"
	// General account - the account containing 'unused' collateral for traders
	AccountTypeGeneral AccountType = "General"
)

var AllAccountType = []AccountType{
	AccountTypeInsurance,
	AccountTypeSettlement,
	AccountTypeMargin,
	AccountTypeGeneral,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeInsurance, AccountTypeSettlement, AccountTypeMargin, AccountTypeGeneral:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval for trade candles when subscribing via VEGA graphql, default is I15M
type Interval string

const (
	// 1 minute interval
	IntervalI1m Interval = "I1M"
	// 5 minute interval
	IntervalI5m Interval = "I5M"
	// 15 minute interval (default)
	IntervalI15m Interval = "I15M"
	// 1 hour interval
	IntervalI1h Interval = "I1H"
	// 6 hour interval
	IntervalI6h Interval = "I6H"
	// 1 day interval
	IntervalI1d Interval = "I1D"
)

var AllInterval = []Interval{
	IntervalI1m,
	IntervalI5m,
	IntervalI15m,
	IntervalI1h,
	IntervalI6h,
	IntervalI1d,
}

func (e Interval) IsValid() bool {
	switch e {
	case IntervalI1m, IntervalI5m, IntervalI15m, IntervalI1h, IntervalI6h, IntervalI1d:
		return true
	}
	return false
}

func (e Interval) String() string {
	return string(e)
}

func (e *Interval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Interval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Interval", str)
	}
	return nil
}

func (e Interval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type signature provided by a node
type NodeSignatureKind string

const (
	// A signature for proposing a new asset into the network
	NodeSignatureKindAssetNew NodeSignatureKind = "AssetNew"
	// A signature for allowing a withdrawal of funds
	NodeSignatureKindAssetWithdrawal NodeSignatureKind = "AssetWithdrawal"
)

var AllNodeSignatureKind = []NodeSignatureKind{
	NodeSignatureKindAssetNew,
	NodeSignatureKindAssetWithdrawal,
}

func (e NodeSignatureKind) IsValid() bool {
	switch e {
	case NodeSignatureKindAssetNew, NodeSignatureKindAssetWithdrawal:
		return true
	}
	return false
}

func (e NodeSignatureKind) String() string {
	return string(e)
}

func (e *NodeSignatureKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeSignatureKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeSignatureKind", str)
	}
	return nil
}

func (e NodeSignatureKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order statuses, these determine several states for an order that cannot be expressed with other fields in Order.
type OrderStatus string

const (
	// The order is active and not cancelled or expired, it could be unfilled, partially filled or fully filled.
	// Active does not necessarily mean it's still on the order book.
	OrderStatusActive OrderStatus = "Active"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or expires.
	OrderStatusExpired OrderStatus = "Expired"
	// The order is cancelled, the order could be partially filled or unfilled before it was cancelled. It is not possible to cancel an order with 0 remaining.
	OrderStatusCancelled OrderStatus = "Cancelled"
	// This order was of type IOC or FOK and could not be processed by the matching engine due to lack of liquidity.
	OrderStatusStopped OrderStatus = "Stopped"
	// This order is fully filled with remaining equals zero.
	OrderStatusFilled OrderStatus = "Filled"
	// This order was rejected while beeing processed in the core.
	OrderStatusRejected OrderStatus = "Rejected"
	// This order was partially filled.
	OrderStatusPartiallyFilled OrderStatus = "PartiallyFilled"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusActive,
	OrderStatusExpired,
	OrderStatusCancelled,
	OrderStatusStopped,
	OrderStatusFilled,
	OrderStatusRejected,
	OrderStatusPartiallyFilled,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusActive, OrderStatusExpired, OrderStatusCancelled, OrderStatusStopped, OrderStatusFilled, OrderStatusRejected, OrderStatusPartiallyFilled:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid order types, these determine what happens when an order is added to the book
type OrderTimeInForce string

const (
	// The order either trades completely (remainingSize == 0 after adding) or not at all, does not remain on the book if it doesn't trade
	OrderTimeInForceFok OrderTimeInForce = "FOK"
	// The order trades any amount and as much as possible but does not remain on the book (whether it trades or not)
	OrderTimeInForceIoc OrderTimeInForce = "IOC"
	// This order trades any amount and as much as possible and remains on the book until it either trades completely or is cancelled
	OrderTimeInForceGtc OrderTimeInForce = "GTC"
	// This order type trades any amount and as much as possible and remains on the book until they either trade completely, are cancelled, or expires at a set time
	// NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
	OrderTimeInForceGtt OrderTimeInForce = "GTT"
)

var AllOrderTimeInForce = []OrderTimeInForce{
	OrderTimeInForceFok,
	OrderTimeInForceIoc,
	OrderTimeInForceGtc,
	OrderTimeInForceGtt,
}

func (e OrderTimeInForce) IsValid() bool {
	switch e {
	case OrderTimeInForceFok, OrderTimeInForceIoc, OrderTimeInForceGtc, OrderTimeInForceGtt:
		return true
	}
	return false
}

func (e OrderTimeInForce) String() string {
	return string(e)
}

func (e *OrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTimeInForce", str)
	}
	return nil
}

func (e OrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderType string

const (
	// the default order type
	OrderTypeMarket OrderType = "MARKET"
	// mentioned in ticket, but as yet unused order type
	OrderTypeLimit OrderType = "LIMIT"
	// Used for distressed traders, an order placed by the network to close out distressed traders
	// similar to MARKET order, only no party is attached to the order.
	OrderTypeNetwork OrderType = "NETWORK"
)

var AllOrderType = []OrderType{
	OrderTypeMarket,
	OrderTypeLimit,
	OrderTypeNetwork,
}

func (e OrderType) IsValid() bool {
	switch e {
	case OrderTypeMarket, OrderTypeLimit, OrderTypeNetwork:
		return true
	}
	return false
}

func (e OrderType) String() string {
	return string(e)
}

func (e *OrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderType", str)
	}
	return nil
}

func (e OrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Varoius states a proposal can transition through:
//   Open ->
//       - Passed -> Enacted.
//       - Rejected.
//   Proposal can enter Failed state from any other state.
type ProposalState string

const (
	// Proposal became invalid and cannot be processed
	ProposalStateFailed ProposalState = "Failed"
	// Proposal is open for voting
	ProposalStateOpen ProposalState = "Open"
	// Proposal has gained enough support to be executed
	ProposalStatePassed ProposalState = "Passed"
	// Proposal didn't get enough votes
	ProposalStateDeclined ProposalState = "Declined"
	// Proposal has could not gain enough support to be executed
	ProposalStateRejected ProposalState = "Rejected"
	// Proposal has been executed and the changes under this proposal have now been applied
	ProposalStateEnacted ProposalState = "Enacted"
)

var AllProposalState = []ProposalState{
	ProposalStateFailed,
	ProposalStateOpen,
	ProposalStatePassed,
	ProposalStateDeclined,
	ProposalStateRejected,
	ProposalStateEnacted,
}

func (e ProposalState) IsValid() bool {
	switch e {
	case ProposalStateFailed, ProposalStateOpen, ProposalStatePassed, ProposalStateDeclined, ProposalStateRejected, ProposalStateEnacted:
		return true
	}
	return false
}

func (e ProposalState) String() string {
	return string(e)
}

func (e *ProposalState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalState", str)
	}
	return nil
}

func (e ProposalState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for the order beeing rejected by the core node
type RejectionReason string

const (
	// Market id is invalid
	RejectionReasonInvalidMarketID RejectionReason = "InvalidMarketId"
	// Order id is invalid
	RejectionReasonInvalidOrderID RejectionReason = "InvalidOrderId"
	// Order is out of sequence
	RejectionReasonOrderOutOfSequence RejectionReason = "OrderOutOfSequence"
	// Remaining size in the order is invalid
	RejectionReasonInvalidRemainingSize RejectionReason = "InvalidRemainingSize"
	// Time has failed us
	RejectionReasonTimeFailure RejectionReason = "TimeFailure"
	// Unable to remove the order
	RejectionReasonOrderRemovalFailure RejectionReason = "OrderRemovalFailure"
	// Expiration time is invalid
	RejectionReasonInvalidExpirationTime RejectionReason = "InvalidExpirationTime"
	// Order reference is invalid
	RejectionReasonInvalidOrderReference RejectionReason = "InvalidOrderReference"
	// Edit is not allowed
	RejectionReasonEditNotAllowed RejectionReason = "EditNotAllowed"
	// Order amend fail
	RejectionReasonOrderAmendFailure RejectionReason = "OrderAmendFailure"
	// Order does not exist
	RejectionReasonOrderNotFound RejectionReason = "OrderNotFound"
	// Party id is invalid
	RejectionReasonInvalidPartyID RejectionReason = "InvalidPartyId"
	// Market is closed
	RejectionReasonMarketClosed RejectionReason = "MarketClosed"
	// Margin check failed
	RejectionReasonMarginCheckFailed RejectionReason = "MarginCheckFailed"
	// Order missing general account
	RejectionReasonMissingGeneralAccount RejectionReason = "MissingGeneralAccount"
	// An internal error happend
	RejectionReasonInternalError RejectionReason = "InternalError"
	// Invalid size
	RejectionReasonInvalidSize RejectionReason = "InvalidSize"
	// Invalid persistence
	RejectionReasonInvalidPersistence RejectionReason = "InvalidPersistence"
	// Invalid type
	RejectionReasonInvalidType RejectionReason = "InvalidType"
)

var AllRejectionReason = []RejectionReason{
	RejectionReasonInvalidMarketID,
	RejectionReasonInvalidOrderID,
	RejectionReasonOrderOutOfSequence,
	RejectionReasonInvalidRemainingSize,
	RejectionReasonTimeFailure,
	RejectionReasonOrderRemovalFailure,
	RejectionReasonInvalidExpirationTime,
	RejectionReasonInvalidOrderReference,
	RejectionReasonEditNotAllowed,
	RejectionReasonOrderAmendFailure,
	RejectionReasonOrderNotFound,
	RejectionReasonInvalidPartyID,
	RejectionReasonMarketClosed,
	RejectionReasonMarginCheckFailed,
	RejectionReasonMissingGeneralAccount,
	RejectionReasonInternalError,
	RejectionReasonInvalidSize,
	RejectionReasonInvalidPersistence,
	RejectionReasonInvalidType,
}

func (e RejectionReason) IsValid() bool {
	switch e {
	case RejectionReasonInvalidMarketID, RejectionReasonInvalidOrderID, RejectionReasonOrderOutOfSequence, RejectionReasonInvalidRemainingSize, RejectionReasonTimeFailure, RejectionReasonOrderRemovalFailure, RejectionReasonInvalidExpirationTime, RejectionReasonInvalidOrderReference, RejectionReasonEditNotAllowed, RejectionReasonOrderAmendFailure, RejectionReasonOrderNotFound, RejectionReasonInvalidPartyID, RejectionReasonMarketClosed, RejectionReasonMarginCheckFailed, RejectionReasonMissingGeneralAccount, RejectionReasonInternalError, RejectionReasonInvalidSize, RejectionReasonInvalidPersistence, RejectionReasonInvalidType:
		return true
	}
	return false
}

func (e RejectionReason) String() string {
	return string(e)
}

func (e *RejectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RejectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RejectionReason", str)
	}
	return nil
}

func (e RejectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether the placer of an order is aiming to buy or sell on the market
type Side string

const (
	// The Placer of the order is aiming to buy
	SideBuy Side = "Buy"
	// The placer of the order is aiming to sell
	SideSell Side = "Sell"
)

var AllSide = []Side{
	SideBuy,
	SideSell,
}

func (e Side) IsValid() bool {
	switch e {
	case SideBuy, SideSell:
		return true
	}
	return false
}

func (e Side) String() string {
	return string(e)
}

func (e *Side) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Side(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Side", str)
	}
	return nil
}

func (e Side) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid trade types
type TradeType string

const (
	// Default trade type
	TradeTypeDefault TradeType = "Default"
	// Network close-out - good
	TradeTypeNetworkCloseOutGood TradeType = "NetworkCloseOutGood"
	// Network close-out - bad
	TradeTypeNetworkCloseOutBad TradeType = "NetworkCloseOutBad"
)

var AllTradeType = []TradeType{
	TradeTypeDefault,
	TradeTypeNetworkCloseOutGood,
	TradeTypeNetworkCloseOutBad,
}

func (e TradeType) IsValid() bool {
	switch e {
	case TradeTypeDefault, TradeTypeNetworkCloseOutGood, TradeTypeNetworkCloseOutBad:
		return true
	}
	return false
}

func (e TradeType) String() string {
	return string(e)
}

func (e *TradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeType", str)
	}
	return nil
}

func (e TradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteValue string

const (
	// NO reject a proposal
	VoteValueNo VoteValue = "NO"
	// YES accept a proposal
	VoteValueYes VoteValue = "YES"
)

var AllVoteValue = []VoteValue{
	VoteValueNo,
	VoteValueYes,
}

func (e VoteValue) IsValid() bool {
	switch e {
	case VoteValueNo, VoteValueYes:
		return true
	}
	return false
}

func (e VoteValue) String() string {
	return string(e)
}

func (e *VoteValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteValue", str)
	}
	return nil
}

func (e VoteValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
